<!DOCTYPE HTML>
<html>

<!-- HEADER -->
<head>

<meta charset="UTF-8">

<title>"""
Ekphrasis
[a game about looking at things]
"""</title>

<script type="text/bitsyGameData" id="exportedGameData">
"""
Ekphrasis
[a game about looking at things]
"""

# BITSY VERSION 7.2

! ROOM_FORMAT 1

DEFAULT_FONT unicode_european_small

PAL 0
NAME blueprint
0,188,233
34,46,58
201,218,208

ROOM 0
0,0,0,0,0,6b,6c,0,0,0,0,0,0,0,6b,6c
0,6b,6c,0,0,0,0,0,0,0,0,6b,6c,0,0,0
6a,6a,6a,6a,6a,6a,6a,6a,6a,6a,6a,6a,6a,6a,6a,6a
68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68
68,67,0,69,68,68,68,67,69,68,68,68,67,0,69,68
66,0,0,0,66,6j,66,0,0,66,6j,66,0,0,0,66
66,6n,6o,6m,66,6l,66,6n,6m,66,6l,66,6n,6o,6m,66
66,6g,6i,6h,66,6l,66,6g,6h,66,6l,66,6g,6i,6h,66
66,6d,6f,6e,66,6l,66,6d,6e,66,6l,66,6d,6f,6e,66
65,6d,6f,6e,65,6k,65,6d,6e,65,6k,65,6d,6f,6e,65
62,62,62,62,62,64,62,62,62,62,63,62,62,62,62,62
62,62,62,62,64,62,62,62,62,62,62,63,62,62,62,62
62,62,62,64,62,62,62,62,62,62,62,62,63,62,62,62
5z,5z,61,5z,5z,5z,5z,5z,5z,5z,5z,5z,5z,60,5z,5z
5z,61,5z,5z,5z,5z,5z,5z,5z,5z,5z,5z,5z,5z,60,5z
61,5z,5z,5z,5z,5z,5z,5z,5z,5z,5z,5z,5z,5z,5z,60
NAME Museum Entrance
ITM 8 1,1
ITM 8 5,0
ITM 8 11,1
ITM 8 14,0
ITM 9 2,1
ITM 9 6,0
ITM 9 12,1
ITM 9 15,0
EXT 7,9 1 7,15 FX fade_b DLG l
EXT 8,9 1 8,15 FX fade_b DLG l
PAL 0

ROOM 1
5j,5f,5f,5f,5f,5f,5f,5f,5f,5f,5f,5f,5f,5f,5f,5k
5d,5o,0,0,0,0,0,0,0,0,0,0,0,5n,5o,5e
5d,0,5r,5v,5q,0,5p,0,0,0,0,0,0,0,0,5e
5d,0,5x,0,5w,0,0,0,0,0,5o,5r,5v,5q,0,5e
5d,0,5t,5u,5s,0,0,0,0,0,0,5x,0,5w,0,5e
5d,0,5y,0,0,0,5r,5v,5q,0,0,5t,5u,5s,0,5e
5d,0,0,0,0,0,5x,0,5w,0,0,0,0,0,0,5e
5d,5n,0,0,0,0,5t,5u,5s,0,0,0,0,5y,0,5e
5d,0,0,0,0,0,0,0,0,0,0,5o,0,0,0,5e
5d,0,0,5r,5v,5q,5n,0,5o,0,0,0,0,0,0,5e
5d,0,5p,5x,0,5w,0,0,0,0,5r,5v,5q,0,0,5e
5d,0,0,5t,5u,5s,0,0,0,5p,5x,0,5w,0,0,5e
5d,0,0,0,0,0,5o,0,0,0,5t,5u,5s,0,0,5e
5d,0,0,0,0,0,0,0,0,0,0,0,0,5n,0,5e
5d,5n,0,0,5o,0,0,0,0,0,0,0,0,0,5o,5e
5h,5g,5g,5g,5g,5g,5l,0,0,5m,5g,5g,5g,5g,5g,5i
NAME Sculpture Gallery
ITM 3 11,12
ITM 3 4,11
ITM 3 3,4
ITM 3 7,7
ITM 3 12,5
EXT 4,11 2 1,14 FX wave DLG b
EXT 3,4 5 1,14 FX wave DLG g
EXT 7,7 14 1,14 FX wave DLG f
EXT 12,5 13 1,14 FX wave DLG h
EXT 11,12 16 1,14 FX wave DLG t
PAL 0

ROOM 2
0,0,0,0,0,0,0,0,1,2,0,0,0,0,0,0
0,0,0,0,0,0,0,0,3,4,0,0,0,0,0,0
0,0,0,0,0,0,0,5,6,7,8,0,0,0,0,0
0,0,0,0,0,0,0,9,c,d,e,0,0,0,0,0
0,0,0,0,0,0,0,f,g,h,i,0,0,0,0,0
0,0,0,0,0,0,0,j,k,l,m,0,0,0,0,0
0,0,0,0,0,0,n,o,p,q,r,s,0,0,0,0
0,0,0,0,0,5,t,u,v,w,x,y,z,0,0,0
0,0,0,0,5,10,11,12,13,14,15,16,17,18,0,0
0,0,0,0,19,1a,1b,1c,1d,1e,1f,1g,1h,1i,0,0
0,0,0,0,1j,1k,1l,1m,1n,1o,1p,1q,1r,0,0,0
0,0,0,0,0,0,0,1s,0,1t,0,0,0,0,0,0
0,0,0,0,0,0,1u,1v,0,1w,0,0,0,0,0,0
0,0,0,0,0,1x,1y,1z,20,21,22,23,0,0,0,0
0,0,0,24,25,26,27,28,29,2a,2b,2c,0,0,0,0
0,0,0,2d,2e,2f,2g,2h,2h,2i,2j,2k,0,0,0,0
NAME dancer 1
ITM 3 14,14
EXT 14,14 3 1,14 FX wave DLG m
PAL 0

ROOM 3
0,0,0,0,0,0,0,0,0,0,0,2m,2n,0,0,0
0,0,0,0,0,0,0,0,0,0,0,2o,2p,8,0,0
0,0,0,0,0,0,0,0,0,0,0,2q,2r,2s,0,0
0,0,2t,2u,2v,2w,0,0,0,0,0,2x,2y,2z,0,0
0,30,31,32,33,34,0,0,0,0,35,36,37,38,39,0
0,0,3a,3b,3c,3d,0,0,0,3e,3f,3g,3h,3i,3j,3k
0,0,3l,3m,3n,3o,0,0,0,3p,3q,3r,3s,3t,3u,0
0,0,3v,3w,3x,3y,0,0,0,0,3z,40,41,0,0,0
0,0,42,43,44,45,0,0,0,46,47,48,49,4a,4b,0
0,0,4c,4d,4e,4f,0,0,4g,4h,4i,4j,4k,4l,4m,0
0,0,4n,4o,4p,4q,0,0,4r,0,0,0,0,4s,4m,0
0,0,0,4t,0,4u,4v,0,4r,0,0,0,0,4s,4m,0
0,0,0,4w,0,4x,4y,0,4r,0,0,0,0,4s,4m,0
0,0,0,4z,0,0,50,51,52,0,0,0,0,53,54,0
0,0,0,55,0,0,56,57,0,0,0,0,0,0,0,0
0,0,58,59,5a,0,5b,5c,0,0,0,0,0,0,0,0
NAME dancer 2
ITM 3 14,14
EXT 14,14 1 4,11 FX wave DLG n
PAL 0

ROOM 5
0,0,0,0,0,0,0,0,6r,6s,0,0,0,0,0,0
0,0,0,0,0,0,6t,6u,6v,6w,6x,6y,0,0,0,0
0,0,0,0,0,6z,70,71,72,0,73,74,0,0,0,0
0,0,0,0,0,75,0,0,76,0,77,78,0,0,0,0
0,0,0,0,0,79,7a,0,0,7b,7c,7d,0,0,0,0
0,0,0,0,0,7e,7f,7g,7h,7i,7j,7k,0,0,0,0
0,0,0,0,0,7l,7m,7n,7o,7p,7q,7r,0,0,0,0
0,0,0,0,0,7s,7t,7u,0,7v,7w,7x,0,0,0,0
0,0,0,0,0,7y,7z,0,80,81,82,83,0,0,0,0
0,0,0,0,84,85,86,0,87,88,89,7x,0,0,0,0
0,0,0,0,8a,8b,0,0,8c,8d,8e,0,0,0,0,0
0,0,0,0,8f,0,8g,0,8h,8i,8j,0,0,0,0,0
0,0,0,0,8k,8l,8m,8n,8o,8p,0,0,0,0,0,0
0,0,0,0,0,8q,8r,8s,8t,8u,0,0,0,0,0,0
0,0,0,0,0,8v,8w,8x,0,8y,0,0,0,0,0,0
0,0,0,0,0,0,8z,90,0,91,0,0,0,0,0,0
NAME Torso
ITM 3 8,5
EXT 8,5 6 1,14 FX wave DLG o
PAL 0

ROOM 6
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,9b,9c,9d,9e,9f,0,0,0,0,0,0,0,0,0
0,9g,9h,9i,9j,9k,9l,0,0,0,0,0,0,0,0,0
0,9m,9n,0,9o,93,9p,0,0,0,0,0,0,0,0,0
0,9q,9r,0,9s,9t,0,0,0,0,0,0,0,0,0,0
0,9u,94,9v,9w,9x,4j,9y,9z,0,0,0,0,0,0,0
0,a0,a1,95,96,a2,a3,97,a4,a5,a6,0,0,0,0,0
0,a7,a8,a9,aa,ab,ac,ad,ae,af,ag,ah,ai,aj,ak,0
0,al,am,98,an,0,0,0,0,0,ao,ap,aq,ar,as,0
at,au,av,aw,99,ax,ay,az,b0,b1,b2,b3,b4,b5,0,0
0,b6,b7,b8,b9,ba,bb,9a,bc,bd,be,bf,bg,0,0,0
0,0,0,0,0,0,bh,0,0,0,0,bi,bj,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME Lamp
ITM 3 13,7
ITM f 13,8
ITM g 13,6
ITM h 12,7
ITM i 12,8
ITM j 14,7
ITM k 14,8
EXT 13,7 15 1,14 FX wave DLG p
PAL 0

ROOM 7
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bk,51,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,bl,bm,bn,bo,ax,bp,bq,0,0,0,0,0,0,0,0
0,br,af,0,0,wt,ws,ws,ws,bu,bv,bw,51,0,0,0
0,bx,by,0,wt,ws,ws,ws,ws,c0,c1,c2,c3,18,0,0
0,c4,c5,c6,wt,wt,ws,ws,ws,0,c7,c8,c9,ca,cb,0
0,0,cc,cd,0,ws,ws,ws,ws,ce,cf,cg,ch,ci,cj,0
0,ck,9p,cl,cm,ws,ws,ws,ws,cn,co,cp,cq,0,0,0
cr,cs,0,0,ws,ws,ws,ws,ws,ws,cu,cv,cw,cx,0,0
cy,cz,d0,d1,51,ws,ws,ws,d3,d4,af,d5,d6,7x,0,0
d7,d8,0,0,d9,da,db,dc,dd,bq,0,0,0,0,0,0
de,df,dg,0,0,ag,dh,di,dj,dk,dl,dm,dn,0,0,0
do,dp,dq,dr,ds,dt,du,dv,dw,dx,dy,dz,e0,e1,4j,4j
0,e2,e3,e4,e5,e6,e7,e8,e9,ea,eb,ec,ed,ee,0,0
0,0,0,0,0,ef,eg,eh,ei,ag,ej,ek,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME Lion
ITM 3 14,14
EXT 14,14 10 1,14 FX wave DLG r
PAL 0

ROOM 10
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,ok,0,0,0,0,0,0,lm,0,0,0,0
0,0,0,0,ol,0,0,0,0,ln,lo,lp,lq,4j,lr,0
0,0,0,3z,ls,0,0,0,lt,lu,0,lv,lw,0,lx,0
0,ly,o6,m0,m1,c1,om,0,m2,0,m3,af,m4,m5,af,0
m6,m7,o7,0,0,0,on,oo,m8,el,gj,0,0,m9,0,0
ma,mb,0,0,mc,o8,o9,mf,mg,mh,cl,mi,0,cl,mj,0
cl,oa,ml,mm,mn,mo,mp,0,0,0,0,0,mq,mr,ms,0
0,cl,ob,0,mu,mv,0,4j,mw,h3,mx,gy,my,mz,n0,0
0,0,oc,0,n2,n3,n4,bq,0,0,0,n5,n6,n7,0,0
0,0,od,n9,na,nb,nc,nd,ne,0,nf,ng,nh,0,0,0
0,0,4m,nj,nk,nl,51,0,nm,nn,0,no,np,0,0,0
0,0,oe,a7,nr,ns,nt,0,nu,ag,nv,nw,nx,ny,0,0
0,0,of,og,af,o1,o2,0,fp,oh,oi,0,oj,ek,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME Leo
ITM a 12,3
ITM a 10,5
ITM a 12,7
ITM a 12,9
ITM a 6,9
ITM l 6,8
ITM l 3,10
ITM l 13,4
ITM 3 10,7
EXT 10,7 11 1,14 FX wave DLG s
PAL 0

ROOM 11
h7,h7,h7,h7,h7,h7,h8,h9,ha,hb,hc,hd,he,h7,h7,h7
h7,h7,h7,h7,h7,hf,hg,hh,hi,hj,hk,hl,h7,hm,hn,h7
h7,h7,h7,h7,h7,ho,hp,hq,hr,hs,ht,hu,hv,hw,hx,hy
h7,h7,hz,i0,i1,i2,i3,i4,i5,i6,i7,i8,i9,ia,ib,ic
h7,hm,id,ie,if,ig,ih,ii,ij,ik,il,im,in,io,ip,iq
h7,ir,h7,is,it,iu,iv,iw,ix,iy,iz,j0,j1,j2,j3,j4
j5,h7,h7,j6,j7,j8,j9,0,0,ja,jb,jc,jd,je,jf,jg
jh,ji,jj,jk,jl,jm,0,0,0,jn,jo,jp,jq,jr,js,jt
ju,jv,jw,jx,jy,jz,0,0,k0,k1,k2,k3,k4,k5,k6,h7
k7,k8,k9,ka,kb,kc,kd,ke,kf,kg,kh,ki,kj,kk,h7,h7
h7,kl,km,kn,ko,kp,kq,kr,ks,kt,ku,kv,kw,h7,h7,h7
kx,ky,kz,l0,l1,l2,l3,l4,l5,l6,h7,l7,id,h7,h7,h7
l8,l9,la,lb,lc,ld,le,lf,h7,h7,lg,h7,h7,h7,h7,h7
h7,lh,li,lj,lk,h7,h7,h7,h7,ll,h7,h7,h7,h7,h7,h7
h7,h7,h7,h7,h7,h7,h7,h7,h7,h7,h7,h7,h7,h7,h7,h7
h7,h7,h7,h7,h7,h7,h7,h7,h7,h7,h7,h7,h7,h7,h7,h7
NAME Supernova
ITM 3 7,7
ITM b 7,8
ITM c 7,6
ITM d 6,7
ITM e 8,7
ITM a 8,6
ITM a 6,8
END 4 7,7
PAL 0

ROOM 13
0,0,0,0,op,oq,gy,or,os,0,0,0,0,0,0,0
0,0,0,0,ot,ou,ov,ow,ox,0,0,0,0,0,0,0
0,0,0,0,oy,oz,p0,p1,p2,0,0,p3,p4,p5,0,0
0,0,0,0,p6,p7,o1,p8,p9,0,pa,pb,pc,pd,0,0
0,0,0,0,pe,pf,pg,ph,pi,pj,pk,pl,pm,pn,0,0
0,0,0,0,po,pp,pq,pr,ps,pt,pu,pv,pw,px,51,0
0,0,0,py,pz,q0,q1,q2,q3,q4,q5,q6,q7,q8,q9,0
0,0,0,qa,qb,qc,qd,qe,qf,qg,qh,qi,qj,qk,ql,0
0,0,qm,qn,qo,qp,qq,qr,qs,qt,qu,qv,qw,qx,qy,0
0,0,qz,r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,ra,rb,0
0,0,rc,rd,re,rf,rg,rh,ri,rj,rk,rl,rm,rn,0,0
0,0,ro,rp,rq,rr,rs,rt,ru,rv,rw,rx,ry,rz,0,0
0,0,s0,s1,s2,s3,s4,s5,6e,s6,s7,s8,s9,sa,0,0
0,0,sb,sc,sd,se,4s,sf,sg,sh,si,sj,sk,sl,0,0
0,0,sm,sn,so,sp,sq,sr,ss,st,su,sv,sw,sx,0,0
0,0,sy,sz,t0,7x,t1,t2,t3,t4,t5,t6,t7,0,0,0
NAME Virgin
ITM 3 6,0
ITM a 7,0
ITM l 5,0
EXT 6,0 1 12,5 FX wave DLG j
PAL 0

ROOM 14
t8,t9,ta,0,tb,0,tc,td,te,0,0,0,0,0,0,0
tf,tg,th,ti,tj,tk,tl,tm,tn,0,0,0,0,0,0,0
to,tp,tq,tr,ts,tt,tu,tv,tw,tx,0,0,0,ty,0,0
tz,u0,u1,u2,u3,u4,u5,0,u6,u7,0,0,u8,u9,ua,ub
uc,ud,ue,fe,uf,ug,uh,cc,cl,ui,uj,uk,ul,um,un,0
uo,up,uq,ur,us,ut,0,uu,uv,uw,ux,uy,0,0,0,0
uz,v0,v1,v2,v3,v4,0,4s,0,0,0,0,0,0,0,0
v5,v6,v7,v8,v9,va,vb,vc,0,0,0,0,0,0,0,0
vd,ve,vf,vg,vh,vi,vj,vk,0,0,0,0,0,0,0,0
cl,vl,vm,vn,vo,vp,vq,vr,0,0,0,0,0,0,0,0
0,vs,vt,vu,vv,vw,vx,vy,0,0,0,0,0,0,0,0
0,vz,0,w0,w1,w2,w3,w4,0,0,0,0,0,0,0,0
0,w5,0,w6,w7,w8,w9,6e,0,0,0,0,0,0,0,0
0,wa,51,wb,wc,wd,we,wf,0,0,0,0,0,0,0,0
0,0,wg,wh,z,wi,wj,wk,0,0,0,0,0,0,0,0
0,0,wl,wm,wn,wo,wp,wq,wr,0,0,0,0,0,0,0
NAME Perseus
ITM 3 14,14
EXT 14,14 1 7,7 FX wave DLG k
PAL 0

ROOM 15
0,0,0,0,0,0,0,0,6r,6s,0,0,0,0,0,0
0,0,0,0,0,0,6t,6u,6v,6w,6x,6y,0,0,0,0
0,0,0,0,0,6z,70,71,72,0,73,74,0,0,0,0
0,0,0,0,0,75,0,0,76,0,77,78,0,0,0,0
0,0,0,0,0,79,7a,0,0,7b,7c,7d,0,0,0,0
0,0,0,0,0,7e,7f,7g,7h,7i,7j,7k,0,0,0,0
0,0,0,0,0,7l,7m,7n,7o,7p,7q,7r,0,0,0,0
0,0,0,0,0,7s,7t,7u,0,7v,7w,7x,0,0,0,0
0,0,0,0,0,7y,7z,0,80,81,82,83,0,0,0,0
0,0,0,0,84,85,86,0,87,88,89,7x,0,0,0,0
0,0,0,0,8a,8b,0,0,8c,8d,8e,0,0,0,0,0
0,0,0,0,8f,0,8g,0,8h,8i,8j,0,0,0,0,0
0,0,0,0,8k,8l,8m,8n,8o,8p,0,0,0,0,0,0
0,0,0,0,0,8q,8r,8s,8t,8u,0,0,0,0,0,0
0,0,0,0,0,8v,8w,8x,0,8y,0,0,0,0,0,0
0,0,0,0,0,0,8z,90,0,91,0,0,0,0,0,0
NAME Torso 2
ITM 3 7,11
ITM 5 5,8
ITM 6 10,9
ITM 7 7,12
EXT 7,11 7 1,14 FX wave DLG q
PAL 0

ROOM 16
0,0,0,0,0,0,0,0,wu,wv,ww,0,0,0,0,0
0,0,0,0,0,0,84,wx,wy,wz,x0,x1,0,0,0,0
0,0,0,0,0,0,x2,x3,x4,x5,x6,x7,0,0,0,0
0,0,0,0,0,0,x8,x9,xa,xb,xc,xd,0,0,0,0
0,0,0,0,0,0,xe,xf,xg,xh,xi,xj,0,0,0,0
0,0,0,0,0,0,xk,xl,xm,xn,xo,xp,0,0,0,0
0,0,0,xq,xr,xs,xt,xu,xv,xw,xx,xy,xz,0,0,0
0,0,y0,y1,y2,y3,y4,y5,y6,y7,y8,y9,ya,18,0,0
0,84,yb,0,yc,yd,ye,yf,yg,yh,yi,yj,yk,yl,0,0
0,ym,0,yn,0,yo,yp,yq,cc,t1,yr,ys,yt,yu,yv,0
0,yw,yx,yy,0,0,yz,cl,cc,z0,z1,z2,z3,z4,z5,0
84,z6,z7,z8,z9,za,zb,zc,fy,zd,0,ze,zf,zg,zh,0
8a,zi,zj,zk,zl,0,0,zm,0,zn,zo,zp,zq,zr,zs,zt
zu,0,0,zv,zw,zx,0,zy,zz,100,101,102,103,104,0,cc
105,fe,0,106,107,108,109,el,10a,10b,10c,10d,10e,10f,10g,7x
10h,10i,0,0,0,10j,10k,10l,10m,10n,10o,10p,0,0,10q,10r
NAME Ugolino
ITM 3 14,14
EXT 14,14 1 11,12 FX wave DLG u
PAL 0

TIL 1
00000000
00000000
00000000
00000000
00000111
00011111
00110000
00100000
NAME dancer 1 1

TIL 2
00000000
00000000
00000000
00000000
10000000
11000000
00110000
00011000
NAME dancer 1 2

TIL 3
01000000
01011000
01000011
10000000
10000111
11000000
01000000
01100000
NAME dancer 1 3

TIL 4
00001000
11001100
00001100
00001100
00000010
00000110
00011000
00111000
NAME dancer 1 4

TIL 5
00000000
00000000
00000000
00000000
00000000
00000000
00000001
00000011
NAME dancer 1 5

TIL 6
00111111
00111111
00011111
00111111
00110111
01000011
10001010
00000000
NAME dancer 1 6

TIL 7
11100000
11100000
11100000
11110000
00011100
00011111
00111111
00010100
NAME dancer 1 7

TIL 8
00000000
00000000
00000000
00000000
00000000
00000000
10000000
11000000
NAME dancer 1 8

TIL 9
00001110
00001110
00001011
00001000
00001010
00001000
00001000
00001000
NAME dancer 1 9

TIL 10
00000110
00001100
00011000
00110000
01100000
11000000
10000001
00000010
NAME dancer 1 34

TIL 11
00100110
00000100
01000101
01001001
10010010
10010101
00100110
01001100
NAME dancer 1 35

TIL 12
10000010
10000010
00000100
00000101
00000101
01001001
00001001
00010010
NAME dancer 1 36

TIL 13
10010110
10011111
10101111
00101111
00110111
01010111
01101011
01101011
NAME dancer 1 37

TIL 14
00000110
00010110
00010011
00010011
00010011
00110011
00110011
00110011
NAME dancer 1 38

TIL 15
10101001
01100101
01100100
01010010
01010010
00010001
00001001
00001000
NAME dancer 1 39

TIL 16
00000101
00100010
10000010
10001001
10000010
01000100
00100011
10100000
NAME dancer 1 40

TIL 17
01011000
11101000
01100100
01010010
10101010
01010101
00101010
10100101
NAME dancer 1 41

TIL 18
00000000
00000000
00000000
00000000
00000000
00000000
10000000
01000000
NAME dancer 1 42

TIL 19
00000111
00001101
00110010
01100100
11001000
10011110
00111100
00001001
NAME dancer 1 43

TIL 20
00000000
00000000
00000001
00000001
00000011
11111011
10010111
00100011
NAME dancer 1 70

TIL 21
11110000
11100000
11100000
11100000
11100000
11110000
11111111
11110001
NAME dancer 1 71

TIL 22
00000000
00000000
00000000
00000000
00000000
00000000
11111100
00000011
NAME dancer 1 72

TIL 23
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11111110
NAME dancer 1 73

TIL 24
00000000
00000000
00000000
00000000
00000000
00000000
00000001
00000010
NAME dancer 1 74

TIL 25
00000001
00000110
00001000
00010000
00100000
11000001
00000001
00000000
NAME dancer 1 75

TIL 26
00000001
00000111
00001110
00111100
11111111
11111111
11111111
00000000
NAME dancer 1 76

TIL 27
11001110
10011100
00111110
11111100
11111101
11111100
11111000
00000000
NAME dancer 1 77

TIL 28
00000010
10001000
00010000
01000100
00000000
10000000
00000000
00000000
NAME dancer 1 78

TIL 29
00001011
10000111
00000011
00000000
00000000
00000000
00000000
00000000
NAME dancer 1 79

TIL 30
00000000
00000001
00000001
00000000
00000000
00000000
00000000
00000000
NAME dancer 2 15

TIL 31
01000110
11110000
11100000
01000101
01111000
00110011
01111111
01000111
NAME dancer 2 16

TIL 32
00100000
00001010
10000000
00101010
01100000
11110011
01111111
01110111
NAME dancer 2 17

TIL 33
00000000
00001010
01100000
00110100
11111111
11010110
11101111
11110111
NAME dancer 2 18

TIL 34
10110000
00110000
10011000
00011000
10111000
01111000
11110000
11110000
NAME dancer 2 19

TIL 35
00000000
00000000
00000001
00000010
00000011
00000000
00000100
00011000
NAME dancer 2 20

TIL 36
00111001
01010001
00000010
00000010
00000000
00000000
00000001
10100110
NAME dancer 2 21

TIL 37
00000011
10000001
00000000
00000001
00000001
01000001
00000001
00000001
NAME dancer 2 22

TIL 38
00000000
10001110
11001000
01000010
01000101
11101010
10101001
11000100
NAME dancer 2 23

TIL 39
00000000
00000000
10000000
11000000
01000000
00100000
10010000
01000000
NAME dancer 2 24

TIL 40
00111100
00110100
00110100
01111100
01111100
11111000
11111000
11110000
NAME dancer 2 51

TIL 41
00001111
00011111
00011111
00011111
00011110
00011110
00011110
00011100
NAME dancer 2 52

TIL 42
00000100
00000110
00000010
00000011
00000011
00000011
00000011
00000011
NAME dancer 2 53

TIL 43
00111111
00111111
00011111
00011111
00001011
10000000
10000011
11001000
NAME dancer 2 54

TIL 44
11100000
11100001
11000001
11000011
10000011
10000111
00001111
00001111
NAME dancer 2 55

TIL 45
10000000
10000000
11000000
11000000
11100000
11100000
11100000
11110000
NAME dancer 2 56

TIL 46
00000000
00000000
00000000
00000000
00000000
00000001
00000000
00001000
NAME dancer 2 57

TIL 47
00000001
00000001
00000001
00111111
10000011
00000011
00001101
01100111
NAME dancer 2 58

TIL 48
11110000
11000000
11000000
11000000
10000010
10000100
10000100
00101000
NAME dancer 2 59

TIL 49
00011100
00111000
00111000
00111000
00111111
10111100
01111111
00011111
NAME dancer 2 60

TIL 50
01111100
01111100
00111110
00111110
00011110
00001111
00001111
00001111
NAME dancer 2 87

TIL 51
00000000
00000000
00000000
00000000
00000000
00000000
00000000
10000000
NAME dancer 2 88

TIL 52
00000001
00000001
00000001
00000001
00000001
00000000
00000000
00000000
NAME dancer 2 89

TIL 53
00010000
00010000
00010000
00010000
00010000
00000000
00000000
00000000
NAME dancer 2 90

TIL 54
01000000
01000000
01000000
01000000
01000000
00000000
00000000
00000000
NAME dancer 2 91

TIL 55
00011111
00011110
00011110
00011110
00011110
00011110
00011110
00111111
NAME dancer 2 92

TIL 56
00001111
00001111
00001111
10001111
00001111
00000011
10000000
00000010
NAME dancer 2 93

TIL 57
11000000
11000000
11100000
11100000
11111000
11111100
11111110
01111110
NAME dancer 2 94

TIL 58
00000000
00000000
00000000
00000000
00000100
00000000
00000000
00000000
NAME dancer 2 95

TIL 59
01111111
00111111
00011110
00000000
00000000
00000000
00000000
00000000
NAME dancer 2 96

TIL 60
01100000
11111111
11111111
00011000
00001100
11111111
11111111
00000011
NAME Stairs Foreground Right Rail
WAL true

TIL 61
00000110
11111111
11111111
00011000
00110000
11111111
11111111
11000000
NAME Stairs Foreground Rail Left
WAL true

TIL 62
11111111
00000000
11111111
00000000
11111111
00000000
11111111
00000000
NAME Stairs Middleground

TIL 63
11111111
11000000
11111111
00110000
11111111
00001100
11111111
00000011
NAME Stairs Middleground Rail Right
WAL true

TIL 64
11111111
00000011
11111111
00001100
11111111
00110000
11111111
11000000
NAME Stairs Middleground Right Rail
WAL true

TIL 65
01000010
01001010
01000010
01010010
01111110
01000010
10111101
10000001
NAME Column Bottom
WAL true

TIL 66
01000010
01000010
01010010
01000010
01000110
01000010
01000010
01010010
NAME Column Middle
WAL true

TIL 67
11111110
00000010
11111110
00001000
11111000
00100000
01100000
11000000
NAME Column Top Right
WAL true

TIL 68
11111111
00000000
11111111
00000000
11111111
00000000
00000000
11111111
NAME Column Top Middle
WAL true

TIL 69
01111111
01000000
01111111
00010000
00011111
00000100
00000110
00000011
NAME Column Top Left
WAL true

TIL 70
00100000
01000000
10000000
10000000
00000000
00000000
00000000
00000000
NAME Torso Test 10

TIL 71
01000100
00010001
00000100
00000000
00000000
00000000
00000000
00000000
NAME Torso Test 11

TIL 72
00000000
00000000
00000000
00010000
00000000
01000000
00000000
00000000
NAME Torso Test 12

TIL 73
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000010
NAME Torso Test 13

TIL 74
00100100
00100100
00100100
01000100
01000100
10001000
10001000
10010000
NAME Torso Test 14

TIL 75
00000100
00001000
00001000
00001000
00010000
00010000
00010000
00010000
NAME Torso Test 15

TIL 76
00000000
00000000
00000000
00000000
00010000
00000000
00000000
00000000
NAME Torso Test 16

TIL 77
00000000
00000100
00000000
00001010
00000000
00000100
00000000
00000000
NAME Torso Test 17

TIL 78
00010000
10010000
00010000
00010000
00010000
00010000
01010000
00110000
NAME Torso Test 18

TIL 79
00100100
00100000
00100000
01001001
01000100
01000010
01000010
10000001
NAME Torso Test 19

TIL 80
00000000
00000000
00000000
00000000
00000000
00000000
00000000
01000000
NAME Torso Test 46

TIL 81
00010100
00000001
00000000
00000000
00001000
00000000
00000000
00000010
NAME Torso Test 47

TIL 82
00000010
00000001
00101001
00100000
00100000
00100000
00100010
01000000
NAME Torso Test 48

TIL 83
00000000
00000000
00000000
10000000
10000000
10000000
10000000
10000000
NAME Torso Test 49

TIL 84
00000000
00000000
00000000
00000000
00000000
00000000
00000001
00000001
NAME Torso Test 50

TIL 85
01000000
01100000
11100000
10110000
11011000
10001100
10100010
01000100
NAME Torso Test 51

TIL 86
00101000
00000100
00000100
00000000
00000000
00000000
00000000
10000000
NAME Torso Test 52

TIL 87
01100000
01100000
00000000
00000000
00000000
00000000
00000000
00000001
NAME Torso Test 53

TIL 88
00100000
00000000
00000000
00100000
00000100
00000000
01000000
00000000
NAME Torso Test 54

TIL 89
01000000
10000000
00001001
01000001
00000010
00000001
01000001
00000001
NAME Torso Test 55

TIL 90
01000000
01000000
01000000
01000000
01000000
11000000
11000000
11000000
NAME Torso Test 82

TIL 91
11111000
11111000
11111000
11111000
11111000
11111000
11111000
11111000
NAME Torso Test 83

TIL 92
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Hidden Wall
WAL true

TIL 93
01001110
01001110
01001100
01011000
10110001
11100001
11000010
10000010
NAME Lamp 1

TIL 94
10000010
11100011
01001001
01110000
00110100
10011110
10011010
10001101
NAME Lamp 2

TIL 95
00010111
01000010
10010000
11000001
01110000
00100000
01100010
01100011
NAME Lamp 3

TIL 96
10001100
00011101
01001101
00100110
01001110
00010000
00000000
10000000
NAME Lamp 4

TIL 97
00000000
00000111
00000000
00000000
00000000
11111100
11111111
11111111
NAME Lamp 5

TIL 98
00010100
10000000
11100101
01110000
00011001
00001100
00010110
00000011
NAME Lamp 6

TIL 99
10001000
11000000
11110000
10001000
11100110
01100001
10000001
10000000
NAME Lamp 7

TIL 100
00000000
00001000
00000000
00001000
00001000
00000000
00001000
00000001
NAME Ugolino 115

TIL 101
10000000
10000000
10000000
10001000
10001000
10001111
10010000
01110000
NAME Ugolino 116

TIL 102
00000000
00000001
01000001
10010001
10110011
10101110
00001000
00000100
NAME Ugolino 117

TIL 103
10001100
10001000
10001000
10001000
11000001
01110000
00011100
00000111
NAME Ugolino 118

TIL 104
00000000
10000100
00000000
00100000
00000000
00000000
00000000
10000000
NAME Ugolino 119

TIL 105
10000010
00011010
00010010
01100010
00000011
00000001
00001001
00000000
NAME Ugolino 120

TIL 106
00000000
00000000
00000100
00001100
01111001
00000000
00000000
00000000
NAME Ugolino 121

TIL 107
00000000
00000000
00000000
00000000
11110000
00001111
00000000
00000000
NAME Ugolino 122

TIL 108
00000110
00000111
00101011
00000011
00010011
00000111
11111111
00000000
NAME Ugolino 123

TIL 109
00000000
00000000
10000000
11000000
11100000
11110000
11111000
11001110
NAME Ugolino 124

TIL a
11111111
10000001
10000001
10011001
10011001
10000001
10000001
11111111
NAME block
WAL true

TIL b
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL c
00101000
11000000
11010000
11000000
01111101
00001111
10100101
00000001
NAME dancer 1 10

TIL d
00100010
00001001
10110111
00111100
01111000
11000100
00100000
00000001
NAME dancer 1 11

TIL e
11100000
00110000
00010000
00010000
00110000
00110000
01110000
11110000
NAME dancer 1 12

TIL f
00001100
00000100
00000100
00000100
00000100
00000010
00000010
00000010
NAME dancer 1 13

TIL g
00010100
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME dancer 1 14

TIL h
01000000
00000100
00000001
00000000
00100101
00000001
00010011
00000001
NAME dancer 1 15

TIL i
11100000
11100000
11100000
11100000
11000000
11000000
11000000
11000000
NAME dancer 1 16

TIL j
00000010
00000010
00000010
00000110
00000111
00000111
00000111
00000110
NAME dancer 1 17

TIL k
00000001
00000000
00000000
00000001
01000000
00000001
00010000
01000000
NAME dancer 1 18

TIL l
01001011
00000011
00010011
00000011
00001011
00000011
01001111
00111000
NAME dancer 1 19

TIL m
11000000
11000000
11000000
11000000
11000000
11000000
11000000
11110000
NAME dancer 1 20

TIL n
00000000
00000000
00000000
00000000
00000000
00000001
00000011
00000110
NAME dancer 1 21

TIL o
00000110
00011001
00110110
01101100
11011000
10110000
00100000
01000000
NAME dancer 1 22

TIL p
00000011
11111111
00000000
01010000
01110000
01100000
01000000
10000010
NAME dancer 1 23

TIL q
11111000
01111100
00001110
00001111
00000111
00000011
00000011
00000011
NAME dancer 1 24

TIL r
00011000
00000110
01000011
00001000
10000010
10000011
11000001
11000000
NAME dancer 1 25

TIL s
00000000
00000000
00000000
10000000
01000000
01100000
00010000
10001000
NAME dancer 1 26

TIL t
00001100
00011000
00110100
00101000
01000000
10001000
10010000
00000010
NAME dancer 1 27

TIL u
00000000
00000000
00000001
00000001
00000001
00000001
01000001
01000010
NAME dancer 1 28

TIL v
10000010
10000010
00000010
00001010
00001010
01010010
01010010
10010010
NAME dancer 1 29

TIL w
00000001
00000011
00000011
00000010
00000010
00000110
00000110
00000110
NAME dancer 1 30

TIL x
11100010
01100000
01100001
11110000
10110010
11011010
11011010
10101001
NAME dancer 1 31

TIL y
01001100
00100110
00010010
01001001
00101000
00010100
00101010
00001010
NAME dancer 1 32

TIL z
00000000
00000000
00000000
00000000
10000000
01000000
00100000
00010000
NAME dancer 1 33

TIL 1a
00000010
00000100
00000101
00001001
00010010
00100100
00100001
01000011
NAME dancer 1 44

TIL 1b
01001100
10011010
00101000
00110010
01010100
11100100
11101100
11011000
NAME dancer 1 45

TIL 1c
00010010
00100010
00100010
00100100
01010001
01100001
11110010
11110100
NAME dancer 1 46

TIL 1d
01001011
10001011
10001101
10010101
00010101
00010101
00011010
00001010
NAME dancer 1 47

TIL 1e
00110011
00110001
00110001
00110001
00110001
00110001
00110001
00110001
NAME dancer 1 48

TIL 1f
01001000
00000100
00000101
10100000
10000001
10000000
10100010
10010001
NAME dancer 1 49

TIL 1g
10010010
01010000
01010001
01101000
01110000
00110000
00111000
01111100
NAME dancer 1 50

TIL 1h
00010101
01010010
10001001
01001000
00010110
10000001
00101001
00000100
NAME dancer 1 51

TIL 1i
11000000
01110000
01011000
10011000
01010000
01100000
00100000
10000000
NAME dancer 1 52

TIL 1j
00001100
00000011
00000011
00000011
00000001
00000000
00000000
00000000
NAME dancer 1 53

TIL 1k
10000111
10000111
00011111
11111011
10111111
00000001
00000000
00000000
NAME dancer 1 54

TIL 1l
10110001
11010001
11100011
11001111
11111111
10000000
00000000
00000000
NAME dancer 1 55

TIL 1m
11100100
11101000
10011111
00010010
00011110
01111111
01111111
01111111
NAME dancer 1 56

TIL 1n
00001010
00001100
10010111
10010111
00011111
11001011
11110011
10000000
NAME dancer 1 57

TIL 1o
00110001
00110001
00110000
00101000
00011000
00110000
00110001
11111101
NAME dancer 1 58

TIL 1p
10101000
10111110
10011111
10101111
10001111
00000000
01000000
00000000
NAME dancer 1 59

TIL 1q
00111111
11100111
11110001
11000000
10000000
00000000
00000000
00000000
NAME dancer 1 60

TIL 1r
11111000
11111000
11000000
00000000
00000000
00000000
00000000
00000000
NAME dancer 1 61

TIL 1s
01111111
01111111
01111111
01111111
01111011
11111011
11111011
11111011
NAME dancer 1 62

TIL 1t
01111111
01111111
01111111
11111111
11111111
11111111
11111110
11111110
NAME dancer 1 63

TIL 1u
00000001
00000001
00000011
00000011
00000011
00000111
00000111
00000111
NAME dancer 1 64

TIL 1v
11110110
11110110
11110100
11101100
11101100
11110000
11110000
11100000
NAME dancer 1 65

TIL 1w
11111110
11111100
11111100
11111000
11111000
11110000
11110000
11110000
NAME dancer 1 66

TIL 1x
00000000
00000000
00000000
00000000
00001111
00010000
01100000
10000000
NAME dancer 1 67

TIL 1y
00000111
00001111
00001111
00001111
11111111
00111111
00111110
01110110
NAME dancer 1 68

TIL 1z
11100000
11000000
10000000
10000000
00000000
11111111
00000000
10010010
NAME dancer 1 69

TIL 2a
11111010
11111100
11111111
11111111
00111111
00000111
00000000
00000000
NAME dancer 1 80

TIL 2b
01010000
00000000
01000000
10000000
11000000
11000000
00000000
00000000
NAME dancer 1 81

TIL 2c
00000110
00000110
00001010
00010010
00010010
00100010
00100010
01000010
NAME dancer 1 82

TIL 2d
00001100
00010000
00111111
00100000
00100000
00100000
00100000
00100000
NAME dancer 1 83

TIL 2e
00000000
00000000
11110000
00001111
00000000
00000000
00000000
00000000
NAME dancer 1 84

TIL 2f
00000000
00000000
00000000
11111111
00000111
00000000
00000000
00000000
NAME dancer 1 85

TIL 2g
00000000
00000000
00000000
11111110
11111111
00000001
00000000
00000000
NAME dancer 1 86

TIL 2h
00000000
00000000
00000000
00000000
11111111
11111111
00000000
00000000
NAME dancer 1 87

TIL 2i
00000000
00000000
00000000
00000000
11100000
11111111
00111111
00000000
NAME dancer 1 88

TIL 2j
00000000
00000000
00000001
00000011
01111111
11111110
11111110
00111110
NAME dancer 1 89

TIL 2k
11000010
10000010
10000010
00000010
00000010
00000010
00000010
00000010
NAME dancer 1 90

TIL 2l
00000000
00100000
00110000
00111000
00111000
00110000
00100000
00000000
NAME Next

TIL 2m
00000000
00000000
00000000
00000000
00000000
00000001
00000001
00000010
NAME dancer 2 1

TIL 2n
00000000
00000000
00000000
10000100
10000110
00000010
00100010
00000010
NAME dancer 2 2

TIL 2o
00000011
00000001
00000000
00000000
00000000
00000001
00000010
00001100
NAME dancer 2 3

TIL 2p
00000001
00000110
11111000
01111000
11111100
00100111
01000111
11000001
NAME dancer 2 4

TIL 2q
00000111
00000101
00000000
00000000
00001000
00001000
00001000
00000100
NAME dancer 2 5

TIL 2r
00010101
11101110
01111000
00100000
00001000
00000000
00000000
00000101
NAME dancer 2 6

TIL 2s
00100000
01100000
01100000
11100000
11000000
11000000
10000000
10000000
NAME dancer 2 7

TIL 2t
00000000
00000000
00000011
00000010
00001110
00001000
00111010
01000001
NAME dancer 2 8

TIL 2u
00111100
11100011
11000010
00000000
01000000
00000100
01000000
00001010
NAME dancer 2 9

TIL 2v
00000000
11111100
00101100
00000110
10000011
00000001
00001000
00100000
NAME dancer 2 10

TIL 2w
00000000
00000000
00000000
00000000
01000000
10000000
11000000
01110000
NAME dancer 2 11

TIL 2x
00000100
00000100
00000100
00001100
00001100
00001101
00000011
00011100
NAME dancer 2 12

TIL 2y
00000000
00101011
00000101
00100001
00001011
00000110
11101110
00000011
NAME dancer 2 13

TIL 2z
10000000
10000000
10000000
10000000
10000000
11100000
00011000
00001100
NAME dancer 2 14

TIL 3a
00011110
00001111
00001011
00010011
00010011
00010011
00010011
00010011
NAME dancer 2 25

TIL 3b
11111101
10111011
10111110
11111111
00011111
11111111
00000000
11111111
NAME dancer 2 26

TIL 3c
11111011
11111111
11101100
11001001
11111111
00000000
00000000
11111111
NAME dancer 2 27

TIL 3d
11100000
10010000
11000000
10100000
10110000
10010000
10010000
10010000
NAME dancer 2 28

TIL 3e
00000000
00000000
00000000
00000001
00000000
00000010
00001000
00110100
NAME dancer 2 29

TIL 3f
00100001
01000000
10000110
10000111
00010001
00010001
00001000
01010011
NAME dancer 2 30

TIL 3g
00000110
01001000
10001000
01100001
00000101
00000101
00010110
00100000
NAME dancer 2 31

TIL 3h
01100101
11100101
10100101
00100101
11100101
01100101
01100100
00100100
NAME dancer 2 32

TIL 3i
01010110
00101000
00101000
00100100
00000010
00000001
00010101
10000111
NAME dancer 2 33

TIL 3j
01111000
00010000
01101000
10010110
00100110
01000111
00101010
00000100
NAME dancer 2 34

TIL 3k
00000000
00000000
00000000
00000000
10000000
10000000
11100000
11000000
NAME dancer 2 35

TIL 3l
00010001
00010001
00010001
00010001
00010001
00100001
00100001
00100001
NAME dancer 2 36

TIL 3m
00000000
00000000
11111111
00000000
00001111
11110000
00000000
11111111
NAME dancer 2 37

TIL 3n
00000000
11111111
00000000
00011111
11100010
00000010
00000110
11111110
NAME dancer 2 38

TIL 3o
10010000
10010000
10010000
00010000
00010000
00010000
00010000
00010000
NAME dancer 2 39

TIL 3p
00001110
00000100
00000001
00000000
00000001
00000000
00000000
00000000
NAME dancer 2 40

TIL 3q
00001101
10011110
00011110
01111100
11111101
00000000
00000000
00000000
NAME dancer 2 41

TIL 3r
00110100
00111000
01110000
11001110
11000110
00111111
00111110
00111100
NAME dancer 2 42

TIL 3s
01000100
01000100
01000100
00100100
00100010
10100100
00011110
00001111
NAME dancer 2 43

TIL 3t
11001011
10100111
11111010
10111111
11011100
00000000
00000000
00000000
NAME dancer 2 44

TIL 3u
00001010
10000101
11111000
00110000
00000000
00000000
00000000
00000000
NAME dancer 2 45

TIL 3v
00010001
00010001
00010001
00010000
00011000
00011000
00001000
00001100
NAME dancer 2 46

TIL 3w
00000000
00000000
11111111
10000000
10000000
11111111
11111111
01111111
NAME dancer 2 47

TIL 3x
00000010
00000100
11111100
00000100
00001000
11111000
11110000
11110000
NAME dancer 2 48

TIL 3y
00100000
00100000
00100000
01000000
01000000
01000000
10000000
10000000
NAME dancer 2 49

TIL 3z
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000001
NAME dancer 2 50

TIL 4a
00000000
00000000
00000000
00000000
11110000
00001111
00100000
10000001
NAME dancer 2 61

TIL 4b
00000000
00000000
00000000
00000000
00000000
11000000
11000000
01000000
NAME dancer 2 62

TIL 4c
00000011
00000011
00000011
00000011
00000011
00000011
00000011
00000011
NAME dancer 2 63

TIL 4d
11000111
11111101
11111000
11100000
11100010
11001101
11001000
11010000
NAME dancer 2 64

TIL 4e
00011111
10011111
10111111
00111111
00111111
01111111
01111111
11111111
NAME dancer 2 65

TIL 4f
11110000
11111000
11111000
11111000
11111100
11111100
11111110
11111110
NAME dancer 2 66

TIL 4g
00000000
00000000
00000000
00000000
00000001
00000001
00000001
00000001
NAME dancer 2 67

TIL 4h
00110001
00000001
01000000
00000000
11111000
00000000
00000000
00000000
NAME dancer 2 68

TIL 4i
11111111
11111110
00000000
00000000
00000000
00011111
00000000
00000000
NAME dancer 2 69

TIL 4j
00000000
00000000
00000000
00000000
00000000
11111111
00000000
00000000
NAME dancer 2 70

TIL 4k
00000001
00000000
00000000
00000000
00000000
11111000
00000111
00000000
NAME dancer 2 71

TIL 4l
10000010
00000010
00000000
00000000
00000100
01111100
11111000
00010000
NAME dancer 2 72

TIL 4m
01000000
01000000
01000000
01000000
01000000
01000000
01000000
01000000
NAME dancer 2 73

TIL 4n
00000111
00000111
00000111
00000111
00000000
00000000
00000000
00000000
NAME dancer 2 74

TIL 4o
11000001
11000011
11111111
11111111
11000001
11000001
11000001
11000001
NAME dancer 2 75

TIL 4p
11111111
11111111
11111111
11111111
00000011
00000011
00000001
00000000
NAME dancer 2 76

TIL 4q
11111110
11111111
11111111
11111110
00000110
00000110
10000010
10000011
NAME dancer 2 77

TIL 4r
00000001
00000001
00000001
00000001
00000001
00000001
00000001
00000001
NAME dancer 2 78

TIL 4s
00010000
00010000
00010000
00010000
00010000
00010000
00010000
00010000
NAME dancer 2 79

TIL 4t
11000001
11000001
11000001
01000001
01000001
01000001
01000001
01000001
NAME dancer 2 80

TIL 4u
11000001
01000001
01100001
00100000
00110000
00010011
00001111
00001111
NAME dancer 2 81

TIL 4v
00000000
00000000
10000000
10000000
11000000
11000000
11000000
11100000
NAME dancer 2 82

TIL 4w
01100010
01111110
01111110
01111111
01111111
01111111
01111111
01111111
NAME dancer 2 83

TIL 4x
00000111
00000111
00000011
00000001
00000001
00000001
00000000
00000000
NAME dancer 2 84

TIL 4y
11100000
11110000
11110000
11110000
11111000
11111000
11111000
01111100
NAME dancer 2 85

TIL 4z
01111111
01111111
01111111
01111111
00111111
00111111
00111111
00011111
NAME dancer 2 86

TIL 5a
00000000
00000000
00100000
00000010
01000000
00000000
00000000
00000000
NAME dancer 2 97

TIL 5b
01001000
00000100
00000000
00000000
00000000
00000000
00000000
00000000
NAME dancer 2 98

TIL 5c
10011100
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME dancer 2 99

TIL 5d
00000010
00001010
10000010
00100010
00000010
00000010
00001010
00000010
NAME wall left
WAL true

TIL 5e
01000000
01010010
01000000
01000000
01010000
01000000
01000100
01000000
NAME wall right
WAL true

TIL 5f
10000000
00000000
00000100
00100000
00000010
00000000
11111111
00000000
NAME wall top
WAL true

TIL 5g
00000000
11111111
00000000
01000000
00001000
00000000
00010001
00000000
NAME wall bottom
WAL true

TIL 5h
00000010
00100011
00000000
00001000
00000000
01000000
00000000
00000010
NAME wall corner SW
WAL true

TIL 5i
01010000
11000000
00000010
10000000
00000000
00010000
00000000
00000010
NAME wall corner SE
WAL true

TIL 5j
00000000
00010000
00000000
00000001
00010000
10000000
00010011
00000010
NAME wall corner NW
WAL true

TIL 5k
00000000
00010001
10000000
00000000
00010000
00000000
11000010
01000000
NAME wall corner NE
WAL true

TIL 5l
00000000
11111100
00001010
00001010
00001010
00001010
00001010
00001010
NAME entry left
WAL true

TIL 5m
00000000
00111111
01010000
01010000
01010000
01010000
01010000
01010000
NAME entry right
WAL true

TIL 5n
00000000
00100000
00010000
00000000
00000010
00000000
00100000
00000000
NAME marble texture 1 

TIL 5o
00000000
00000000
00100000
00000000
00000000
00000000
00000010
00000000
NAME marble texture 2

TIL 5p
00000000
00000100
00001000
00000000
00000000
00100000
00000100
00000010
NAME marble texture 3

TIL 5q
00000000
00000000
00001000
00010100
00001000
11000000
01100000
00100000
NAME hexagon top right

TIL 5r
00000000
00000000
00010000
00101000
00010000
00000011
00000110
00000100

TIL 5s
00100000
01100000
11000000
00001000
00010100
00001000
00000000
00000000
NAME hexgon bottom right

TIL 5t
00000100
00000110
00000011
00010000
00101000
00010000
00000000
00000000
NAME hexagon bottom left

TIL 5u
00000000
00000000
00000000
11000011
00111100
00000000
00000000
00000000
NAME heaxgon bottom

TIL 5v
00000000
00000000
00000000
00111100
11000011
00000000
00000000
00000000
NAME hexagon top

TIL 5w
00010000
00010000
00001000
00001000
00001000
00001000
00010000
00010000
NAME hexagon right

TIL 5x
00001000
00001000
00010000
00010000
00010000
00010000
00001000
00001000
NAME hexagon left

TIL 5y
00000000
00000100
00000000
00000000
00000000
00000000
01000000
00000000
NAME marble texture 5

TIL 5z
00000000
11111111
11111111
00000000
00000000
11111111
11111111
00000000
NAME Stairs Foreground

TIL 6a
00000000
00000000
01100110
10011001
11111111
00000000
00000000
11111111
NAME Building Top
WAL true

TIL 6b
00000000
00000000
00000100
00010011
01000000
01100000
00011111
00000000
NAME Cloud Left

TIL 6c
00000000
00000000
00000000
10000000
01000000
00010000
11100000
00000000

TIL 6d
01000000
01000000
01000000
01000000
01000000
01000000
01000000
01000000
NAME Entrance Left

TIL 6e
00000010
00000010
00000010
00000010
00000010
00000010
00000010
00000010
NAME Entrance Right

TIL 6f
00100100
00100100
00100100
00100100
00100100
00100100
00100100
00100100
NAME Entrance Middle

TIL 6g
00000000
00011111
00100000
01000000
01111111
01000000
01000000
01000000
NAME Entrance Top Left

TIL 6h
00000000
11111000
00000100
00000010
11111110
00000010
00000010
00000010
NAME Entrance Top Right

TIL 6i
00000000
11111111
00100100
00100100
11100111
00100100
00100100
00100100
NAME Entrance Middle Top

TIL 6j
00000000
01111110
01000010
01000010
01000010
01000010
01000010
01000010
NAME Banner Top

TIL 6k
01000010
01000010
01000010
01000010
01000010
01000010
01111110
00000000
NAME Banner Bottom

TIL 6l
01001010
01010010
01011010
01000010
01010010
01001010
01010010
01011010
NAME Banner Middle

TIL 6m
00000000
11000000
00110000
00010000
00001000
00001000
11111000
00000000
NAME Rounded Window Right

TIL 6n
00000000
00000011
00001100
00001000
00010000
00010000
00011111
00000000
NAME Rounded Window Left

TIL 6o
00111100
11000011
00000000
00000000
00000000
00000000
11111111
00000000
NAME Rounded Window Middle

TIL 6p
00010000
10001000
11000000
01000100
00100110
00000010
00010001
00010000
>
00010000
10010000
11000000
01000100
01000110
00000010
00010010
00010000
NAME Fur Test

TIL 6q
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL 6r
00000000
00000000
00000000
00000000
00000000
00000110
00011001
01100000
NAME Torso Test 1

TIL 6s
00000000
00000000
00000000
00000000
00000000
00000000
10000000
01100000
NAME Torso Test 2

TIL 6t
00000000
00000000
00000011
00000100
00001000
00010011
00010010
00100000
NAME Torso Test 3

TIL 6u
00000001
00001110
11110000
00000000
00000000
11000000
01111111
10010001
NAME Torso Test 4

TIL 6v
10000000
00000010
00000010
00010000
00100100
10000000
00000000
01000000
NAME Torso Test 5

TIL 6w
10011100
00000011
00001000
01000000
00000000
00000000
00000000
00000000
NAME Torso Test 6

TIL 6x
00000000
11000000
00111111
00000000
00000000
00000000
00000000
00000000
NAME Torso Test 7

TIL 6y
00000000
00000000
11110000
00001000
00010100
00010100
00010100
00100100
NAME Torso Test 8

TIL 6z
00000000
00000000
00000000
00000000
00000001
00000010
00000010
00000100
NAME Torso Test 9

TIL 7a
00000000
00000000
00000000
00000000
11000000
00010000
00000000
01000000
NAME Torso Test 20

TIL 7b
00000000
00000000
00000000
00000001
00000000
00000001
00000000
00000100
NAME Torso Test 21

TIL 7c
00000001
00000100
01001000
11001000
00010000
00100001
00100000
01000000
NAME Torso Test 22

TIL 7d
00110000
00010000
00010000
00010000
00010000
00010000
00010000
00100000
NAME Torso Test 23

TIL 7e
10001000
10000000
10000100
10000000
01000000
01010000
01000000
01000000
NAME Torso Test 24

TIL 7f
10010000
01100000
00011110
10000001
00000000
00000000
00000000
00000000
NAME Torso Test 25

TIL 7g
00000000
10000000
00000111
11111000
00000000
00000000
00000000
00000000
NAME Torso Test 26

TIL 7h
00000000
00000000
00000011
00000000
00000000
00000000
00000000
00000000
NAME Torso Test 27

TIL 7i
00000001
00001110
11110000
00000000
00000000
00000000
00000000
00000000
NAME Torso Test 28

TIL 7j
10000010
00000000
00001000
01000000
00000001
00000000
00000010
00001000
NAME Torso Test 29

TIL 7k
00100000
00100000
00100000
00100000
00100000
00100000
00100000
00100000
NAME Torso Test 30

TIL 7l
01000100
01000000
00100000
00100001
00010000
00010000
00001000
00001000
NAME Torso Test 31

TIL 7m
10000000
00000000
00000000
00001000
01000000
00000010
00000001
00000000
NAME Torso Test 32

TIL 7n
00000000
00000000
00000001
00000110
00001000
00110000
11000000
00000000
NAME Torso Test 33

TIL 7o
00000000
00000011
00000000
00000000
00000000
00000000
00000000
00000000
NAME Torso Test 34

TIL 7p
00000000
10000000
01111000
00000100
00000011
00000000
00000000
00000001
NAME Torso Test 35

TIL 7q
00000000
00000000
00000001
00000000
00010000
11100000
00000100
00000000
NAME Torso Test 36

TIL 7r
00100000
00100000
01000000
01000000
01000000
01000000
01000000
01000000
NAME Torso Test 37

TIL 7s
00000100
00000100
00000100
00000100
00001100
00001000
00011000
00010000
NAME Torso Test 38

TIL 7t
00000000
00000000
10010010
01000000
00000010
00000000
00001000
00000111
NAME Torso Test 39

TIL 7u
00000000
00000000
00000000
00000000
10010000
00000011
00001100
11110000
NAME Torso Test 40

TIL 7v
00000000
00000000
00010010
00000000
01100011
00011100
00000000
00000000
NAME Torso Test 41

TIL 7w
00000000
00010000
00000101
10000001
00000010
00100010
00000010
00100010
NAME Torso Test 42

TIL 7x
10000000
10000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Torso Test 43

TIL 7y
00110000
01100000
01000000
01000000
01000000
01000000
01000000
01000000
NAME Torso Test 44

TIL 7z
00000000
00000000
00000000
00000000
00001000
00001000
00010000
00001000
NAME Torso Test 45

TIL 8a
00000001
00000001
00000010
00000010
00000010
00000010
00000010
00000010
NAME Torso Test 56

TIL 8b
10000000
01010000
00000000
10000000
00000000
00000000
01000000
00000000
NAME Torso Test 57

TIL 8c
00000000
00001000
00000000
00000000
00000000
00000100
00000000
00100000
NAME Torso Test 58

TIL 8d
00010000
00000000
10000100
00000000
00000000
10000000
00000000
00010001
NAME Torso Test 59

TIL 8e
00001001
00010001
00100001
01110101
01100001
11000001
10010001
11000001
NAME Torso Test 60

TIL 8f
00000010
00000010
00000010
00000010
00000010
00000010
00000010
00000011
NAME Torso Test 61

TIL 8g
00001000
00000100
00000010
00000010
00000001
00000000
00000000
00000000
NAME Torso Test 62

TIL 8h
00000000
00000001
00010000
00000000
00000000
00000100
00000000
00100000
NAME Torso Test 63

TIL 8i
00000001
00000011
00000110
01001100
00011001
00100000
01000000
10000000
NAME Torso Test 64

TIL 8j
10000010
00100100
00000100
00001000
00010000
00100000
01000000
10000000
NAME Torso Test 65

TIL 8k
00000001
00000001
00000001
00000001
00000001
00000001
00000000
00000000
NAME Torso Test 66

TIL 8l
00000000
00000000
00000000
00000000
10000000
10000000
11000000
11000000
NAME Torso Test 67

TIL 8m
00000000
00000000
00000001
00000000
00000000
00000000
00000000
00000000
NAME Torso Test 68

TIL 8n
00000000
00000000
00100001
00110001
00011010
01001000
00001000
00101000
NAME Torso Test 69

TIL 8o
00010001
00000010
11000110
00001101
00011010
00011101
00001110
00000110
NAME Torso Test 70

TIL 8p
00000001
01000010
00000100
00001000
00011000
00111000
11101000
11101000
NAME Torso Test 71

TIL 8q
01101000
01100001
00110000
00111000
00011001
00001100
00001100
00000110
NAME Torso Test 72

TIL 8r
00000000
00100000
00000000
00000000
00000000
00000000
00100000
10000000
NAME Torso Test 73

TIL 8s
01001010
00011000
00011001
01011000
00001000
00001100
00010110
00000111
NAME Torso Test 74

TIL 8t
01000111
10000110
01001000
00001000
01010000
00100000
01000000
10000000
NAME Torso Test 75

TIL 8u
11101000
11101000
11101000
11101000
11101000
11101000
11101000
11101000
NAME Torso Test 76

TIL 8v
00000011
00000011
00000001
00000000
00000000
00000000
00000000
00000000
NAME Torso Test 77

TIL 8w
00000000
10100000
11000000
11010000
01100000
00110000
00011011
00001111
NAME Torso Test 78

TIL 8x
00000011
00010011
00000110
00001100
00011000
01100000
11000000
11000000
NAME Torso Test 79

TIL 8y
11101000
11101000
11101000
11101000
11101000
11101000
11111000
11111000
NAME Torso Test 80

TIL 8z
00000111
00000111
00000111
00000111
00000111
00000111
00000111
00000111
NAME Torso Test 81

TIL 9a
11010001
00000001
00010000
00000001
00100001
11001111
01111000
00010000
NAME Lamp 8

TIL 9b
00000000
00000000
00000000
00000000
00000000
00000011
00000110
00011000
NAME Lamp 9

TIL 9c
00000000
00000000
00001111
00110000
11100000
11100000
00111000
00001111
NAME Lamp 10

TIL 9d
00000000
00000000
11111100
00000111
00000001
01001000
00100000
11111111
NAME Lamp 11

TIL 9e
00000000
00000011
00000110
00001100
10011000
11111000
00110000
01110000
NAME Lamp 12

TIL 9f
11000000
10110000
00010000
00010000
00010000
00010000
00010000
00010000
NAME Lamp 13

TIL 9g
00000000
00000000
00000000
00000000
00000001
00000001
00000010
00000010
NAME Lamp 14

TIL 9h
00100001
01000000
10001000
11000011
00000110
00010100
01001100
00101000
NAME Lamp 15

TIL 9i
00000011
00000000
11111000
00001100
00000010
00000011
00000001
00000000
NAME Lamp 16

TIL 9j
11100111
11111100
00011000
00010000
00110000
00100000
10100000
11100000
NAME Lamp 17

TIL 9k
10110000
10110000
11110000
11111000
01011000
01011000
01001100
01001100
NAME Lamp 18

TIL 9l
00100000
00100000
00100000
00100000
01000000
01000000
01000000
01000000
NAME Lamp 19

TIL 9m
00000011
00000100
00000100
00001010
00001000
00001110
00001000
00001000
NAME Lamp 20

TIL 9n
00001000
00110000
10010000
00110000
01110000
11110000
01110000
01010000
NAME Lamp 21

TIL 9o
01100000
01000000
01000000
01000000
01000000
01000001
01000001
01000001
NAME Lamp 22

TIL 9p
10000000
10000000
10000000
10000000
00000000
00000000
00000000
00000000
NAME Lamp 23

TIL 9q
00001101
00010000
00010000
00010000
00010010
00010000
00011000
00010001
NAME Lamp 24

TIL 9r
11010000
11011000
11001000
11001000
10001100
11000100
10000100
10100110
NAME Lamp 25

TIL 9s
01000000
01000000
01000000
01100000
00100000
00110000
00110000
00110000
NAME Lamp 26

TIL 9t
00000010
00000100
00000100
00000100
00001000
00001000
00010000
00010000
NAME Lamp 27

TIL 9u
00010001
00100001
00100001
00101001
00100001
00100001
00100001
00100001
NAME Lamp 28

TIL 9v
00000000
00000000
10000000
11000000
01000000
00110000
00011000
01001100
NAME Lamp 29

TIL 9w
00110000
00110000
00010000
00011000
00011000
00001000
00111000
11101000
NAME Lamp 30

TIL 9x
00010000
00100000
00100000
01000000
01000000
01111111
10000000
10000000
NAME Lamp 31

TIL 9y
00000000
00000000
00000000
00000000
00000000
11111000
00001111
00000000
NAME Lamp 32

TIL 9z
00000000
00000000
00000000
00000000
00000000
00000000
11000000
01111110
NAME Lamp 33

TIL a0
00100001
00110001
00110000
00010000
00010000
00001000
00001000
00001100
NAME Lamp 34

TIL a1
10000110
10000111
10000001
11000000
01000000
01100000
00110000
00110000
NAME Lamp 35

TIL a2
10000000
00000000
00000000
00000000
00000000
00000001
00111111
01111111
NAME Lamp 36

TIL a3
00000000
00000000
00000000
00000000
00000000
11111111
11111111
11111111
NAME Lamp 37

TIL a4
00000011
11000000
01111000
00000111
00000001
00000000
00000000
10000000
NAME Lamp 38

TIL a5
00000000
11100000
00011000
00000110
10000011
11000000
01000000
00000000
NAME Lamp 39

TIL a6
00000000
00000000
00000000
00000000
10000000
11100000
00111000
00011100
NAME Lamp 40

TIL a7
00000100
00000110
00000011
00000001
00000000
00000000
00000000
00000000
NAME Lamp 41

TIL a8
00011000
00001100
00001111
00000011
10000000
11000000
01100000
00011000
NAME Lamp 42

TIL a9
01100100
01100000
11000100
10100000
00000000
00000010
00000100
00100000
NAME Lamp 43

TIL aa
11000000
00110000
00001110
00000001
01000000
00000000
00000000
00000000
NAME Lamp 44

TIL ab
01111111
00111111
00000000
11100000
00011110
00000000
00000000
00000000
NAME Lamp 45

TIL ac
11111111
11111111
01111111
00000000
00000000
00000000
00000000
00000000
NAME Lamp 46

TIL ad
11111111
11111111
11111000
00000000
00011111
00000000
00000000
00000000
NAME Lamp 47

TIL ae
10000000
00000010
00000000
00011000
11000000
00000000
00000000
00000000
NAME Lamp 48

TIL af
10000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Lamp 49

TIL ag
00000011
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Lamp 50

TIL ah
10000000
11111111
00000000
00000000
00000000
00000000
01111100
00000111
NAME Lamp 51

TIL ai
00000000
11111111
00000000
00000001
00000011
00000001
00000000
11000000
NAME Lamp 52

TIL aj
00000000
11111111
00000000
11111000
11111111
11111110
00000000
00000000
NAME Lamp 53

TIL ak
00000000
11000000
01111000
00001100
00000100
00000100
00000100
00000100
NAME Lamp 54

TIL al
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00010000
NAME Lamp 55

TIL am
00001100
00000011
00000000
00000000
00000000
00000001
00000000
00100000
NAME Lamp 56

TIL an
00000000
00000000
00000000
00100000
01000000
00000000
00100000
00000000
NAME Lamp 57

TIL ao
00000000
00000000
00000000
00000100
00000000
00100001
10000100
00010001
NAME Lamp 58

TIL ap
00000000
00000000
00000000
00100000
00000000
00011000
01010011
00101001
NAME Lamp 59

TIL aq
01111000
00001111
00000000
00000000
00000000
00000000
00000000
00010001
NAME Lamp 60

TIL ar
00000000
11111111
00000000
00000000
00000000
00000000
00000101
00000111
NAME Lamp 61

TIL as
01100100
10001000
00011000
00010000
00100000
01100000
10000000
00000000
NAME Lamp 62

TIL at
00000000
00000000
00000000
00000000
00001000
00000000
00000001
00000000
NAME Lamp 63

TIL au
00000000
00000000
00000000
00000000
00000000
00000000
00010000
00000010
NAME Lamp 64

TIL av
00000010
00000000
00001000
00000010
00000000
00100000
00000100
00100000
NAME Lamp 65

TIL aw
01001011
00000001
01000000
00000100
01010001
00000011
10100001
00000101
NAME Lamp 66

TIL ax
00000000
00000000
00000000
00000000
00000000
11100000
00011111
00000000
NAME Lamp 67

TIL ay
00000000
00000000
00000000
00000000
00000000
00000000
11111111
01001101
NAME Lamp 68

TIL az
00000000
00000000
00000000
00000000
00000001
00011110
11100001
10001000
NAME Lamp 69

TIL b0
00000000
00000000
00000000
00011111
11100011
00000011
00010011
00000010
NAME Lamp 70

TIL b1
00001001
00000000
00111111
11000000
00000000
00000000
00000000
01000001
NAME Lamp 71

TIL b2
01010101
01100010
11111111
00000000
00000000
00000000
00000000
00000000
NAME Lamp 72

TIL b3
01000010
01011111
11111000
00000000
00000000
00000000
00000000
00000000
NAME Lamp 73

TIL b4
01001000
11111111
00000000
00000000
00000000
00000000
00000000
00000000
NAME Lamp 74

TIL b5
00111000
11100000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Lamp 75

TIL b6
00000000
00001000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Lamp 76

TIL b7
00000001
00000100
00100000
00000000
00000001
00000000
00000000
00000000
NAME Lamp 77

TIL b8
00010000
01000001
00100100
00000000
00010010
00000000
00000000
00000000
NAME Lamp 78

TIL b9
11000000
11000000
01110000
00010000
00011100
01000011
00000000
00000000
NAME Lamp 79

TIL ba
00100001
00000000
11000100
00100000
00000000
11100001
01111111
00000010
NAME Lamp 80

TIL bb
11000100
00010011
00000010
00000000
00000000
11100001
00111111
00000010
NAME Lamp 81

TIL bc
01011110
00110100
00010000
11110100
00000001
00100000
00000100
10000000
NAME Lamp 82

TIL bd
00010000
00000000
10100101
00000000
00001000
10000000
00010010
00000000
NAME Lamp 83

TIL be
00000000
00001000
00000000
00000000
00100010
10000000
00001010
00000000
NAME Lamp 84

TIL bf
00000000
00000000
10000000
00100001
00000000
10010001
00000100
00010000
NAME Lamp 85

TIL bg
00000000
00000000
00000000
00000000
01000000
00000100
01000000
00001000
NAME Lamp 86

TIL bh
00100000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Lamp 87

TIL bi
01000000
00000010
00000000
00000000
00000000
00000000
00000000
00000000
NAME Lamp 88

TIL bj
01000010
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Lamp 89

TIL bk
00000000
00000000
00000000
00000000
00000000
00000000
11110000
00001111
NAME Lion 1

TIL bl
01111110
00000011
00000000
00000000
00000000
00000000
00000000
00000000
NAME Lion 2

TIL bm
00000000
11111100
00000011
00000000
00000000
00000000
00111000
11000000
NAME Lion 3

TIL bn
00000000
00000000
11111000
00000111
00000000
00000000
00000000
00000000
NAME Lion 4

TIL bo
00000000
00000000
00000000
10000000
01111000
00000111
00000000
00000000
NAME Lion 5

TIL bp
00000000
00000000
00000000
00000000
00000000
00000000
11000000
00111111
NAME Lion 6

TIL bq
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11000000
NAME Lion 7

TIL br
00000001
00000010
00000100
00001000
00001000
00001000
00001000
00001100
NAME Lion 8

TIL bs
00111111
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Lion 9

TIL bt
11111000
00001111
00000000
00000001
00000001
00000001
00000011
00000011
NAME Lion 10

TIL bu
00111111
11100000
11000000
10011111
10000111
00000001
00000001
10000011
NAME Lion 11

TIL bv
10000000
11000000
01111110
00110001
11000000
11100000
11100000
00000000
NAME Lion 12

TIL bw
00000000
00000000
00000000
00000000
11000000
00110000
00001110
00000001
NAME Lion 13

TIL bx
00000100
00000010
00000010
00000001
00000000
00000000
00000000
00000000
NAME Lion 14

TIL by
00000000
00000000
00000000
00000000
10000000
10000000
01100000
00010000
NAME Lion 15

TIL bz
00000011
00000011
00000001
00000000
00000010
00000000
00000000
00000000
NAME Lion 16

TIL c0
10000010
11100000
11111101
11111110
00000000
10010010
00000000
01001000
NAME Lion 17

TIL c1
00000000
11000000
10000000
00000000
00000000
00000000
00000000
00000000
NAME Lion 18

TIL c2
00000000
00000000
00000000
00000000
00000000
00000001
00000011
00000010
NAME Lion 19

TIL c3
01100000
00011000
00000100
00000100
00000010
10010001
01000000
00100000
NAME Lion 20

TIL c4
00000000
00000001
00000001
00000001
00000000
00000000
00000000
00000000
NAME Lion 21

TIL c5
00001100
00000010
00000001
00000000
10000000
10000000
10000000
10000000
NAME Lion 22

TIL c6
00000000
00000000
10000000
01000000
00100000
00110000
00010000
00001000
NAME Lion 23

TIL c7
00000010
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Lion 24

TIL c8
00000110
00000000
10101010
00000000
00000000
00000000
00000000
00000000
NAME Lion 25

TIL c9
00100000
11100000
00000000
00000000
00000000
00000000
00000000
00100001
NAME Lion 26

TIL ca
00110000
00001000
00000110
00000001
00001000
00000010
00101100
00001110
NAME Lion 27

TIL cb
00000000
00000000
00000000
10000000
01000000
01100000
00100000
00100000
NAME Lion 28

TIL cc
10000000
10000000
10000000
10000000
10000000
10000000
10000000
10000000
NAME Lion 29

TIL cd
00001000
00001000
00000100
00000100
00000100
00000010
00000010
00000010
NAME Lion 30

TIL ce
00000000
00000000
00000000
00000000
00000000
00000000
00000000
01100000
NAME Lion 31

TIL cf
00000000
00000000
00000000
00000100
00000001
00001000
00000000
00110000
NAME Lion 32

TIL cg
00000000
10000000
00100000
01001111
00001000
00010101
00010000
00100111
NAME Lion 33

TIL ch
00000000
00000000
00000000
11000000
01111110
00000011
01111110
11100000
NAME Lion 34

TIL ci
00000110
00000000
00000000
10000000
00100101
11000011
01111110
00000000
NAME Lion 35

TIL cj
11100000
10000000
10000000
10000000
10000000
00000000
00000000
00000000
NAME Lion 36

TIL ck
00000000
00000000
00000000
00000001
00000011
00001110
00111000
11100000
NAME Lion 37

TIL cl
00000001
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Lion 38

TIL cm
00000000
10000000
10000000
01000000
00100000
00010000
00001000
00000000
NAME Lion 39

TIL cn
00111000
00001110
00000000
00001001
00000000
00000010
00000000
00000000
NAME Lion 40

TIL co
01100100
00000000
00100000
01000100
00000000
00010000
00000010
00000000
NAME Lion 41

TIL cp
00111111
01000001
01001000
01100010
01011000
01101110
00110011
00011001
NAME Lion 42

TIL cq
10000000
11000000
11100000
01110000
00111000
00011000
00001100
10000010
NAME Lion 43

TIL cr
00000011
00001110
00011000
01110000
11000000
00000000
00000000
00000001
NAME Lion 44

TIL cs
00000000
00000000
00000000
00000000
00000000
00000000
00000000
01110000
NAME Lion 45

TIL ct
00000000
00000000
00000000
00000000
00000000
00000000
00000000
10000100
NAME Lion 46

TIL cu
00000101
00000000
00001010
00000000
00101001
00000000
00011111
01100000
NAME Lion 47

TIL cv
00001100
11000011
01110000
00011100
01000011
00101000
10000010
01110100
NAME Lion 48

TIL cw
11000011
11100000
00011111
00000000
00110000
00011110
00000011
00000001
NAME Lion 49

TIL cx
00000000
10000000
10000000
00000000
10000000
01000000
01000000
11000000
NAME Lion 50

TIL cy
00010000
00000000
00000000
00000000
00000000
00000001
00000001
00000001
NAME Lion 51

TIL cz
01110000
11100000
01000000
01000000
10000000
10000000
00000000
00000000
NAME Lion 52

TIL d0
00000000
00000000
10000000
11110000
00001110
00000001
00000000
00000000
NAME Lion 53

TIL d1
00000000
00000000
00000000
00000000
00000000
11100000
00011100
00000011
NAME Lion 54

TIL d2
00000000
00000000
00000000
00000000
00000000
00000000
00000001
00000000
NAME Lion 55

TIL d3
00000000
00000000
00000000
00000100
00000001
00000110
00011000
01100000
NAME Lion 56

TIL d4
01000001
00000110
00011000
01100000
10000000
00000000
00000000
00000000
NAME Lion 57

TIL d5
00011000
00001101
00000110
00000011
00000001
00000000
00000000
00000000
NAME Lion 58

TIL d6
00000000
00000001
00000001
11000011
11111100
00000000
00000000
00000000
NAME Lion 59

TIL d7
00000011
00000000
00000000
00010100
00010100
00010100
01100100
00000100
NAME Lion 60

TIL d8
00000000
00000000
00000000
00010000
00000000
00000000
00000001
00010000
NAME Lion 61

TIL d9
01110000
00011100
00000111
00000000
00000000
00000000
00000000
00000000
NAME Lion 62

TIL da
00000000
00000000
00000000
11000010
00110000
00001100
00000111
00000111
NAME Lion 63

TIL db
00000000
01000000
00000100
01000000
00000001
00001110
11110000
11111001
NAME Lion 64

TIL dc
00010001
00000110
00011000
01101111
10000001
10100000
00000100
10101000
NAME Lion 65

TIL dd
10000000
00000000
00000000
00000000
11100000
00111000
00001110
01000001
NAME Lion 66

TIL de
00000100
01111110
11000010
00000011
00000001
00000000
00000000
00000000
NAME Lion 67

TIL df
00000000
00000000
00000000
00000100
10000000
11100000
00110000
00001100
NAME Lion 68

TIL dg
00000000
00000000
00000000
00000000
00000000
10000000
00000000
00001001
NAME Lion 69

TIL dh
11100010
11110101
00111000
00001111
00000000
00000000
00000000
00000000
NAME Lion 70

TIL di
01000001
00000000
00101001
00001100
11100010
00011100
00000110
00000011
NAME Lion 71

TIL dj
00001010
00100000
00000100
01001000
00000000
01010100
00000000
10010100
NAME Lion 72

TIL dk
00110000
00011100
10100110
00000011
01000000
00100100
00000000
10000000
NAME Lion 73

TIL dl
00000000
00000000
00000000
10000000
11000000
00111000
00000111
00010000
NAME Lion 74

TIL dm
00000000
00000000
00000000
00000000
00000000
00000000
00000001
11111111
NAME Lion 75

TIL dn
00000000
00000000
00000000
00000000
00000000
00000000
11110000
00011000
NAME Lion 76

TIL do
00000000
00000000
00000000
00000000
11111111
00000000
00000000
01000100
NAME Lion 77

TIL dp
00000111
00000000
00000000
00000000
11111111
00000000
00010000
00000000
NAME Lion 78

TIL dq
00000000
11111110
00000011
00000000
11111111
00000000
00000100
00100000
NAME Lion 79

TIL dr
00101100
00000000
11100000
00011110
11111111
00000011
10000000
00010100
NAME Lion 80

TIL ds
00000000
01010010
00000000
00000100
10010000
11000011
11100101
11100000
NAME Lion 81

TIL dt
00000000
00000000
01010000
00000010
00000000
00011000
11000100
01110010
NAME Lion 82

TIL du
00000000
00000000
00000000
00000000
00000000
01000000
00000000
00000000
NAME Lion 83

TIL dv
00000000
00000000
00000000
00000000
00000000
00000010
00000000
00000000
NAME Lion 84

TIL dw
11100000
00111100
00011111
00000000
00000000
00000000
00000000
01000000
NAME Lion 85

TIL dx
00010010
00010000
11000000
11111111
00000000
00000000
00000000
00000000
NAME Lion 86

TIL dy
01000000
00001000
00000000
11100001
00110000
00011100
00000110
00000011
NAME Lion 87

TIL dz
00000000
01000000
00000000
00010000
00000000
00100010
00000000
00000000
NAME Lion 88

TIL e0
00001100
00000110
00000001
00001000
10001100
00000011
00000001
00000000
NAME Lion 89

TIL e1
00000000
00000000
10000000
11000000
00110000
00011111
10001000
01001000
NAME Lion 90

TIL e2
01000010
00000000
00000000
00000000
00000100
00000000
00000000
00000000
NAME Lion 91

TIL e3
00010010
00000000
00000000
00000100
01000000
00000000
00000000
00000000
NAME Lion 92

TIL e4
00000000
10000000
00000001
00010000
00000000
00000001
00000000
00001000
NAME Lion 93

TIL e5
01110000
01111011
00101110
00000000
00100000
00000000
01000100
00000000
NAME Lion 94

TIL e6
00001110
11111000
00100111
00000000
10001000
00000000
00000010
01000000
NAME Lion 95

TIL e7
00000000
00000000
00000011
10011110
01000000
01000001
01000001
01100001
NAME Lion 96

TIL e8
00000000
00000011
00000001
00000000
00000000
11000010
01011111
10000000
NAME Lion 97

TIL e9
00001001
00000000
11000000
00110000
00001110
01100000
11011100
00000000
NAME Lion 98

TIL ea
00000000
01100000
00111000
00001100
00000011
00000001
11111000
01011110
NAME Lion 99

TIL eb
00011001
00001100
00000011
10000001
01000000
10000000
00000000
00111000
NAME Lion 100

TIL ec
11000010
01100011
01111111
11011000
01111100
00011110
00001110
00011110
NAME Lion 101

TIL ed
10000000
11110000
11001111
00000000
10100000
00000000
00000000
00000000
NAME Lion 102

TIL ee
00111000
01001000
11000000
00000000
00000000
00000000
00000000
00000000
NAME Lion 103

TIL ef
00000000
00000000
00001000
00000000
00000000
00000000
00000000
00000000
NAME Lion 104

TIL eg
00111110
00000000
00100000
00000000
00000000
00000000
00000000
00000000
NAME Lion 105

TIL eh
00000000
00000100
10000000
00000001
00000000
00000000
00000000
00000000
NAME Lion 106

TIL ei
00000000
00010000
00000001
00000000
00000000
00000000
00000000
00000000
NAME Lion 107

TIL ej
11101111
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Lion 108

TIL ek
11110000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Lion 109

TIL el
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000011
NAME Leo 1

TIL em
00000000
00000000
00000000
00000000
00011111
01110000
10000000
00000000
NAME Leo 2

TIL en
00000000
00000000
00000000
00000000
10000000
11100000
00111000
00001110
NAME Leo 3

TIL eo
00000100
00001000
00010000
00100000
01000000
01000000
10000000
10000000
NAME Leo 4

TIL ep
00000001
00000000
00000000
00000000
00000000
00000000
00000010
00000100
NAME Leo 5

TIL eq
10000000
11100000
00110000
00001111
00000000
00000000
00110000
00001100
NAME Leo 6

TIL er
00000000
00000000
00000000
00000000
11111000
00001100
00000100
00000110
NAME Leo 7

TIL es
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000111
NAME Leo 8

TIL et
00000000
00000000
00000000
00000011
00000110
00011100
11110000
10000000
NAME Leo 9

TIL eu
00000000
00000000
00000000
11111110
00000001
00000000
01111100
00000011
NAME Leo 10

TIL ev
00000100
00000100
00001100
00001000
00001000
00001000
00001000
00001000
NAME Leo 11

TIL ew
00000000
00000000
00000000
00000000
00000001
00000010
00000100
00000000
NAME Leo 12

TIL ex
00001000
00010000
01100000
10000000
00000000
00000000
00000000
00000000
NAME Leo 13

TIL ey
00000011
00000000
00000000
00000000
00000000
00000000
00000011
00001100
NAME Leo 14

TIL ez
00000010
00000010
00000010
00000010
00000110
00001100
11111000
00000000
NAME Leo 15

TIL f0
00000000
00000001
00000111
00001100
00011001
00110110
01100100
01000100
NAME Leo 16

TIL f1
01111000
11001111
00111000
11100000
10000000
00000000
00000000
00000000
NAME Leo 17

TIL f2
00000000
11111110
00000011
00000000
00000000
00000000
00000000
00000000
NAME Leo 18

TIL f3
00000000
00000111
11111000
00000000
00000000
00000000
00000000
00000000
NAME Leo 19

TIL f4
00001000
00000100
00000100
00100000
00100000
00010000
00010000
00011000
NAME Leo 20

TIL f5
00000000
00000000
00000000
00001000
00001000
00000100
00000100
00000100
NAME Leo 21

TIL f6
00001100
00000111
00000001
00000000
00000000
00000000
00000000
00000000
NAME Leo 22

TIL f7
00000000
00000000
10000000
01000000
00100000
00010000
00001000
00001000
NAME Leo 23

TIL f8
11000100
10000100
10000100
10000100
10000100
10000100
10000100
10000100
NAME Leo 24

TIL f9
00001000
00000100
00000011
00000001
00000000
00000000
00001111
11110000
NAME Leo 25

TIL fa
00000000
00000000
00000000
00000000
00001111
11110000
00000000
00000000
NAME Leo 26

TIL fb
00000000
00000000
00000000
11100000
00000000
00000000
00000000
00000000
NAME Leo 27

TIL fc
00000000
00000000
00000000
00000000
10000000
01100000
00011000
00000000
NAME Leo 28

TIL fd
00000100
00000010
00000010
00000010
00000001
00000001
00000000
00000000
NAME Leo 29

TIL fe
00000000
00000000
00000000
00000000
00000000
00000000
10000000
10000000
NAME Leo 30

TIL ff
11000110
01000010
00100001
00100000
00010000
00010000
00001000
00000100
NAME Leo 31

TIL fg
00000000
00000000
00000000
10000000
01000000
00100000
00011000
00001111
NAME Leo 32

TIL fh
00000000
00000000
00000000
00000000
00000001
00000010
00001100
11110000
NAME Leo 33

TIL fi
00000000
00000011
00111110
11100000
10000000
00000000
00000000
00000000
NAME Leo 34

TIL fj
00000000
11111110
00000000
00000000
00000000
00000000
00000001
00000010
NAME Leo 35

TIL fk
00000000
00000001
00001110
00000000
00000000
00000000
00000000
00000000
NAME Leo 36

TIL fl
00011110
11100000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Leo 37

TIL fm
00000000
00000000
00000000
10000000
01000000
01000000
00100000
00100000
NAME Leo 38

TIL fn
00000000
00000000
00000000
00000000
00000011
00000001
00000001
00000001
NAME Leo 39

TIL fo
10000000
01000000
01000000
01000000
01000000
01000000
01000000
00000000
NAME Leo 40

TIL fp
00000011
00000001
00000000
00000000
00000000
00000000
00000000
00000000
NAME Leo 41

TIL fq
00000000
10000000
01000000
00110000
00001110
00000011
00000000
00000000
NAME Leo 42

TIL fr
00000000
00000000
00000000
00000000
00000000
11110000
00010000
00010000
NAME Leo 43

TIL fs
00000100
00001000
00010000
00100000
01000000
10000000
00000000
00000000
NAME Leo 44

TIL ft
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11111111
NAME Leo 45

TIL fu
00000000
00000000
00000000
00000000
00000000
00000000
00000111
11111000
NAME Leo 46

TIL fv
00000000
00000000
00000000
00000000
00000000
00000000
11111111
00000000
NAME Leo 47

TIL fw
00000000
00000000
00000000
00000000
00000000
00111111
11000000
00000000
NAME Leo 48

TIL fx
00010000
00010000
00000000
00000000
00000000
10000000
00000000
00000000
NAME Leo 49

TIL fy
10000000
10000000
10000000
10000000
10000000
10000000
00000000
00000000
NAME Leo 50

TIL fz
00010000
00010000
00100000
00100000
01000000
01000000
10000000
10000000
NAME Leo 51

TIL g0
00000100
00001000
00010000
00100000
01000000
00000001
00001110
00110000
NAME Leo 52

TIL g1
00000000
00000000
00000000
00000111
00111000
11000001
00000111
00001100
NAME Leo 53

TIL g2
00000000
00000000
11000000
00000000
00000000
10000000
11100000
00011000
NAME Leo 54

TIL g3
01111111
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Leo 55

TIL g4
00000000
00000000
00000000
00000000
00000000
00000010
00000010
00000110
NAME Leo 56

TIL g5
00000010
00010010
00010000
00010000
00100000
00100000
01000000
01000000
NAME Leo 57

TIL g6
00000001
00000011
00000011
00000110
00000110
00000100
00000100
00000100
NAME Leo 58

TIL g7
00000000
00000000
00000001
00000011
00000101
00011010
00100010
01000010
NAME Leo 59

TIL g8
00010000
01100000
11000000
00000000
00000000
00000000
00000000
00000000
NAME Leo 60

TIL g9
00000111
00000110
00001100
00001000
00010000
00100000
01000000
10000000
NAME Leo 61

TIL ga
00000000
10000000
01110000
00011110
00000111
00000000
00000000
00000000
NAME Leo 62

TIL gb
00000000
00000000
00000000
00000000
11000000
01111000
00001000
00001000
NAME Leo 63

TIL gc
00000000
00000000
00000000
00000000
00000000
00000000
01111111
01000000
NAME Leo 64

TIL gd
00000000
00000010
00000100
00001000
00010000
11100001
00000110
00000000
NAME Leo 65

TIL ge
00000100
00001011
00011000
00100000
01000000
10000000
00100000
00100000
NAME Leo 66

TIL gf
00001100
00001000
00001000
00010000
00010000
00010000
00010000
00010000
NAME Leo 67

TIL gg
00000000
00000001
00000011
00000010
00000100
00000100
00000100
00000100
NAME Leo 68

TIL gh
10000100
00000100
00000100
00000100
00000010
00000010
00000001
00000000
NAME Leo 69

TIL gi
00000001
00000001
00000001
00000001
00000001
00000001
00000001
10000000
NAME Leo 70

TIL gj
00001000
00001000
00001000
00001000
00001000
00001000
00001000
00001000
NAME Leo 71

TIL gk
00000000
00000001
00000001
00000011
00000110
00000100
00000100
00000100
NAME Leo 72

TIL gl
10000000
01000000
01000000
00100000
00100000
00010000
00010000
00001000
NAME Leo 73

TIL gm
00100000
00100000
00100000
00010000
00010000
00010000
00001000
00001000
NAME Leo 74

TIL gn
00010000
00010000
00010000
00100000
00100000
00100000
00100000
00110000
NAME Leo 75

TIL go
00000100
00000100
00000010
00000010
00000001
00000000
00000000
00000000
NAME Leo 76

TIL gp
00000000
00000000
00000000
00000000
00000000
10000000
01000000
00100000
NAME Leo 77

TIL gq
10000000
11000000
01000000
00100000
00010000
00010000
00001000
00001100
NAME Leo 78

TIL gr
01000000
01000000
00110000
00011000
00000100
00000010
00000011
00000001
NAME Leo 79

TIL gs
00001000
00001000
00001100
00000100
00000110
00000001
00000000
00000000
NAME Leo 80

TIL gt
00000000
00000000
00000000
00000000
00000000
10000000
11100000
00110000
NAME Leo 81

TIL gu
00001000
00000100
00000100
00000010
00000010
00000001
00000001
00000000
NAME Leo 82

TIL gv
00000100
00000100
00000100
00000010
00000011
00000000
00000000
10000000
NAME Leo 83

TIL gw
00000000
00000000
00000000
00000000
10000000
01100000
00110000
00011000
NAME Leo 84

TIL gx
00010000
00011000
00001111
00000000
00000000
00000000
00000000
00000000
NAME Leo 85

TIL gy
00000000
00000000
00000000
11111111
00000000
00000000
00000000
00000000
NAME Leo 86

TIL gz
00100000
00100000
11100000
10000000
00000000
00000000
00000000
00000000
NAME Leo 87

TIL h0
00000110
00000011
00000000
00000000
00000000
00000000
00000000
00000000
NAME Leo 88

TIL h1
00000011
11111110
00000000
00000000
00000000
00000000
00000000
00000000
NAME Leo 89

TIL h2
00001100
00000100
00000010
00000001
00000000
00000000
00000000
00000000
NAME Leo 90

TIL h3
00000000
00000000
00000000
00000000
11111111
00000000
00000000
00000000
NAME Leo 91

TIL h4
00010000
00010000
00110000
01100000
10000000
00000000
00000000
00000000
NAME Leo 92

TIL h5
01000000
00100000
00011111
00000000
00000000
00000000
00000000
00000000
NAME Leo 93

TIL h6
00001000
00111000
11100000
00000000
00000000
00000000
00000000
00000000
NAME Leo 94

TIL h7
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Leo 95

TIL h8
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111101
NAME Leo 96

TIL h9
11111111
11111111
11111111
11111111
11111110
11111111
11111111
11111111
NAME Leo 97

TIL ha
11111111
11111111
11111111
11111111
11111111
11111111
11111111
10111111
NAME Leo 98

TIL hb
11111111
11111111
11111011
11111011
11111111
01111111
11111111
11111111
NAME Leo 99

TIL hc
11111111
11111111
11111111
11111111
11111111
11111111
10111101
11111111
NAME Leo 100

TIL hd
11111111
11111111
11111111
10111111
11111111
11111111
11111111
11101111
NAME Leo 101

TIL he
11111111
11111111
11111111
11111111
11110011
11111111
11111111
10111111
NAME Leo 102

TIL hf
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11101111
NAME Leo 103

TIL hg
11111111
11111111
11111111
11111111
11111011
10111111
11111111
11111111
NAME Leo 104

TIL hh
11111111
11111111
10111111
11111111
11111110
11111100
11100001
00001111
NAME Leo 105

TIL hi
11111111
11111111
11111100
00000000
00000011
00111111
11111111
11111111
NAME Leo 106

TIL hj
11111111
11110000
00000000
11111111
11111111
11111111
11111111
11000011
NAME Leo 107

TIL hk
11111111
00001000
00010011
11111111
11111111
11111111
01111111
11111111
NAME Leo 108

TIL hl
11111111
11111111
11111111
11111111
10111111
11111111
11111111
11111111
NAME Leo 109

TIL hm
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111110
NAME Leo 110

TIL hn
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00011111
NAME Leo 111

TIL ho
11111111
11111111
11111111
11111111
11111000
11111100
11111001
11100011
NAME Leo 112

TIL hp
11111000
11000000
10000001
00011111
00111111
00111111
11101111
11111110
NAME Leo 113

TIL hq
01011111
11111111
11011111
11111111
11111111
11100110
11011110
00111001
NAME Leo 114

TIL hr
01111111
01111111
11100011
11111111
11111111
01110111
11111111
11111111
NAME Leo 115

TIL hs
11011111
11111111
11111111
11110001
00001111
11111111
11111111
11111100
NAME Leo 116

TIL ht
11111111
11111111
11110111
11111110
11111111
11111111
11111001
00000111
NAME Leo 117

TIL hu
11111111
11100000
11111111
11111111
11111111
11111100
11111000
10111111
NAME Leo 118

TIL hv
11111111
00001111
11111111
11111111
11111111
00000110
00111111
11110111
NAME Leo 119

TIL hw
11111000
11111111
11110111
11111111
11111111
00111110
11111111
11111111
NAME Leo 120

TIL hx
11100111
11111000
11111100
11000011
11001110
01111111
11111111
11111111
NAME Leo 121

TIL hy
11111111
00011111
00011111
11100111
01111011
11111100
11111111
01111111
NAME Leo 122

TIL hz
11111111
11111111
11111111
11111111
11111111
11111111
11111100
11111001
NAME Leo 123

TIL i0
11111111
11111011
11110011
11111111
11111111
11111111
11111111
11111111
NAME Leo 124

TIL i1
11111111
11111111
11111111
11111110
11111111
11111111
11111111
11111111
NAME Leo 125

TIL i2
10000011
00001111
00011111
11111111
11111011
11110011
11100111
11101111
NAME Leo 126

TIL i3
11111110
11111111
11011111
11111111
11111100
11111001
11111111
11111111
NAME Leo 127

TIL i4
01111111
11100110
11001111
00111111
01110111
11111110
11111111
01111111
NAME Leo 128

TIL i5
11111111
11111110
11100001
11011111
11111111
11111111
11111111
11111100
NAME Leo 129

TIL i6
10000000
00000111
11111111
11111111
01111011
11111111
11111111
11110111
NAME Leo 130

TIL i7
00111111
11110111
11111111
11111111
11111110
00001111
00000001
11111111
NAME Leo 131

TIL i8
11111111
11111111
11111111
11111111
11111101
11111100
11111111
11111111
NAME Leo 132

TIL i9
11111111
11111111
11111111
11111111
11111111
00011111
10000111
11111111
NAME Leo 133

TIL ia
11100111
11111111
11111111
11111110
11111111
11111011
11111000
11111111
NAME Leo 134

TIL ib
10111000
11100011
11100111
11111111
11111111
11000011
00011111
11100011
NAME Leo 135

TIL ic
00111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Leo 136

TIL id
11111011
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Leo 137

TIL ie
11111111
11111111
11111111
11111111
11111110
11111100
11111000
11111001
NAME Leo 138

TIL if
11111111
11111111
11111111
00111111
00111111
11110111
11110111
11101111
NAME Leo 139

TIL ig
11001111
10011111
00111111
01111111
11111111
11111111
11111011
11110111
NAME Leo 140

TIL ih
11111111
10111111
11111111
11111111
11111100
11111001
10111011
11111111
NAME Leo 141

TIL ii
11111111
11111100
11111111
11111100
11111111
10001111
00011111
11111111
NAME Leo 142

TIL ij
11000001
00001111
00111111
01111111
11111100
11111111
11111111
11111111
NAME Leo 143

TIL ik
11111111
11111111
11111111
00000111
11111111
11111111
11111100
11111101
NAME Leo 144

TIL il
11111111
11110111
10000111
11111111
11111111
11111111
00011111
11111011
NAME Leo 145

TIL im
11111111
10000111
11111111
11111111
11001111
11111111
01111000
11111000
NAME Leo 146

TIL in
11111111
11111111
11111111
11111100
11111000
10000011
00000011
01111100
NAME Leo 147

TIL io
11111111
11111111
11111111
11000000
00000000
11110110
11000111
00111111
NAME Leo 148

TIL ip
11111111
11111111
11111111
00000111
00110001
01111000
11111000
11111110
NAME Leo 149

TIL iq
11111111
11110111
01111111
11111111
11111111
11111111
01111011
01111111
NAME Leo 150

TIL ir
11111110
11111111
11111111
11101111
11001111
10011111
11111111
11111111
NAME Leo 151

TIL is
11111001
11111011
11111011
11111011
11100111
11100110
10000111
10001111
NAME Leo 152

TIL it
11101110
11011111
11011111
11011101
11011111
11011111
11110111
11111101
NAME Leo 153

TIL iu
11111111
11111111
11111100
11110001
11111111
01111111
11111111
11001111
NAME Leo 154

TIL iv
11111111
11111111
01111111
11111111
11111110
11110001
11000111
10011111
NAME Leo 155

TIL iw
11111111
11111111
11111111
11000111
00001111
11111111
11111111
11100000
NAME Leo 156

TIL ix
11111111
11111111
11110000
10000111
11111111
11111111
10000000
00000000
NAME Leo 157

TIL iy
11111111
11111111
01111111
11111000
11111111
11111111
00000000
00000011
NAME Leo 158

TIL iz
11111110
11111111
11110001
00001000
11000000
11111001
01111001
10111101
NAME Leo 159

TIL j0
11110001
10011101
11011111
01111110
01111111
11111000
11110000
11000111
NAME Leo 160

TIL j1
11111111
11111111
00011111
11110000
11101111
11111100
11111011
11100111
NAME Leo 161

TIL j2
11000111
11111100
11111111
11100011
11111110
01101111
11111111
11111101
NAME Leo 162

TIL j3
11111111
00001111
11001111
11101111
01101111
00111111
11111011
01111011
NAME Leo 163

TIL j4
01111111
00111111
10111111
00111111
00111111
00110111
00111111
00111111
NAME Leo 164

TIL j5
11111111
11111111
11111110
11111110
11111110
11101110
11111111
11111111
NAME Leo 165

TIL j6
11001101
10011111
10011111
11011111
10011110
00011111
00011111
00111111
NAME Leo 166

TIL j7
11101111
00111110
11111100
11111001
11111011
11101111
11111111
11111110
NAME Leo 167

TIL j8
00011111
01111110
11111001
11100111
11011111
10111111
00111100
01111000
NAME Leo 168

TIL j9
00111111
11111100
11111000
11100000
10000000
00000000
00000000
00000000
NAME Leo 169

TIL ja
00000001
00000000
00000000
00000000
00000001
00000001
00000011
00000110
NAME Leo 170

TIL jb
10011111
01011111
00011111
00011111
10011100
10011100
00011111
00111111
NAME Leo 171

TIL jc
11011111
11011111
11011110
00110110
11110110
11100111
11111111
11111110
NAME Leo 172

TIL jd
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00111111
NAME Leo 173

TIL je
11111100
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Leo 174

TIL jf
10111111
10011010
11111100
11111100
10111100
00111101
11111001
11110011
NAME Leo 175

TIL jg
00111111
01111111
01111101
01111111
11111111
11111111
11110110
11111111
NAME Leo 176

TIL jh
11111111
11111011
11111111
11101101
11101101
11111101
11111101
11111001
NAME Leo 177

TIL ji
11111111
11111111
11111111
11111111
11111111
11011111
11111111
11111111
NAME Leo 178

TIL jj
11111111
11111111
11111111
11111111
11111111
11111111
11111110
11111110
NAME Leo 179

TIL jk
00111011
00111011
01111011
01111011
01111001
01101101
11101100
11001110
NAME Leo 180

TIL jl
11100110
01111001
11111111
11111111
11111111
10000111
00011111
01111111
NAME Leo 181

TIL jm
11111000
11110000
11000000
10000000
10000000
10000000
01000000
01000000
NAME Leo 182

TIL jn
00000110
00001100
00010000
00100000
01000001
10000011
00000111
00001111
NAME Leo 183

TIL jo
00111111
01111101
01111100
11111100
11111111
11111111
11001111
11011111
NAME Leo 184

TIL jp
11111110
01001111
00011111
11111111
11111111
11110110
11000110
11000111
NAME Leo 185

TIL jq
01110000
11111000
11111111
11111111
00000111
00000011
11111000
11111110
NAME Leo 186

TIL jr
11111111
11111111
11111111
11111111
11001111
11111111
01111111
11111111
NAME Leo 187

TIL js
11100111
11001111
11011111
11111111
11111110
11111111
11111111
11011111
NAME Leo 188

TIL jt
11111111
11111111
11111111
11110111
11110111
11111111
11111111
11111111
NAME Leo 189

TIL ju
11111000
11111100
11011100
11011100
11111100
11111110
11111110
11110111
NAME Leo 190

TIL jv
11111111
11011110
11111111
00111011
00111111
00001111
00000001
00010101
NAME Leo 191

TIL jw
11111101
11111001
11111011
11111111
11111101
11011100
11111111
11111111
NAME Leo 192

TIL jx
11011111
11011111
11001100
11000000
11100011
11111111
11111111
11111111
NAME Leo 193

TIL jy
11111011
11111011
11110111
11110111
11110111
11010011
11011011
01011011
NAME Leo 194

TIL jz
01000000
01000000
01100000
01110000
10111000
11011110
11100000
11111100
NAME Leo 195

TIL k0
00000000
00000000
00000000
00000001
00000011
00001111
00111111
11111100
NAME Leo 196

TIL k1
00011111
00111111
01111110
11111100
11100011
10001111
00111111
01111111
NAME Leo 197

TIL k2
00011110
00111110
01111111
11111111
11111111
11100111
11011111
11111111
NAME Leo 198

TIL k3
00001111
11111111
11111111
11111000
11111001
10001111
10111111
01111111
NAME Leo 199

TIL k4
11111111
11111110
11111111
01111111
11111111
11111111
11111111
11111110
NAME Leo 200

TIL k5
01111111
00011111
00111111
00111111
00111111
01111111
01111111
11111111
NAME Leo 201

TIL k6
11111111
11111111
11111111
11111101
11111111
11111111
11111111
11111111
NAME Leo 202

TIL k7
11110111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Leo 203

TIL k8
11100000
11111000
01111111
11101111
01111111
11111101
11111111
11010111
NAME Leo 204

TIL k9
01000000
00011100
00000011
11111111
11110111
10111111
11111110
11101101
NAME Leo 205

TIL ka
01100011
00000111
11111111
11111111
10111011
11111110
00000110
11110000
NAME Leo 206

TIL kb
01101100
10000111
11111111
01111101
11111111
01110111
00000010
00100100
NAME Leo 207

TIL kc
11111111
00001111
00011111
11111111
11110110
11111111
00111111
00111011
NAME Leo 208

TIL kd
11000000
11111111
11111111
00000000
00011001
10111011
10111110
11111110
NAME Leo 209

TIL ke
00011111
11111111
11111111
00000001
01111111
11111111
01110011
11111111
NAME Leo 210

TIL kf
11111111
11111111
11111111
11100111
11111111
11111111
11111110
11111100
NAME Leo 211

TIL kg
11111111
11111111
11101111
11111100
11111111
11000111
00001111
11111111
NAME Leo 212

TIL kh
11111111
00111110
01110011
01111111
11111111
11111111
10011111
00111111
NAME Leo 213

TIL ki
01111111
01101111
11111111
11111111
11111111
01111111
01111111
11111111
NAME Leo 214

TIL kj
11111110
11111101
11111101
11111101
11111011
11111111
11111111
11111111
NAME Leo 215

TIL kk
11111111
11111111
11110111
11111111
11111111
11011111
11111111
11111111
NAME Leo 216

TIL kl
11111111
11111111
11111101
11111110
11111111
11111111
11111111
11111111
NAME Leo 217

TIL km
01111111
11111011
11111111
11011111
11011111
11111011
11111111
11111111
NAME Leo 218

TIL kn
11111111
11111111
11111111
11011110
11111111
11110111
11111111
11111111
NAME Leo 219

TIL ko
11111111
11110111
11100011
00001111
11111111
11111111
01110111
11101111
NAME Leo 220

TIL kp
11111111
11111111
01111111
00111100
11111111
10111111
11111110
11110000
NAME Leo 221

TIL kq
11111111
10011111
11111111
11111110
11111100
11111100
11000000
01000010
NAME Leo 222

TIL kr
11111111
11111100
10000011
00000011
11000111
00000111
01111111
11111111
NAME Leo 223

TIL ks
11001111
00011111
01111111
11111111
11110111
11110111
11111111
11111111
NAME Leo 224

TIL kt
11111111
11111111
10111101
00011100
10111111
11111111
11111111
11111111
NAME Leo 225

TIL ku
01111111
11111111
11101111
11101111
11111111
11111111
11111111
11111111
NAME Leo 226

TIL kv
11111111
11111111
11111111
11111111
11111111
11111110
11111110
11111111
NAME Leo 227

TIL kw
11111111
11110011
11110011
11111111
00111111
00111111
00111111
11110011
NAME Leo 228

TIL kx
11111111
11011111
11111111
11111111
11111111
11111101
11011111
11100111
NAME Leo 229

TIL ky
11111111
11111111
11110111
11111111
11111111
11111111
11101111
11111111
NAME Leo 230

TIL kz
11111111
10111111
11111111
11111111
11111101
11111100
10111110
11111111
NAME Leo 231

TIL l0
11110111
11111110
11111111
11001111
11011111
10010111
01111111
11111111
NAME Leo 232

TIL l1
11111110
11111111
11111110
11001111
00111111
11110100
11110000
11100001
NAME Leo 233

TIL l2
01111101
01111000
01111000
11110000
10000001
00010011
01111110
11111111
NAME Leo 234

TIL l3
00001111
00001111
00111111
11111110
11111100
11101111
01100011
11111111
NAME Leo 235

TIL l4
11111100
11111110
11111111
01001111
11011100
11111111
11111111
11111111
NAME Leo 236

TIL l5
00111111
00111111
11111111
11111111
11111001
01111111
11111111
11111111
NAME Leo 237

TIL l6
11100111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Leo 238

TIL l7
11111111
11111111
11111111
11111111
11011111
11111111
11111111
11111111
NAME Leo 239

TIL l8
11111000
11111100
11111111
11111111
11111101
11111111
11111111
11111111
NAME Leo 240

TIL l9
00111111
00001101
10000000
11100111
11111111
11111011
11111111
11111111
NAME Leo 241

TIL la
11111111
01101110
00000000
10000000
11111110
11111111
11101111
11111110
NAME Leo 242

TIL lb
11111110
11100000
00010000
00111001
11111111
11111111
11111111
00011100
NAME Leo 243

TIL lc
00001111
00001111
00111111
11111011
11111111
11111111
00111111
01111111
NAME Leo 244

TIL ld
10111111
10111011
11111111
10011111
01111111
11111111
11111110
11111111
NAME Leo 245

TIL le
11111111
11011111
11111000
11100111
11111111
11111111
11111111
11111111
NAME Leo 246

TIL lf
11101111
00011111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Leo 247

TIL lg
11110011
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Leo 248

TIL lh
11111111
11111111
11110111
11111111
11111111
11111111
11111111
11111111
NAME Leo 249

TIL li
10011110
11111111
11111111
11111011
11111111
11111111
11111111
11111111
NAME Leo 250

TIL lj
10011111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Leo 251

TIL lk
11111110
11111111
11111111
11111111
11111111
11011111
11111111
11111111
NAME Leo 252

TIL ll
11111111
11111111
11111111
11111111
11110111
11111111
11111111
11111111
NAME Leo 253

TIL lm
00000000
00000000
00000000
00000000
00000000
00000000
00000000
01111000
NAME Leo 254

TIL ln
00000000
00000001
00000010
00000100
00001000
00010000
00010000
00100001
NAME Leo 255

TIL lo
00000001
10000110
00001000
00110000
00100000
01000000
10000000
00000000
NAME Leo 256

TIL lp
11000000
00000111
00000000
00000000
00000000
00000000
00000000
00000000
NAME Leo 257

TIL lq
00000000
00000000
11100000
00011100
00000111
00000001
00000000
00010000
NAME Leo 258

TIL lr
00000000
00000000
00000000
00000000
00000000
10000000
11000000
01000000
NAME Leo 259

TIL ls
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11111100
NAME Leo 260

TIL lt
00000000
00000000
00000000
00000000
00010001
00010001
00010001
00110001
NAME Leo 261

TIL lu
01000001
10000010
10000010
10000010
00000000
00000000
00000000
00000000
NAME Leo 262

TIL lv
00000001
00000010
00000100
00001000
00001000
00010000
00100000
01000000
NAME Leo 263

TIL lw
00001000
00000100
00000010
00000001
00000000
00000000
00000000
00000000
NAME Leo 264

TIL lx
01000000
01100000
00100000
00100000
00100000
00100000
00100000
11100000
NAME Leo 265

TIL ly
00000000
00000000
00000000
00000000
00000000
00000111
00001100
00110000
NAME Leo 266

TIL lz
00000000
00000000
00000001
00001111
11110000
00000000
00001111
00011110
NAME Leo 267

TIL m0
00001111
00111000
11100000
00000000
00001111
00000000
11111100
00000111
NAME Leo 268

TIL m1
00000011
00000001
00000001
00000110
11111100
00001100
00110000
11100000
NAME Leo 269

TIL m2
00100001
00100000
00100000
00100000
00100000
00100000
00100000
00100000
NAME Leo 270

TIL m3
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00001000
NAME Leo 271

TIL m4
00000000
00000000
00000000
00000011
00000110
00000011
00000001
00000000
NAME Leo 272

TIL m5
00000001
00011111
11100000
00000000
00000000
00000000
00000000
10000000
NAME Leo 273

TIL m6
00000000
00000000
00000000
00000000
00000000
00000001
00000001
00000001
NAME Leo 274

TIL m7
01100000
01000011
10000110
10000100
10001100
00001000
00001000
00001000
NAME Leo 275

TIL m8
00100000
00010000
00010000
00001000
00000100
00000010
00000010
00000000
NAME Leo 276

TIL m9
01000000
00100000
00100000
00010000
00001000
00000100
00000010
00000001
NAME Leo 277

TIL ma
00000010
00000010
00000010
00000010
00000010
00000010
00000001
00000001
NAME Leo 278

TIL mb
00001000
00001000
00001000
00001000
00001000
00001100
00000110
10000110
NAME Leo 279

TIL mc
00000000
00000000
00000000
00000000
00000000
00000000
00000111
00111100
NAME Leo 280

TIL md
00000000
00000000
00000000
00000000
00000000
00111111
11101111
00000000
NAME Leo 281

TIL me
00000000
00000000
00000000
00000000
00000000
11111000
11110000
00000011
NAME Leo 282

TIL mf
00000000
00000000
00000000
00000000
00000001
00001110
01110000
10000000
NAME Leo 283

TIL mg
00000000
00000000
00000111
00111000
11000000
00000000
00000000
00000000
NAME Leo 284

TIL mh
00011100
11100000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Leo 285

TIL mi
00000000
11000000
00110000
00001100
00000011
00000000
00000000
00000000
NAME Leo 286

TIL mj
00000000
10000000
01000000
01000000
01000000
00100000
00100000
00100000
NAME Leo 287

TIL mk
10000011
11000001
01000000
01100000
00110000
00011000
00001110
00001111
NAME Leo 288

TIL ml
10000000
11100000
00011111
00000000
00000000
00000000
00000000
00000000
NAME Leo 289

TIL mm
00000000
00000111
11111100
00000000
00000000
00000000
00000000
00000000
NAME Leo 290

TIL mn
11100000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Leo 291

TIL mo
00000000
00000000
00000000
00000000
00000001
00000010
00000100
00001000
NAME Leo 292

TIL mp
00001100
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Leo 293

TIL mq
00100000
00100000
00010000
00010000
00010000
00010000
00001000
00001000
NAME Leo 294

TIL mr
00000000
00000011
00000001
00000001
00000001
00000001
00000000
00000000
NAME Leo 295

TIL ms
00100000
00100000
00100000
00100000
00100000
00000000
10000000
10000000
NAME Leo 296

TIL mt
11000000
01111111
00011111
00000011
00000011
00000011
00000011
00000010
NAME Leo 297

TIL mu
00000000
00000000
00000000
00000001
00000010
00000100
00001000
00010000
NAME Leo 298

TIL mv
00010000
00100000
01000000
10000000
00000000
00000000
00000000
00000000
NAME Leo 299

TIL mw
00000000
00000000
00000000
00000000
00111111
11000000
00000000
00000000
NAME Leo 300

TIL mx
00000000
00000000
00000000
00000011
11111100
00000000
00000000
00000000
NAME Leo 301

TIL my
00001000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Leo 302

TIL mz
00000000
00000000
00000000
00000000
00000000
00000000
00010000
00010001
NAME Leo 303

TIL n0
10000000
10000000
10000000
10000000
10000000
10000000
10000000
00000000
NAME Leo 304

TIL n1
00000010
00000110
00000110
00000110
00000110
00000110
00001110
00001100
NAME Leo 305

TIL n2
00100000
01000000
10000000
00000111
00111000
11000000
00000000
00000000
NAME Leo 306

TIL n3
00000011
00011100
11100000
00000000
00000000
00000001
00000011
00000110
NAME Leo 307

TIL n4
00000000
00000000
00000000
00000000
00000000
11111000
00001111
00001111
NAME Leo 308

TIL n5
00000000
00010000
00010000
00010000
00010000
00010000
00110000
01100001
NAME Leo 309

TIL n6
00000000
00000000
00000000
00000000
00000000
00000001
10000001
00000010
NAME Leo 310

TIL n7
00010001
00100001
00100010
01000010
10000000
00000000
00000000
00000000
NAME Leo 311

TIL n8
00011000
00111000
00110000
01110000
01110000
01100000
01100000
01100000
NAME Leo 312

TIL n9
00000000
00000000
00000000
00000000
00000000
00000001
00000010
00000110
NAME Leo 313

TIL na
00000000
00000000
00000000
00000111
00111100
11100000
00110000
00010000
NAME Leo 314

TIL nb
00011100
00110000
11000000
00000000
00000011
00000011
00000110
00000110
NAME Leo 315

TIL nc
00011100
00111000
01100000
11000000
10000000
00000000
00000000
00000000
NAME Leo 316

TIL nd
00111110
00000011
00000000
00000000
00000000
00000000
00000000
00000000
NAME Leo 317

TIL ne
11000000
11110000
00011000
00000100
00000110
00000010
00000010
00000010
NAME Leo 318

TIL nf
00000000
00000001
00000110
00001100
00110000
01100000
11000000
10000000
NAME Leo 319

TIL ng
11000010
10000110
00001000
00010001
01100010
00000000
01000000
01000000
NAME Leo 320

TIL nh
00000100
00011000
01100000
10010000
00010000
00011000
00011000
00011000
NAME Leo 321

TIL ni
01100000
01100000
01000000
01000000
01000000
01000000
01000000
01000000
NAME Leo 322

TIL nj
00000100
00000100
00000100
00000100
00000100
00000100
00000100
00000100
NAME Leo 323

TIL nk
00001000
00001000
00001100
00000100
00000110
00000010
00000010
00000011
NAME Leo 324

TIL nl
00000110
00000110
00000010
00000010
00000011
00000011
00000001
00000001
NAME Leo 325

TIL nm
00000010
00000010
00000010
00000010
00000010
00000010
00000100
00000100
NAME Leo 326

TIL nn
00000001
00000001
00000011
00000010
00000110
00000100
00000100
00000110
NAME Leo 327

TIL no
00100000
00100000
00110000
00010000
00001000
00001000
00001100
00000110
NAME Leo 328

TIL np
00001100
00001100
00001100
00000100
00000100
00000010
00000010
00000011
NAME Leo 329

TIL nq
01000000
01000000
10000000
10000000
10000000
11000000
11100000
11110000
NAME Leo 330

TIL nr
00000011
00000001
00000001
10000001
11000001
01000000
01000000
11000000
NAME Leo 331

TIL ns
00000000
00000000
10000000
10000000
11000000
11000000
11100000
00111000
NAME Leo 332

TIL nt
11000000
01100000
00011000
00001100
00000010
00000010
00000010
00000010
NAME Leo 333

TIL nu
00000100
00000100
00000100
00000100
00000100
00000100
00000100
00000110
NAME Leo 334

TIL nv
00000000
11000000
00110000
00011000
00000100
00000010
00000010
00000010
NAME Leo 335

TIL nw
00000010
00000010
00000001
00000001
00000001
00000000
00000000
00000000
NAME Leo 336

TIL nx
00000011
00000000
00000000
00000000
10000000
11000000
01100000
00111100
NAME Leo 337

TIL ny
10000000
11000000
01100000
00110000
00010000
00001000
00001000
00001000
NAME Leo 338

TIL nz
01111110
00001111
00000000
00000000
00000000
00000000
00000000
00000000
NAME Leo 339

TIL o0
00011111
11111111
00000000
00000000
00000000
00000000
00000000
00000000
NAME Leo 340

TIL o1
00001111
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Leo 341

TIL o2
11111100
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Leo 342

TIL o3
10000000
11100000
01111111
00000111
00000000
00000000
00000000
00000000
NAME Leo 343

TIL o4
00000010
00000110
11011000
11111000
00000000
00000000
00000000
00000000
NAME Leo 344

TIL o5
11111000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Leo 345

TIL o6
00000000
00000000
00000001
00001111
11110000
00000000
00001111
00111000
NAME Leo 346

TIL o7
11000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Leo 347

TIL o8
00000000
00000000
00000000
00000000
00000000
00111111
11100000
00000000
NAME Leo 348

TIL o9
00000000
00000000
00000000
00000000
00000000
11111000
00000000
00000011
NAME Leo 349

TIL oa
10000011
11000001
01000000
01100000
00110000
00011000
00001110
00000111
NAME Leo 350

TIL ob
11000000
01111100
00011100
00000010
00000010
00000010
00000010
00000010
NAME Leo 351

TIL oc
00000010
00000110
00000110
00000110
00000110
00000100
00001000
00001000
NAME Leo 352

TIL od
00010000
00110000
00110000
01100000
01000000
01000000
01000000
01000000
NAME Leo 353

TIL oe
01000000
01000000
10000000
10000000
10000000
11000000
11100000
01110000
NAME Leo 354

TIL of
00111110
00001111
00000000
00000000
00000000
00000000
00000000
00000000
NAME Leo 355

TIL og
00000001
11111111
00000000
00000000
00000000
00000000
00000000
00000000
NAME Leo 356

TIL oh
10000000
11100000
01111100
00000111
00000000
00000000
00000000
00000000
NAME Leo 357

TIL oi
00000010
00000110
00001000
11110000
00000000
00000000
00000000
00000000
NAME Leo 358

TIL oj
00000111
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Leo 359

TIL ok
00000000
00000000
00010000
00010000
00010000
11101110
00010000
00010000
NAME Leo 1

TIL ol
00010000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Leo 2

TIL om
00000000
00000000
00000000
00000000
00000000
00000000
00000010
00000010
NAME Leo 3

TIL on
00000010
00011101
00000010
00000010
00000010
00000000
00000000
00000000
NAME Leo 4

TIL oo
00000000
11000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Leo 5

TIL op
00000000
00000000
00000000
00000000
00000000
00010001
00011100
00001100
NAME Supernova 1

TIL oq
00000000
00000000
00000000
00000000
00000111
00000110
00000001
00000011
NAME Supernova 2

TIL or
00000000
00000000
00000000
10000000
00000000
00000000
00001110
00000000
NAME Supernova 3

TIL os
00000000
00000000
00000000
00000000
00000000
01100000
00100000
01110000
NAME Supernova 4

TIL ot
00000001
00001001
00001111
00000011
00000010
00000111
00000101
00000110
NAME Supernova 5

TIL ou
10000011
00000111
11000000
11111000
00000000
10000000
00000000
01010001
NAME Supernova 6

TIL ov
00000000
10000000
00001111
00000000
00000000
00000000
00000111
00100111
NAME Supernova 7

TIL ow
00011111
01011101
10011000
00000001
00000000
11100000
11111100
11000111
NAME Supernova 8

TIL ox
01010000
10010000
11110000
11111000
00100000
01100000
00100000
00010000
NAME Supernova 9

TIL oy
00001110
00001100
00001100
00001100
00001000
00001000
00011001
00011001
NAME Supernova 10

TIL oz
00000000
01001000
00000001
10010000
00110001
00101101
01100001
00000011
NAME Supernova 11

TIL p0
00001111
00101000
01010100
11000000
10010000
10000000
00000001
00000000
NAME Supernova 12

TIL p1
00000001
00000000
00000000
00000000
00000000
00000000
10000000
01100000
NAME Supernova 13

TIL p2
11010000
11010000
01010000
00110000
01110000
01110000
01110000
01110000
NAME Supernova 14

TIL p3
00000000
00000000
00001111
00101000
01100000
00000000
00010000
10000000
NAME Supernova 15

TIL p4
00000000
00011000
11110111
00000101
00000000
00000010
00010000
00000001
NAME Supernova 16

TIL p5
00000000
00000000
00000000
10000000
01000000
00000000
01000000
00010000
NAME Supernova 17

TIL p6
00011001
00011011
00011001
00011001
00011001
00011001
00010011
00011011
NAME Supernova 18

TIL p7
10000011
00010111
00000111
00100110
00001110
00101110
00101110
01101110
NAME Supernova 19

TIL p8
11100111
11000100
10001100
00001100
00001000
00000000
00000000
01000000
NAME Supernova 20

TIL p9
01010000
10010000
10001000
11001000
01001110
01001110
01000010
11100010
NAME Supernova 21

TIL pa
00000000
00000000
00000000
00000001
00000001
00000000
00000001
00000001
NAME Supernova 22

TIL pb
00000000
10000001
00001000
00000001
00000000
01100010
01001000
00001110
NAME Supernova 23

TIL pc
00000000
00000001
00010000
00000000
00001100
01101110
01111000
11001001
NAME Supernova 24

TIL pd
00000000
00010000
00000000
01001000
00000000
00100000
00000000
10100000
NAME Supernova 25

TIL pe
00011011
00010010
00010010
00011110
00011000
00111001
00111001
00100011
NAME Supernova 26

TIL pf
01001111
11011111
10011111
11111111
00111111
00111111
00011111
00111111
NAME Supernova 27

TIL pg
00000000
00000000
00000001
10000000
11000000
11000000
11110011
11111111
NAME Supernova 28

TIL ph
01100001
00000001
11100011
11100111
00001111
00011000
10111010
11111110
NAME Supernova 29

TIL pi
11100010
11100010
11100010
11100010
11100001
11111111
00000000
00000000
NAME Supernova 30

TIL pj
00000000
00000000
00000000
00000011
00011111
11100000
00000000
00000000
NAME Supernova 31

TIL pk
00000010
00000011
00000001
11000010
11111110
10100001
00001001
00000000
NAME Supernova 32

TIL pl
00000000
10000001
10000000
00000100
00000001
00001111
10111111
11111111
NAME Supernova 33

TIL pm
00101110
00001110
10000111
00101111
01000110
00011100
11111000
11110000
NAME Supernova 34

TIL pn
10000000
11000000
11000000
10000000
10000000
11000000
00000000
01000000
NAME Supernova 35

TIL po
00100110
00101100
01010000
01001100
11000110
10001001
10100001
10111110
NAME Supernova 36

TIL pp
00110111
00111111
00111111
01111111
11111111
11111111
11111111
11111111
NAME Supernova 37

TIL pq
11111111
11111111
11111111
11111111
11111111
11111011
11110000
11101010
NAME Supernova 38

TIL pr
11111111
11011111
10011111
11011111
11001111
11110111
11111111
00111111
NAME Supernova 39

TIL ps
00000010
10100000
10000011
11111111
11111100
11100001
11111100
11111111
NAME Supernova 40

TIL pt
00000011
00011111
11111111
10000000
00000000
00010001
00000000
11111100
NAME Supernova 41

TIL pu
10100000
10000100
11111000
00111110
00001111
00000001
00000001
10000001
NAME Supernova 42

TIL pv
00111111
00111111
00111111
00111111
00111110
00111000
00000000
00000000
NAME Supernova 43

TIL pw
11110001
11100000
11000010
00000000
00000000
00000000
00000000
00000000
NAME Supernova 44

TIL px
00011000
10001100
00000110
01000010
00000011
00000011
00000011
00000001
NAME Supernova 45

TIL py
00000000
00000001
00000011
00000011
00000111
00000111
00000110
00000110
NAME Supernova 46

TIL pz
10111000
00001110
11000001
01100000
10000000
01010001
00000001
01000001
NAME Supernova 47

TIL q0
11111111
00111111
11111111
01100111
00111110
10011110
10000000
10000000
NAME Supernova 48

TIL q1
11000000
11000100
10010000
10000000
00011111
01000000
00000000
00000000
NAME Supernova 49

TIL q2
00000000
00000000
00000000
11100000
10000000
00001000
00000000
00000000
NAME Supernova 50

TIL q3
00011111
00000111
00000001
00000111
00000011
00000000
00000010
01000101
NAME Supernova 51

TIL q4
11111110
11111111
11110011
10000001
10000000
11000000
01100000
00110000
NAME Supernova 52

TIL q5
00010001
00000000
10100100
11000000
11100100
01111001
00110000
00001101
NAME Supernova 53

TIL q6
00000000
10000000
10000000
10000000
11000000
01000000
00100001
01111111
NAME Supernova 54

TIL q7
00000100
00001110
00001110
00001011
00101001
00000101
11110000
11011111
NAME Supernova 55

TIL q8
00000000
00000000
00000000
00000000
00000000
10000000
11111100
11100000
NAME Supernova 56

TIL q9
10000000
10000000
11000000
01000000
01100000
00100000
00100000
00110000
NAME Supernova 57

TIL qa
00000100
00001100
00011011
00010010
00100000
01100000
01000000
11000000
NAME Supernova 58

TIL qb
00000001
11000001
00100001
00100001
00100001
00010001
00010001
00100001
NAME Supernova 59

TIL qc
10000000
10100001
10000000
10001000
10100000
10001000
11000010
11100000
NAME Supernova 60

TIL qd
00000010
00000000
00000000
00000000
00000000
00010010
00000000
10000000
NAME Supernova 61

TIL qe
00000000
00010000
00000000
00000001
00000100
00000000
00100001
10000100
NAME Supernova 62

TIL qf
00000010
00000000
00000000
00010000
00000010
00001001
00000010
01000110
NAME Supernova 63

TIL qg
01110001
00110001
10110001
01100001
11000111
10000001
00000001
00000001
NAME Supernova 64

TIL qh
00000110
10000001
10000001
10000001
00000101
00000101
00001100
00001000
NAME Supernova 65

TIL qi
01110000
00100000
00111000
00001000
00001100
10000000
10000000
10000000
NAME Supernova 66

TIL qj
00000000
00000000
00000000
00000000
00001000
00000001
01100000
01111111
NAME Supernova 67

TIL qk
00000000
00000000
00000000
00000000
01001001
00000111
00111111
11111111
NAME Supernova 68

TIL ql
00010000
00000000
00010000
11110000
11110000
11110000
11110000
00101000
NAME Supernova 69

TIL qm
00000000
00000000
00000001
00000001
00000001
00000001
00000001
00000001
NAME Supernova 70

TIL qn
11000000
10000000
10000000
10000000
10000000
10000000
10000000
10111000
NAME Supernova 71

TIL qo
00100001
00100011
00110011
01011011
01001010
10000000
10000000
10000000
NAME Supernova 72

TIL qp
11111100
00011111
00000011
00000000
01110000
00001110
00000011
00010000
NAME Supernova 73

TIL qq
00010000
10000000
11111010
00111101
00000000
11111111
00001111
00000000
NAME Supernova 74

TIL qr
00000000
00100000
00000011
00000110
00000000
00000000
11000000
01111100
NAME Supernova 75

TIL qs
00011000
01110000
11000000
00000000
00000000
00000000
00000000
00000000
NAME Supernova 76

TIL qt
00000000
00000000
00000001
00010001
00000000
00000000
00000000
00000000
NAME Supernova 77

TIL qu
00001100
00000111
00000001
10000000
10000000
01000000
01000000
01000000
NAME Supernova 78

TIL qv
11011111
01000111
00010000
00000000
00000000
01000000
01001010
01000010
NAME Supernova 79

TIL qw
11111111
11111111
01111111
00111011
00001001
00001000
00101100
00000100
NAME Supernova 80

TIL qx
11110001
11110000
11110100
11110010
10100000
10011011
11011011
11011001
NAME Supernova 81

TIL qy
00001000
00011000
10110000
01110000
01110000
01110000
01010000
11010000
NAME Supernova 82

TIL qz
00000001
00000001
00000001
00000001
00000001
00000001
00000011
00000011
NAME Supernova 83

TIL r0
10100100
10110010
10010011
10001101
11000100
11000011
01000001
01100000
NAME Supernova 84

TIL r1
01000001
01100001
00110001
10010001
00011001
00001001
10001001
11001001
NAME Supernova 85

TIL r2
00000000
00000010
00100000
00000000
00000010
00000000
10001000
10000001
NAME Supernova 86

TIL r3
00000000
00000000
10001000
00101100
00000110
01000011
00000001
00001000
NAME Supernova 87

TIL r4
00000000
00000000
00000000
00000000
00000000
10000000
11000000
11110000
NAME Supernova 88

TIL r5
00000000
00000000
00000000
00000000
00000000
10000000
11000000
11000000
NAME Supernova 89

TIL r6
00010000
00000000
00001000
00000000
00101000
00000000
00000000
00001000
NAME Supernova 90

TIL r7
00100000
00100010
01010110
01010110
01101101
01101001
01101001
00001000
NAME Supernova 91

TIL r8
01000010
10000010
10010110
10000010
00000010
00100110
00000011
00000010
NAME Supernova 92

TIL r9
01000110
00001010
00100011
00100101
00011001
01011001
00011001
00101010
NAME Supernova 93

TIL ra
01001001
01101011
00101100
00110101
10110100
10110111
11110111
11111111
NAME Supernova 94

TIL rb
11100000
11000000
10000000
00000000
10000000
00000000
00000000
00000000
NAME Supernova 95

TIL rc
00000111
00000111
00000111
00001111
00011110
00111110
00110000
00011000
NAME Supernova 96

TIL rd
01111000
11111100
11111110
11111111
00001111
00000001
00000000
00111000
NAME Supernova 97

TIL re
01000001
00100001
00010001
00011000
10001000
11000100
11100100
01110100
NAME Supernova 98

TIL rf
10000000
10000000
11000000
11000011
11000011
11000010
11000011
11000111
NAME Supernova 99

TIL rg
00000000
00000000
00100000
00000000
11000000
11100000
00110000
00101111
NAME Supernova 100

TIL rh
11111000
00111111
01001111
11101010
11111001
11001111
01000100
10000010
NAME Supernova 101

TIL ri
11000000
11000100
10110000
01110101
11111111
11100111
00000000
01000000
NAME Supernova 102

TIL rj
00000000
00000000
00000000
00000001
11111111
11111111
00000000
00001010
NAME Supernova 103

TIL rk
00001000
00011010
00111001
11111000
11111000
11110110
00010000
00100000
NAME Supernova 104

TIL rl
00010110
00010100
10011010
11000000
01100000
00110001
00011100
00000110
NAME Supernova 105

TIL rm
10001111
00100111
11100111
00100111
01100011
00100011
01100111
11100001
NAME Supernova 106

TIL rn
11111111
11111111
11111111
11111111
11111100
11111000
11110000
11100000
NAME Supernova 107

TIL ro
00001000
00001001
00011000
00010000
00010000
00010000
00010000
00010000
NAME Supernova 108

TIL rp
00001100
11100010
00110001
00001101
00000110
11100000
00110000
00000001
NAME Supernova 109

TIL rq
01111000
00111000
00111000
01011100
11001100
11001100
11001101
11001101
NAME Supernova 110

TIL rr
11000111
11111110
11101100
11100101
11100000
11100010
11111111
11111110
NAME Supernova 111

TIL rs
00110100
00000000
10001000
00001111
00011110
11100000
10000000
00000000
NAME Supernova 112

TIL rt
00010100
00000001
11111111
10000000
00000000
00000000
00000000
00000000
NAME Supernova 113

TIL ru
00000000
01100111
11110001
00011100
00000100
00000010
00000010
00000011
NAME Supernova 114

TIL rv
00001000
11000000
11000000
00111110
00100111
00100101
00000101
00000100
NAME Supernova 115

TIL rw
10000000
00000000
01100000
00110111
11010010
11100000
00100000
00101000
NAME Supernova 116

TIL rx
00000011
00000001
00000000
10000000
00110000
01100000
11000000
10000000
NAME Supernova 117

TIL ry
01100001
11101100
11100000
01111000
01111001
01111000
11111000
11111111
NAME Supernova 118

TIL rz
11100000
10100000
11100000
01100000
01100000
01100000
10100000
10110000
NAME Supernova 119

TIL s0
00010000
00010001
00010011
00010011
00010111
00010111
00010111
00010111
NAME Supernova 120

TIL s1
10000000
11001000
11100100
11100100
11110000
11111000
11111000
11110000
NAME Supernova 121

TIL s2
11000101
11001101
11011001
11011001
10011000
11000000
01000000
01000011
NAME Supernova 122

TIL s3
11111000
11111000
01110101
01110000
01000000
01001000
01000000
11100010
NAME Supernova 123

TIL s4
01000000
00000000
00000000
00000000
00000000
00000000
00000000
00001000
NAME Supernova 124

TIL s5
00000000
00000000
00000000
00000000
00010010
00010010
00010010
00010001
NAME Supernova 125

TIL s6
00010101
00000100
00000100
00000101
00000100
00000100
00000000
00000000
NAME Supernova 126

TIL s7
00000000
00100000
00001000
01001100
00011101
01011111
00111111
00111111
NAME Supernova 127

TIL s8
10000000
00000110
00000110
00000110
10110010
11110010
11110011
11110011
NAME Supernova 128

TIL s9
11111111
11111110
11111100
11110000
11100001
11100000
11000100
01100000
NAME Supernova 129

TIL sa
10011000
00001100
00000110
00001110
00011000
00011110
00000111
10001100
NAME Supernova 130

TIL sb
00010011
00010001
00010000
00011000
00001000
00001100
00000100
00000010
NAME Supernova 131

TIL sc
11110000
11110000
11110000
01110000
01100000
01100000
00100000
00100000
NAME Supernova 132

TIL sd
01000011
01000011
01000010
01000000
01000000
01100000
00100000
00110000
NAME Supernova 133

TIL se
11000000
11000000
11000000
11000000
11000000
11000000
11000000
11000000
NAME Supernova 134

TIL sf
00010001
00010001
00010001
00010001
00010001
00010001
00010000
00010000
NAME Supernova 135

TIL sg
00000010
00000010
00000010
00000010
00000010
10000010
10000010
10000010
NAME Supernova 136

TIL sh
00010001
00000100
00000000
10000000
00000001
00100100
00100000
01100000
NAME Supernova 137

TIL si
01000001
01100000
00100000
00100000
00011000
00001110
10000011
00010000
NAME Supernova 138

TIL sj
11110011
01110011
01110011
00111011
00011001
00011001
10011001
10011000
NAME Supernova 139

TIL sk
01100000
00111000
00110111
00010001
10001001
10000011
10000000
11000000
NAME Supernova 140

TIL sl
00011110
00111110
00011100
10010100
10101000
01011000
11110000
10100000
NAME Supernova 141

TIL sm
00000011
00000011
00000011
00000100
00000100
00000100
00000010
00000010
NAME Supernova 142

TIL sn
00000000
00000000
00000000
10000000
10000000
10000000
10000000
11000000
NAME Supernova 143

TIL so
00010000
00010000
00010000
01010000
01010000
01010001
01010001
01010001
NAME Supernova 144

TIL sp
11000100
10000000
10000000
10000000
10000000
10000000
10000000
10000000
NAME Supernova 145

TIL sq
00010000
00010000
00010000
00010000
00010000
00001000
00001000
00001000
NAME Supernova 146

TIL sr
00010001
00010000
00110000
00110000
00110100
00110000
00110000
00110010
NAME Supernova 147

TIL ss
10000010
10000100
10000100
10000100
10000100
10100100
10000100
10001001
NAME Supernova 148

TIL st
01100000
01100010
01100000
01100000
01100000
00100000
00100010
00100000
NAME Supernova 149

TIL su
00000001
00000011
01001110
00001100
00011100
00111100
00111100
00111000
NAME Supernova 150

TIL sv
10011000
00011100
00001100
10001100
10000110
10000011
10110000
11110000
NAME Supernova 151

TIL sw
11000000
01100000
00110001
00011011
00000010
10000110
11000110
01110110
NAME Supernova 152

TIL sx
01000000
10000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Supernova 153

TIL sy
00000011
00000001
00000001
00000000
00000000
00000000
00000000
00000000
NAME Supernova 154

TIL sz
01100000
00100001
10110011
10010111
10010111
11010011
01010111
01010111
NAME Supernova 155

TIL t0
01010001
01010001
01010001
11010001
11010001
11010001
11010001
11010001
NAME Supernova 156

TIL t1
00001000
00001000
00001000
00001000
00001000
00000100
00000100
00000100
NAME Supernova 157

TIL t2
00110000
00110000
00110000
00110000
00110010
00011000
00011000
00011000
NAME Supernova 158

TIL t3
10001000
10001000
10001000
11001000
11010110
11010000
11010000
01010000
NAME Supernova 159

TIL t4
00100000
00100000
01100000
01100000
01100001
01100000
01100000
01100000
NAME Supernova 160

TIL t5
00110000
00111000
00111000
10011000
00011100
00001100
10001100
00000100
NAME Supernova 161

TIL t6
10000000
11000000
01110001
00011001
00001000
00110000
01100000
11000000
NAME Supernova 162

TIL t7
00110001
00011001
00011001
00000111
10000111
11000011
11100011
10100011
NAME Supernova 163

TIL t8
00010100
00010100
00010100
00010100
00010100
00010100
00010100
00010100
NAME Perseus 1

TIL t9
11000010
11000010
11000010
11000010
11000010
11000010
11000010
11000010
NAME Perseus 2

TIL ta
00101000
00101000
00101000
00101000
00101000
00101100
00100100
00010100
NAME Perseus 3

TIL tb
00100000
00000000
00000000
00100000
00000000
00100000
00000000
00100000
NAME Perseus 4

TIL tc
00000110
00000110
00000110
00000110
00000101
00000100
00000100
00000100
NAME Perseus 5

TIL td
00000011
00010001
00000010
00000000
10001001
10000000
11000011
01000000
NAME Perseus 6

TIL te
11000000
11000000
11000000
01000000
00100000
00100000
11010000
11111000
NAME Perseus 7

TIL tf
00010100
00010100
00011100
00011100
00011010
00011010
00011010
00011010
NAME Perseus 8

TIL tg
11000010
11000010
11000010
01100010
01100010
01100010
01100010
01100001
NAME Perseus 9

TIL th
00010110
00010010
00010010
00001010
00001010
00001101
00001101
00001100
NAME Perseus 10

TIL ti
00000000
00000000
00000000
10000000
00000000
01000000
10000000
10000010
NAME Perseus 11

TIL tj
00100000
00100000
00010000
00000000
00010000
00010010
00010000
00001000
NAME Perseus 12

TIL tk
00000000
00000000
00010000
00000000
00000010
00000000
00010000
10000000
NAME Perseus 13

TIL tl
00001100
00001000
00001000
10001000
00001000
00101000
00011000
10001000
NAME Perseus 14

TIL tm
01100000
00100000
00100000
00100000
00100000
00010000
00010000
00001000
NAME Perseus 15

TIL tn
00111000
00001100
00101100
00001110
00000110
00010010
00000011
00000001
NAME Perseus 16

TIL to
00011010
00011010
00011010
00011010
01011010
00001010
00001010
00001010
NAME Perseus 17

TIL tp
01100001
01100001
01101001
01100001
01010001
01010001
00110001
00110001
NAME Perseus 18

TIL tq
00011100
00011110
00011010
00011010
00011010
00011010
00011010
00010011
NAME Perseus 19

TIL tr
10100000
10001000
01000010
01011000
01000000
01100000
11110000
10111100
NAME Perseus 20

TIL ts
00001000
00111000
00010000
00000000
00000000
00000011
00100111
00001100
NAME Perseus 21

TIL tt
00000000
00000000
00000100
00111111
11000000
00100010
01000000
00000000
NAME Perseus 22

TIL tu
01001000
00001000
10000100
00100100
01000100
10100100
00000100
00000110
NAME Perseus 23

TIL tv
00001000
00001100
00000110
00000110
00000011
00000001
00000001
00000000
NAME Perseus 24

TIL tw
00000001
00000001
00000000
00000000
00000000
00000000
10000000
10000000
NAME Perseus 25

TIL tx
10000000
10000000
10000000
11000000
01000000
01000000
01000000
00100000
NAME Perseus 26

TIL ty
00000000
00000000
00000000
00000000
00000000
00000000
00111000
01111110
NAME Perseus 27

TIL tz
00001010
00001010
00101010
00001010
00001010
01001010
00001010
00001010
NAME Perseus 28

TIL u0
00110100
00010100
00011000
00011000
00011000
00011000
00001100
00001100
NAME Perseus 29

TIL u1
10010011
10010011
10010011
01010010
01010010
01010100
01010100
00110100
NAME Perseus 30

TIL u2
10001100
01010110
00001010
01000000
00010100
00000000
00000000
00000000
NAME Perseus 31

TIL u3
00001010
10100001
01001000
01000010
00000000
00000000
00000000
00000000
NAME Perseus 32

TIL u4
10000000
00000000
00000000
00000000
00000000
00000100
00000000
00000000
NAME Perseus 33

TIL u5
00100110
00000110
00000011
00000011
10000011
00101001
10000001
00010001
NAME Perseus 34

TIL u6
01000000
01100000
00110000
00010000
00001000
00000100
00000110
00000001
NAME Perseus 35

TIL u7
00100000
00010000
00010000
00010000
00011000
00001100
00000110
00000011
NAME Perseus 36

TIL u8
00000000
00000000
00000000
00000000
00000000
00000000
00000111
01111100
NAME Perseus 37

TIL u9
01001101
00000100
00000100
00000100
00001100
01111000
11000000
00000001
NAME Perseus 38

TIL ua
00000000
10000001
10011111
11110000
00000000
00000011
00111110
11100111
NAME Perseus 39

TIL ub
00000000
10000000
11111000
00011000
01110000
11000000
11000000
00000000
NAME Perseus 40

TIL uc
00001010
00101010
00001010
00001010
00001001
00011001
01011001
00011001
NAME Perseus 41

TIL ud
00001100
00001101
00001100
00001010
00000110
00000110
00000110
00000110
NAME Perseus 42

TIL ue
00110110
00110110
00011110
00011010
00011011
10010111
00001101
00001101
NAME Perseus 43

TIL uf
00000000
00000000
00000000
00000000
00000000
00000000
10000000
10001000
NAME Perseus 44

TIL ug
00001010
00000000
00010000
00000100
00000000
00000001
00000000
00000000
NAME Perseus 45

TIL uh
00000000
10000000
00000000
01011000
00000000
00100000
00001000
00000000
NAME Perseus 46

TIL ui
10000001
10000100
11000010
01000100
01000001
00110010
00111000
01101000
NAME Perseus 47

TIL uj
10000000
11110000
11011101
01110010
10000010
00001011
01101001
01101011
NAME Perseus 48

TIL uk
00000111
01111100
11000000
00000000
00001111
00110100
00010111
10101000
NAME Perseus 49

TIL ul
11000000
00000000
00000111
11111001
10001110
01110000
10000000
00000000
NAME Perseus 50

TIL um
00011111
11110011
00011100
11100000
00000000
00000000
00000000
00000000
NAME Perseus 51

TIL un
01111000
10000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Perseus 52

TIL uo
00011001
00111001
10111001
11111001
01111001
00111001
00011001
00001001
NAME Perseus 53

TIL up
00000101
00000011
00000011
00000010
00000001
00000001
00000000
00000000
NAME Perseus 54

TIL uq
00001011
00000110
00000110
10000110
10000101
01000011
11000011
11000010
NAME Perseus 55

TIL ur
10000000
11001000
11100010
11111000
01111111
01111111
00111100
10011000
NAME Perseus 56

TIL us
01000000
01100001
01110000
11111100
11111111
11011110
00100110
00001110
NAME Perseus 57

TIL ut
00100000
00001000
00000000
00100100
10000000
00100000
10000000
00000000
NAME Perseus 58

TIL uu
10000000
10000000
01000000
01000000
01000000
01100000
00100000
00100000
NAME Perseus 59

TIL uv
00000000
00000000
00000001
00000001
00000000
00000000
00000000
00000000
NAME Perseus 60

TIL uw
01101000
01100100
10111100
01111111
11110000
00000000
00000000
00000000
NAME Perseus 61

TIL ux
01101010
01101000
00000011
11011110
01110000
00000000
00000000
00000000
NAME Perseus 62

TIL uy
10100000
01100000
11000000
00000000
00000000
00000000
00000000
00000000
NAME Perseus 63

TIL uz
00001001
00001001
00000101
00000101
00000101
00000101
00000101
00000100
NAME Perseus 64

TIL v0
00000000
00000000
00000010
00000000
00000000
00000000
00000010
10000000
NAME Perseus 65

TIL v1
10100010
01100001
01100001
01010001
00110000
00101000
00011000
00011000
NAME Perseus 66

TIL v2
10011000
01001100
01000110
00100111
10100011
10100011
10100001
10010001
NAME Perseus 67

TIL v3
10010111
00000011
00100111
00000011
00001001
10000011
11000001
11000001
NAME Perseus 68

TIL v4
01000000
00000000
00000000
00000000
00000000
00000000
10000000
10000000
NAME Perseus 69

TIL v5
00000100
00000100
00000010
00000010
00000010
00000010
00000010
00000010
NAME Perseus 70

TIL v6
10000000
10000000
10000000
10000001
10000001
10000000
10000000
10000000
NAME Perseus 71

TIL v7
00010100
00001100
00001100
00001010
00000110
10000101
10000101
01000010
NAME Perseus 72

TIL v8
01010000
01010000
00011000
00001000
00001000
00001000
00001000
10001000
NAME Perseus 73

TIL v9
11100001
01110001
01110001
00111001
00011101
00001111
00000011
00011011
NAME Perseus 74

TIL va
11000000
11000000
11000000
01100000
01110000
00110000
00110000
00011000
NAME Perseus 75

TIL vb
00000000
00000000
00000000
00000000
00000001
00000000
00000000
00000100
NAME Perseus 76

TIL vc
00001000
00001000
00001000
00001000
00001000
00001000
01001000
00001000
NAME Perseus 77

TIL vd
00000010
00000010
00000010
00000001
00000001
00000001
00000001
00000001
NAME Perseus 78

TIL ve
01000000
01000000
01000000
01000000
01000000
01000000
01010000
01010000
NAME Perseus 79

TIL vf
01000010
00100001
00100001
00010000
00001000
00001000
00000100
00000100
NAME Perseus 80

TIL vg
10001100
01000111
01000101
10100101
10100001
01010001
00110001
00101000
NAME Perseus 81

TIL vh
01111011
11000011
00000011
11100001
11000001
11011100
11111110
01111111
NAME Perseus 82

TIL vi
00001000
00001101
00000100
00000110
10000010
11000011
11000001
11000000
NAME Perseus 83

TIL vj
00100000
00001000
01000000
00000010
01000000
00000001
00000000
10000000
NAME Perseus 84

TIL vk
00001000
00001000
00011000
00011000
00001000
00001000
00001000
00001000
NAME Perseus 85

TIL vl
01000000
10100000
10100000
10100000
10101000
01100000
01000000
01000000
NAME Perseus 86

TIL vm
00000010
00000010
00100001
00010001
00010000
00001000
00001000
00000100
NAME Perseus 87

TIL vn
00010100
00010100
00001010
00000101
10000011
10000001
01000001
00100000
NAME Perseus 88

TIL vo
00111111
01011111
00111111
00001111
00000111
10000111
01000111
10000011
NAME Perseus 89

TIL vp
11000000
10000000
10000000
10000000
10000000
00000000
00000000
00000000
NAME Perseus 90

TIL vq
10000000
11000001
01000100
01010000
01010010
01000000
01000101
01010000
NAME Perseus 91

TIL vr
00001100
00001100
00001100
10101100
00111000
00110000
00011000
00011000
NAME Perseus 92

TIL vs
01001000
00100000
00100000
00100000
00100000
00010100
00010100
00010100
NAME Perseus 93

TIL vt
00000100
00000010
00000010
00000001
00000001
00000010
00000001
00000001
NAME Perseus 94

TIL vu
00100000
00010000
00011000
00001000
00000100
10000100
10000010
01000001
NAME Perseus 95

TIL vv
01000011
00100001
00100001
00010001
00001000
00000100
00000100
00000010
NAME Perseus 96

TIL vw
00000000
10000000
10000000
10000000
11000000
11000000
01100000
01100000
NAME Perseus 97

TIL vx
01001000
01000001
01100000
01000000
01000000
01000000
01010000
01000000
NAME Perseus 98

TIL vy
01001000
00011000
00001100
00100100
01000100
00000100
00000110
00010010
NAME Perseus 99

TIL vz
00010000
00010000
00001000
00001000
00001000
00001010
00001000
00001000
NAME Perseus 100

TIL w0
11000000
10100000
01100000
00110000
00110000
00011000
00001000
00001100
NAME Perseus 101

TIL w1
10000000
01000000
01000000
00100000
00010000
00001000
00001100
00000100
NAME Perseus 102

TIL w2
00010000
00110000
10011000
00011000
00001100
00000110
00000110
00000011
NAME Perseus 103

TIL w3
01000010
01101000
01100010
01101000
01100000
00110000
00100000
00110000
NAME Perseus 104

TIL w4
00000110
00000010
00010010
00000010
00001010
00000010
00000010
00000010
NAME Perseus 105

TIL w5
00000100
00000100
00000100
00000100
00000100
00000100
00000010
00000010
NAME Perseus 106

TIL w6
00000100
00000110
00000011
00000011
00000001
00000000
00000000
00000000
NAME Perseus 107

TIL w7
00000010
00010001
00000000
00000010
10000000
11001000
01100100
00110010
NAME Perseus 108

TIL w8
00000001
00000001
10000000
01000000
00000000
00000000
01000000
00000000
NAME Perseus 109

TIL w9
00110000
10010000
11011000
01011000
01101000
00111000
00111100
00011100
NAME Perseus 110

TIL wa
00000010
00000010
00000010
00000010
00000001
00000001
00000001
00000000
NAME Perseus 111

TIL wb
00000000
00000000
00000000
00000000
00000000
00000000
00010000
00001000
NAME Perseus 112

TIL wc
00011001
00001000
00001100
00000110
00000011
00000001
00000000
00000000
NAME Perseus 113

TIL wd
00000000
10000000
01000000
10100000
00010000
10001000
11010100
01100010
NAME Perseus 114

TIL we
00011100
00001110
00000110
00000110
00000011
00000001
10000001
00000000
NAME Perseus 115

TIL wf
00000010
00000010
00000110
00000010
00000010
10000010
10000110
11001010
NAME Perseus 116

TIL wg
10000000
01000000
01000000
01000000
00100100
00100110
00110001
00011001
NAME Perseus 117

TIL wh
00000100
00000010
00000010
00000001
00000000
00000010
00000000
10000100
NAME Perseus 118

TIL wi
00110010
00011001
00001110
00000101
00000010
00000001
00000000
00000000
NAME Perseus 119

TIL wj
00000000
10000000
01000100
00100000
10010000
01001000
11100100
01110000
NAME Perseus 120

TIL wk
01100010
01110010
00110110
00111010
00011011
00001111
00001111
00000111
NAME Perseus 121

TIL wl
00001100
00001110
00000111
00000011
00000011
00000001
00000000
00000000
NAME Perseus 122

TIL wm
01000010
00100001
00011000
11000100
11100011
11110001
11111100
01111111
NAME Perseus 123

TIL wn
10001000
10000100
01010010
00100001
00011000
10000100
11100010
01111001
NAME Perseus 124

TIL wo
00000000
00000000
00010000
00000000
11000000
01110000
00111000
10011111
NAME Perseus 125

TIL wp
00111100
00011110
00001111
00000111
00000001
10000000
00001000
00000000
NAME Perseus 126

TIL wq
10000011
00000011
00000001
10000001
11100000
11110000
00111100
00001110
NAME Perseus 127

TIL wr
00000000
10000000
11000000
11100000
11110000
01110000
00111000
00111000
NAME Perseus 128

TIL ws
00001110
01111100
01000000
00001100
00111000
11000011
00011110
00000000
>
01111110
00000100
00100000
11111100
00000000
00001111
00111000
00000000
NAME Fur

TIL wt
00001110
01111100
01000000
00001100
00111000
11000011
00011110
00000000
>
01111110
00000100
00100000
11111100
00000000
00001111
00111000
00000000
NAME Fur 2

TIL wu
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11111000
NAME Ugolino 1

TIL wv
00000000
00000000
00000000
00000000
00000000
00000000
00011111
01110000
NAME Ugolino 2

TIL ww
00000000
00000000
00000000
00000000
00000000
00000000
11000000
01110000
NAME Ugolino 3

TIL wx
00000001
00000011
00011110
00110000
01100000
11000000
10000000
00000000
NAME Ugolino 4

TIL wy
10000100
00000011
00000001
00000001
00000001
00000001
00001001
00001000
NAME Ugolino 5

TIL wz
11000000
10000000
00000000
01000000
01100000
00100000
10000000
10000000
NAME Ugolino 6

TIL x0
00011111
00000001
00000000
00000001
00000001
00000001
00001000
00011000
NAME Ugolino 7

TIL x1
00000000
10000000
10000000
10000000
11000000
01100000
00110000
00011000
NAME Ugolino 8

TIL x2
00000011
00000010
00000010
00000010
00000010
00000110
00001100
00011000
NAME Ugolino 9

TIL x3
00000000
00100000
00010000
00000000
00000001
00000001
00000011
00000010
NAME Ugolino 10

TIL x4
00001100
00000111
00011110
11110000
10000000
00000000
00000000
00000000
NAME Ugolino 11

TIL x5
01100000
00000000
11111111
00000001
00000000
00000000
00000000
00000000
NAME Ugolino 12

TIL x6
00010000
00000000
00000000
11100010
00111110
00000111
00000011
00000001
NAME Ugolino 13

TIL x7
00001100
00000110
00000010
00000110
01001100
11011000
00010000
00010000
NAME Ugolino 14

TIL x8
00010000
00011000
00001000
00001000
00001100
00000100
00000100
00000101
NAME Ugolino 15

TIL x9
00000010
00000010
00000010
10010010
11100010
00000110
00011100
10000000
NAME Ugolino 16

TIL xa
00000000
00000000
00000000
00000000
00000000
00000001
00000000
00000000
NAME Ugolino 17

TIL xb
00000000
00000000
00000000
00000000
00000000
10000000
00010000
00110000
NAME Ugolino 18

TIL xc
00000001
00000000
00000000
00000000
00000000
11000000
00000000
00000000
NAME Ugolino 19

TIL xd
10001000
10000110
10000010
10000010
11000110
01001100
01001000
10011000
NAME Ugolino 20

TIL xe
00001100
00001000
00001000
00001001
00001101
00000100
00000110
00000010
NAME Ugolino 21

TIL xf
01000000
00000000
01000000
11000000
10000001
10000000
00000000
00000000
NAME Ugolino 22

TIL xg
00000000
11110000
00011100
00000111
11111111
00000000
00000111
00000000
NAME Ugolino 23

TIL xh
00100001
00100010
01100000
01010100
11011101
00000001
00000000
00000001
NAME Ugolino 24

TIL xi
00000000
00001000
00111000
11100000
11100000
11111110
00000000
10000000
NAME Ugolino 25

TIL xj
10010000
10110000
11110000
10010000
10010000
10010000
10010000
01110000
NAME Ugolino 26

TIL xk
00000010
00000011
00000001
00000001
00000001
00000111
00011101
01110010
NAME Ugolino 27

TIL xl
00000000
00000000
10000000
11000000
00111000
11000110
00000001
00000111
NAME Ugolino 28

TIL xm
00000000
00000000
01000000
00000000
10000000
00000100
00001001
10010001
NAME Ugolino 29

TIL xn
00010000
00000000
00010000
00000001
00000000
00010001
00000001
11000110
NAME Ugolino 30

TIL xo
00000000
00001000
00111000
00000000
00001000
01000001
00000111
01000100
NAME Ugolino 31

TIL xp
01100000
01000000
01000000
01000000
10000000
00000000
11111000
00000100
NAME Ugolino 32

TIL xq
00000000
00000000
00000000
00000000
00000001
00000111
00001100
00111000
NAME Ugolino 33

TIL xr
00000000
00000000
00000000
00001111
11110000
00000000
00000000
00000000
NAME Ugolino 34

TIL xs
00000011
00000110
11111000
00000000
00000000
00000000
00000000
00000000
NAME Ugolino 35

TIL xt
10001100
00010000
00100000
00100000
00100000
00100000
00100000
00100000
NAME Ugolino 36

TIL xu
00011110
01111000
11101000
10010001
10010001
11100011
01000000
01000000
NAME Ugolino 37

TIL xv
11110000
01111111
10000100
00000011
00000010
00000110
00000101
00100100
NAME Ugolino 38

TIL xw
01111000
10000011
11111110
11111100
00000111
00000000
01111100
00000001
NAME Ugolino 39

TIL xx
01111010
11111100
00000111
00000000
00000000
11110000
00111000
01101100
NAME Ugolino 40

TIL xy
10100010
00000001
10100001
11001000
01100000
00111000
00011000
00001101
NAME Ugolino 41

TIL xz
00000000
00000000
00000000
10000000
10000000
01000000
01000000
00100000
NAME Ugolino 42

TIL y0
00000000
00000001
00000011
00000010
00000100
00000100
00001000
00001000
NAME Ugolino 43

TIL y1
11100000
10000000
00000000
00000000
00000000
00000010
00000000
00100000
NAME Ugolino 44

TIL y2
00000000
00000000
00000000
00000000
00000000
00000001
01000000
00010000
NAME Ugolino 45

TIL y3
00000000
00000000
00000000
00000000
00001001
10000000
11001000
01100010
NAME Ugolino 46

TIL y4
01010000
00010000
00010000
01010000
00010000
00010000
01011000
00011101
NAME Ugolino 47

TIL y5
10000000
00000000
00000000
00000000
00000000
00001010
10000000
01000000
NAME Ugolino 48

TIL y6
00000111
00000001
00000000
00000000
00100000
00000000
01000000
00001000
NAME Ugolino 49

TIL y7
01001000
11010010
01110101
00011011
00001100
00001001
00001001
00001001
NAME Ugolino 50

TIL y8
01000010
10001011
01000001
00000001
11111111
10000000
00000000
00000000
NAME Ugolino 51

TIL y9
00000110
00000011
00000001
10000000
11000000
01000000
00000000
00000000
NAME Ugolino 52

TIL ya
00100000
00010000
10001000
11000100
01110010
00010001
00000000
00000000
NAME Ugolino 53

TIL yb
00010000
00010000
00100000
01000000
10000000
10000000
00000000
00000000
NAME Ugolino 54

TIL yc
00000000
00001100
00000110
00000010
00000001
00000000
00000000
00000000
NAME Ugolino 55

TIL yd
00110010
00011001
00001101
00000100
00000010
10000011
01000001
01000000
NAME Ugolino 56

TIL ye
01110111
00000001
00000000
10000000
01000000
01000000
00100100
10010001
NAME Ugolino 57

TIL yf
00000100
10000000
11100000
00111000
00011110
00000111
00000001
00000001
NAME Ugolino 58

TIL yg
00000000
10000000
00001010
00000000
00000000
00000000
10000000
10000000
NAME Ugolino 59

TIL yh
00001001
00001001
00001000
00010001
01110011
00010010
00010010
00001011
NAME Ugolino 60

TIL yi
00000000
11111100
00000111
11111100
00000000
00000000
00000000
11111100
NAME Ugolino 61

TIL yj
00000000
00010000
10000000
00010010
00000000
00000000
00000000
00000000
NAME Ugolino 62

TIL yk
00000000
00000000
00000000
00000000
01000000
00000000
00000000
00000000
NAME Ugolino 63

TIL yl
00100000
00010000
00001000
00001000
00000100
00000010
00000001
00000001
NAME Ugolino 64

TIL ym
00000010
00000010
00000100
00000100
00000100
00001000
00001000
00001000
NAME Ugolino 65

TIL yn
00000000
00000000
00000000
00000000
00000000
00000000
10000000
00000000
NAME Ugolino 66

TIL yo
00100000
00010000
00010000
00001000
00001000
00000000
00000000
00000000
NAME Ugolino 67

TIL yp
10010100
11001000
01000100
01000010
00100000
00101000
00100001
00101000
NAME Ugolino 68

TIL yq
00000101
00010001
00000001
00000001
00000001
00000001
00000001
00000001
NAME Ugolino 69

TIL yr
00000111
00000000
00000000
00000000
00000000
00000001
00000011
00000111
NAME Ugolino 70

TIL ys
10000000
11000000
10110000
10011000
10001110
10000011
10000000
01000000
NAME Ugolino 71

TIL yt
00000000
00000000
00000000
00000000
00000000
11000000
01110000
00011000
NAME Ugolino 72

TIL yu
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00100000
NAME Ugolino 73

TIL yv
10000000
10000000
10000000
01000000
01000000
01000000
01000000
01000000
NAME Ugolino 74

TIL yw
00001000
00010000
00010000
00010000
00100000
00100000
00100000
00100000
NAME Ugolino 75

TIL yx
00000010
00000000
00000000
00000000
00000000
00000000
00000000
00001111
NAME Ugolino 76

TIL yy
10000000
00000000
00100000
00000000
00010000
00000000
00000000
10000000
NAME Ugolino 77

TIL yz
01100000
01101010
01100000
01100000
01101000
01100000
00110000
01111000
NAME Ugolino 78

TIL z0
00000100
00000100
00000100
00000010
00000011
00000010
00000010
00000010
NAME Ugolino 79

TIL z1
00001110
00011100
00111010
01111001
11110000
00111011
00011100
00000111
NAME Ugolino 80

TIL z2
00000000
00000001
10000000
00010010
00000000
00100000
00000000
11000100
NAME Ugolino 81

TIL z3
00001000
00001100
00000100
00000100
00000100
00000100
00000101
00000100
NAME Ugolino 82

TIL z4
00100000
00110000
00010000
00011000
00001000
00000100
00000100
00000010
NAME Ugolino 83

TIL z5
00100000
00100000
00100000
00100000
00100000
00010000
00010000
00001000
NAME Ugolino 84

TIL z6
01000000
01000000
01000000
10000000
10000000
10000000
00000000
00000000
NAME Ugolino 85

TIL z7
00000000
00000000
00000000
00000000
00000000
00000000
00100000
00000000
NAME Ugolino 86

TIL z8
01111100
00010010
00000001
00000001
10001001
00100000
10001111
00011100
NAME Ugolino 87

TIL z9
00000000
10000000
00000000
00010000
10000100
01000000
11100000
01100000
NAME Ugolino 88

TIL za
00000001
00000000
00000100
00000000
00000000
00000000
00000000
00000000
NAME Ugolino 89

TIL zb
00011100
00000011
00000001
00000000
00000000
00000000
00000000
00000000
NAME Ugolino 90

TIL zc
00000000
00000000
10000000
11000000
01100000
00110011
00011111
00011110
NAME Ugolino 91

TIL zd
00000010
00000001
00000001
00000001
00000001
00000001
00000001
00000001
NAME Ugolino 92

TIL ze
01100000
00110000
00010000
00000110
00000010
00000011
00000001
00000000
NAME Ugolino 93

TIL zf
01000100
00000100
00000101
00000100
00000100
00100100
10001100
10001000
NAME Ugolino 94

TIL zg
00000010
00000101
00000001
00010001
00000010
01000000
00000000
00000010
NAME Ugolino 95

TIL zh
00001000
00000100
00000100
00000010
10000010
10000010
10000001
01000001
NAME Ugolino 96

TIL zi
00000000
00000000
00000000
00000000
00000011
00001100
00010000
00000000
NAME Ugolino 97

TIL zj
00000010
00000000
00010001
00001111
11111100
00000000
00000000
00000000
NAME Ugolino 98

TIL zk
01110000
11000001
10000000
00000000
00000000
00000000
00000100
00000000
NAME Ugolino 99

TIL zl
01110000
00110000
01011000
00011000
00001100
00000110
00000010
00000011
NAME Ugolino 100

TIL zm
00001110
00001100
00001000
00010000
00010000
00110000
00100000
00100000
NAME Ugolino 101

TIL zn
00000001
00000001
00000001
00000101
00000000
00000000
00000100
00000000
NAME Ugolino 102

TIL zo
00000000
00000000
00000000
00000000
10000000
10000000
10000000
10000000
NAME Ugolino 103

TIL zp
00000000
00001100
00100110
00110011
00001111
00000100
00000100
00000100
NAME Ugolino 104

TIL zq
01001000
01001100
01001001
01001000
01001000
01001000
11001000
10001000
NAME Ugolino 105

TIL zr
01000000
00000000
00000000
00000000
00100000
00000000
10000000
00001000
NAME Ugolino 106

TIL zs
01000000
01000000
01000000
00100000
00000000
01000000
00001000
00000000
NAME Ugolino 107

TIL zt
10000000
10000000
01000000
01000000
01000000
01000000
01000000
01000000
NAME Ugolino 108

TIL zu
00000100
00000100
00000100
00000100
00000100
00000100
00000100
11111100
NAME Ugolino 109

TIL zv
01001000
00000000
00000001
00000000
00000000
00000000
00000000
00000000
NAME Ugolino 110

TIL zw
00000001
00000001
00000000
00000000
01001000
00000000
00000000
00000000
NAME Ugolino 111

TIL zx
10000000
10000000
11000000
01100000
00110000
00010000
00001000
00001100
NAME Ugolino 112

TIL zy
00100000
00100000
00100000
00100000
00100000
00000000
00000000
00000000
NAME Ugolino 113

TIL zz
00000000
00000000
00000000
00000100
00000100
00000100
00000100
00000100
NAME Ugolino 114

TIL 10a
00000100
00000100
00001000
00001000
00010000
00110000
00100000
11000000
NAME Ugolino 125

TIL 10b
00000001
00000001
00000001
00000010
00000011
00000010
00000100
00000100
NAME Ugolino 126

TIL 10c
00000000
00000000
00000001
00000110
11111000
00000000
00001111
11110010
NAME Ugolino 127

TIL 10d
00000100
00001001
10001000
00010100
00100000
11000000
00000000
00000000
NAME Ugolino 128

TIL 10e
00000000
00000000
00000000
00000000
00000000
00000000
01000000
00000000
NAME Ugolino 129

TIL 10f
11100000
00111000
00001100
00000110
00000001
00000000
00000000
00000000
NAME Ugolino 130

TIL 10g
00000000
00000000
00000001
00000001
10000010
10001100
11110000
00110000
NAME Ugolino 131

TIL 10h
00110000
00010010
00000000
00000000
00000100
00100100
00000100
00000100
NAME Ugolino 132

TIL 10i
10000000
01000000
01000000
01000000
01100000
10100000
11010000
00001000
NAME Ugolino 133

TIL 10j
00000001
00000011
00000011
00000110
00000110
00001100
00001100
00001000
NAME Ugolino 134

TIL 10k
10000011
00000001
00000000
00000000
00000000
00000000
00000000
00000000
NAME Ugolino 135

TIL 10l
00000000
10000000
11000000
01110000
00111000
00001110
00000011
00000001
NAME Ugolino 136

TIL 10m
00000000
00000000
00000000
00000000
00000001
00000110
00011000
11100000
NAME Ugolino 137

TIL 10n
00001011
00001111
00110000
01000000
10000000
00000000
00000000
00000000
NAME Ugolino 138

TIL 10o
00000000
11000100
00111100
00000111
00000000
00000000
00000000
00000000
NAME Ugolino 139

TIL 10p
10000000
00000000
10001000
10000000
11000000
00100000
00010010
00010000
NAME Ugolino 140

TIL 10q
00011000
00001100
00000110
00000010
00000011
00000001
00000000
00000000
NAME Ugolino 141

TIL 10r
00000000
00000000
00000000
00000000
00000000
10000000
10000000
11000000
NAME Ugolino 142

SPR A
00011000
00011000
00111100
00111100
00111100
00011000
00001000
00001000
>
00011000
00011000
00111100
00111100
00111100
00011000
00010000
00010000
POS 0 7,15

SPR a
00000000
00000000
00001000
00011000
00011000
00111100
00011000
00111100
NAME Dancer
POS 1 4,10

SPR b
00011000
00011100
00111100
00111110
01111110
01111110
01111110
11111111
NAME Ugolino
POS 1 11,11

SPR c
00010000
00011000
00111010
00111010
00111110
00111110
00111100
00111100
NAME Virgin & Child
POS 1 12,4

SPR d
00010000
11111000
00111000
00111101
00111010
00111000
00111000
00111000
NAME Perseus
POS 1 7,6

SPR e
00000000
00111000
00111100
00111100
00011000
00011000
00010000
00111100
NAME Torso
POS 1 3,3

ITM 3
00000000
00011000
00000000
01011010
01011010
00000000
00011000
00000000
>
00100100
00000000
10100101
00000000
00000000
10100101
00000000
00100100
NAME Sparkle

ITM 4
00000000
00001000
00011000
00011000
00111100
00011000
00111100
00111100
NAME Dancer

ITM 5
00100000
00000000
01000000
00000000
00000000
01000000
00000000
00000000
>
00000000
00100000
00000000
01000000
01000000
00000000
01000000
01000000
NAME glow 1

ITM 6
00000000
00000000
00000001
00000101
00000000
00001000
00000010
00000000
>
00000000
00000000
00000000
00000000
00000101
00000010
00001000
00001010
NAME glow 2

ITM 7
00000000
00000000
01000000
01001000
00000000
00110000
00000000
00000000
>
00000000
00000000
01000000
00100000
00001000
00100000
00100000
00000000
NAME glow 3

ITM 8
00000000
00000000
00011000
00100111
01000000
01100000
00011111
00000000
>
00000000
00000000
00000011
00000100
00001000
00001100
00000011
00000000
NAME Cloud Left

ITM 9
00000000
00000000
00000000
10000000
01000000
00010000
11100000
00000000
>
00000000
00000000
00000000
11110000
00001000
00000010
11111100
00000000
NAME Cloud Right

ITM a
00000000
00001000
00000000
00001010
01010000
00000000
00010000
00000000
>
00000000
00000000
00100100
00000000
00000000
00100100
00000000
00000000
NAME Sparkle Small

ITM b
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00000000
01000010
00000000
00000000
00000000
00000000
00000000
00000000
NAME Sparkle Bottom

ITM c
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00000000
00000000
00000000
00000000
00000000
00000000
01000010
00000000
NAME Sparkle Top

ITM d
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00000000
00000010
00000000
00000000
00000000
00000000
00000010
00000000
NAME Sparkle Left

ITM e
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00000000
01000000
00000000
00000000
00000000
00000000
01000000
00000000
NAME Sparkle Right

ITM f
01000010
00111100
10000001
01111110
00011000
00000000
00000000
00000000
>
01000010
01100110
10111101
10000001
11000011
01111110
00111100
00000000
NAME Flame Bottom

ITM g
00000000
00010000
00100000
01100000
01111000
10000100
10000010
10000000
>
00000100
00000000
00110000
01110000
01111110
01000111
11000011
10000000
NAME Flame Top

ITM h
00000000
00000010
00000010
00000010
00000010
00000010
00000011
00000001
>
00000000
00000010
00000010
00000010
00000010
00001010
00001011
00001101
NAME flame left

ITM i
00001100
00000100
00000110
00000000
00000000
00000000
00000000
00000000
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME flame left bottom

ITM j
00000000
01000000
01000000
01000000
01000000
01000000
11000000
10000000
>
00000000
01000000
01000000
01000000
01000000
01010000
11010000
10110000
NAME flame right

ITM k
00110000
00100000
01100000
00000000
00000000
00000000
00000000
00000000
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME flame right bottom

ITM l
00000000
00100000
00000000
01010000
00001010
00000000
00001000
00000000
>
00000000
00000000
00100100
00000000
00000000
00100100
00000000
00000000
NAME Sparkle Small Alt

DLG 4
"""
that does not see you."
{pg}
...
{pg}
"You must change your life."
{end}
"""
NAME End Narration

DLG b
The Little Fourteen-Year-Old Dancer, 1922, Edgar Degas
NAME Dancer Placard

DLG f
"""
Perseus with the Head of Medusa,
18046, Antonio Canova
"""
NAME Perseus Placard

DLG g
Marble torso of the so-called Apollo Lykeios, A.D. 130161
NAME Torso Placard

DLG h
"""
Virgin and Child,
ca. 13001320
"""
NAME Virgin Placard

DLG j
"""
You don't go to mass anymore, but you do miss the spectacle.
{pg}
You remember the feeling being small, walking through this space with a parent, an aunt, someone who loves you.
"""
NAME Virgin Dialogue

DLG k
Some things are always funny.
NAME Perseus Dialogue

DLG l
"""
You haven't been in a while, and it's a complicated place.
{pg}
But you need to get away without getting away.
{pg}
You're in the heat of August, and you could use some AC.
"""
NAME Entrance Dialogue

DLG m
"""
You loved this when you were small.
{pg}
Can you still see yourself in her?
"""
NAME Dancer Dialogue 1

DLG n
What did you want to be when you grew up?
NAME Dancer Dialogue 2

DLG o
"""
You think of a poem you like...
{pg}
"We cannot know his legendary head
{pg}
with eyes like ripening fruit. And yet his torso
{pg}
is still suffused with brilliance from inside,"
"""
NAME Poem 1

DLG p
"""
"like a lamp, in which his gaze, now turned to low,
{pg}
gleams in all its power. Otherwise
{pg}
the curved breast could not dazzle you so, nor could"
"""
NAME Poem 2

DLG q
"""
"a smile run through the placid hips and thighs
{pg}
to that dark center where procreation flared.
{pg}
Otherwise this stone would seem defaced"
"""
NAME Poem 3

DLG r
"""
"beneath the translucent cascade of shoulder
{pg}
and would not glisten like a wild beast's fur:"
"""
NAME Poem 4

DLG s
"""
"would not, from all the borders of itself,
{pg}
burst like a star: for here there is no place"
"""
NAME Poem 5

DLG t
Ugolino and His Sons, 1865-67, Jean-Baptiste Carpeaux
NAME Ugolino Placard

DLG u
Sometimes, you feel just like that.
NAME Ugolino Dialogue

VAR a
42

FONT unicode_european_small
SIZE 6 9
CHAR 0
000000
001010
010000
000010
010000
000010
010100
000000
000000
CHAR 32
000000
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 33
000000
001000
001000
001000
001000
000000
001000
000000
000000
CHAR 34
000000
010100
010100
010100
000000
000000
000000
000000
000000
CHAR 35
000000
010100
010100
111110
010100
111110
010100
010100
000000
CHAR 36
001000
011100
101010
101000
011100
001010
101010
011100
001000
CHAR 37
010000
101010
010010
000100
001000
010010
010101
000010
000000
CHAR 38
000000
011000
100100
100100
011000
100110
100100
011010
000000
CHAR 39
000000
001000
001000
001000
000000
000000
000000
000000
000000
CHAR 40
000000
000100
001000
001000
001000
001000
001000
000100
000000
CHAR 41
000000
001000
000100
000100
000100
000100
000100
001000
000000
CHAR 42
000000
000000
100010
010100
111110
010100
100010
000000
000000
CHAR 43
000000
000000
001000
001000
111110
001000
001000
000000
000000
CHAR 44
000000
000000
000000
000000
000000
001100
000100
000100
001000
CHAR 45
000000
000000
000000
000000
111110
000000
000000
000000
000000
CHAR 46
000000
000000
000000
000000
000000
001100
001100
000000
000000
CHAR 47
000000
000010
000010
000100
001000
010000
010000
000000
000000
CHAR 48
000000
001100
010010
010010
010010
010010
001100
000000
000000
CHAR 49
000000
001000
011000
001000
001000
001000
011100
000000
000000
CHAR 50
000000
001100
010010
000010
000100
001000
011110
000000
000000
CHAR 51
000000
011110
000100
001100
000010
000010
011100
000000
000000
CHAR 52
000000
000100
001100
010100
100100
111110
000100
000000
000000
CHAR 53
000000
011110
010000
011100
000010
000010
011100
000000
000000
CHAR 54
000000
001100
010000
011100
010010
010010
001100
000000
000000
CHAR 55
000000
011110
000010
000010
000100
001000
001000
000000
000000
CHAR 56
000000
001100
010010
001100
010010
010010
001100
000000
000000
CHAR 57
000000
001100
010010
010010
001110
000010
001100
000000
000000
CHAR 58
000000
000000
001100
001100
000000
001100
001100
000000
000000
CHAR 59
000000
000000
001100
001100
000000
001100
000100
000100
001000
CHAR 60
000000
000000
000110
011000
100000
011000
000110
000000
000000
CHAR 61
000000
000000
000000
111110
000000
111110
000000
000000
000000
CHAR 62
000000
000000
110000
001100
000010
001100
110000
000000
000000
CHAR 63
001100
010010
000010
001100
001000
000000
001000
000000
000000
CHAR 64
000000
011100
100100
101010
101100
100000
011100
000000
000000
CHAR 65
000000
001000
010100
100010
111110
100010
100010
000000
000000
CHAR 66
000000
111100
100010
111100
100010
100010
111100
000000
000000
CHAR 67
000000
001100
010010
010000
010000
010010
001100
000000
000000
CHAR 68
000000
011100
010010
010010
010010
010010
011100
000000
000000
CHAR 69
000000
011110
010000
011100
010000
010000
011110
000000
000000
CHAR 70
000000
011110
010000
011100
010000
010000
010000
000000
000000
CHAR 71
000000
001100
010010
010000
010110
010010
001100
000000
000000
CHAR 72
000000
010010
010010
011110
010010
010010
010010
000000
000000
CHAR 73
000000
011100
001000
001000
001000
001000
011100
000000
000000
CHAR 74
000000
001110
000100
000100
000100
100100
011000
000000
000000
CHAR 75
000000
010010
010100
011000
010100
010010
010010
000000
000000
CHAR 76
000000
010000
010000
010000
010000
010000
011110
000000
000000
CHAR 77
000000
100010
110110
101010
101010
100010
100010
000000
000000
CHAR 78
000000
010010
011010
010110
010010
010010
010010
000000
000000
CHAR 79
000000
011100
100010
100010
100010
100010
011100
000000
000000
CHAR 80
000000
011100
010010
010010
011100
010000
010000
000000
000000
CHAR 81
000000
001100
010010
010010
011010
010110
001100
000010
000000
CHAR 82
000000
011100
010010
010010
011100
010010
010010
000000
000000
CHAR 83
000000
001100
010010
001000
000100
010010
001100
000000
000000
CHAR 84
000000
111110
001000
001000
001000
001000
001000
000000
000000
CHAR 85
000000
010010
010010
010010
010010
010010
001100
000000
000000
CHAR 86
000000
010010
010010
010010
011110
001100
001100
000000
000000
CHAR 87
000000
100010
100010
101010
101010
110110
100010
000000
000000
CHAR 88
000000
100010
010100
001000
001000
010100
100010
000000
000000
CHAR 89
000000
100010
100010
010100
001000
001000
001000
000000
000000
CHAR 90
000000
011110
000010
000100
001000
010000
011110
000000
000000
CHAR 91
000000
011100
010000
010000
010000
010000
011100
000000
000000
CHAR 92
000000
010000
010000
001000
000100
000010
000010
000000
000000
CHAR 93
000000
011100
000100
000100
000100
000100
011100
000000
000000
CHAR 94
000000
001000
010100
100010
000000
000000
000000
000000
000000
CHAR 95
000000
000000
000000
000000
000000
000000
000000
000000
111110
CHAR 96
000000
001000
000100
000000
000000
000000
000000
000000
000000
CHAR 97
000000
000000
000000
001110
010010
010010
001110
000000
000000
CHAR 98
000000
010000
010000
011100
010010
010010
011100
000000
000000
CHAR 99
000000
000000
000000
001110
010000
010000
001110
000000
000000
CHAR 100
000000
000010
000010
001110
010010
010010
001110
000000
000000
CHAR 101
000000
000000
000000
001100
010110
011000
001110
000000
000000
CHAR 102
000000
000100
001010
001000
011100
001000
001000
000000
000000
CHAR 103
000000
000000
000000
001100
010010
010010
001110
000010
001100
CHAR 104
000000
010000
010000
011100
010010
010010
010010
000000
000000
CHAR 105
000000
001000
000000
011000
001000
001000
011100
000000
000000
CHAR 106
000000
000100
000000
001100
000100
000100
000100
010100
001000
CHAR 107
000000
010000
010000
010100
011000
010100
010010
000000
000000
CHAR 108
000000
011000
001000
001000
001000
001000
011100
000000
000000
CHAR 109
000000
000000
000000
110100
101010
101010
100010
000000
000000
CHAR 110
000000
000000
000000
011100
010010
010010
010010
000000
000000
CHAR 111
000000
000000
000000
001100
010010
010010
001100
000000
000000
CHAR 112
000000
000000
000000
011100
010010
010010
011100
010000
010000
CHAR 113
000000
000000
000000
001110
010010
010010
001110
000010
000010
CHAR 114
000000
000000
000000
010100
011010
010000
010000
000000
000000
CHAR 115
000000
000000
000000
001110
011000
000110
011100
000000
000000
CHAR 116
000000
001000
001000
011100
001000
001010
000100
000000
000000
CHAR 117
000000
000000
000000
010010
010010
010010
001110
000000
000000
CHAR 118
000000
000000
000000
010010
010010
001100
001100
000000
000000
CHAR 119
000000
000000
000000
100010
101010
101010
010100
000000
000000
CHAR 120
000000
000000
000000
010010
001100
001100
010010
000000
000000
CHAR 121
000000
000000
000000
010010
010010
010010
001110
010010
001100
CHAR 122
000000
000000
000000
011110
000100
001000
011110
000000
000000
CHAR 123
000100
001000
001000
010000
001000
001000
000100
000000
000000
CHAR 124
000000
001000
001000
001000
001000
001000
001000
001000
000000
CHAR 125
010000
001000
001000
000100
001000
001000
010000
000000
000000
CHAR 126
000000
000000
001010
010100
000000
000000
000000
000000
000000
CHAR 160
000000
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 161
000000
001000
000000
001000
001000
001000
001000
000000
000000
CHAR 162
000000
000000
000100
001110
010100
010100
001110
000100
000000
CHAR 163
000000
001100
010010
010000
111100
010000
010000
111110
000000
CHAR 164
000000
000000
101010
010100
100010
010100
101010
000000
000000
CHAR 165
000000
100010
010100
111110
001000
111110
001000
000000
000000
CHAR 166
000000
001000
001000
001000
000000
001000
001000
001000
000000
CHAR 167
000000
001110
010000
001100
010010
001100
000010
011100
000000
CHAR 168
000000
010100
000000
000000
000000
000000
000000
000000
000000
CHAR 169
011110
100001
100101
101001
100101
100001
011110
000000
000000
CHAR 170
000000
001100
010100
001100
000000
011100
000000
000000
000000
CHAR 171
000000
000000
001010
010100
101000
010100
001010
000000
000000
CHAR 172
000000
000000
000000
000000
011110
000010
000010
000000
000000
CHAR 173
000000
000000
000000
000000
011110
000000
000000
000000
000000
CHAR 174
011110
100001
101101
101001
101001
100001
011110
000000
000000
CHAR 175
000000
011110
000000
000000
000000
000000
000000
000000
000000
CHAR 176
000000
000000
001100
010010
001100
000000
000000
000000
000000
CHAR 177
000000
001000
001000
111110
001000
001000
000000
111110
000000
CHAR 178
000000
001000
010100
000100
001000
011100
000000
000000
000000
CHAR 179
000000
011000
000100
001000
000100
011000
000000
000000
000000
CHAR 180
000000
000100
001000
000000
000000
000000
000000
000000
000000
CHAR 181
000000
000000
000000
010010
010010
010110
011010
010000
000000
CHAR 182
000000
011110
111010
111010
011010
001010
001010
000000
000000
CHAR 183
000000
000000
000000
000000
001000
000000
000000
000000
000000
CHAR 184
000000
000000
000000
000000
000000
000000
000000
000100
001000
CHAR 185
000000
001000
011000
001000
001000
011100
000000
000000
000000
CHAR 186
000000
001000
010100
001000
000000
011100
000000
000000
000000
CHAR 187
000000
000000
101000
010100
001010
010100
101000
000000
000000
CHAR 188
010000
110000
010000
010100
011100
001100
011110
000100
000000
CHAR 189
010000
110000
010000
010100
011010
000010
000100
001110
000000
CHAR 190
110000
001000
010000
001100
111100
001100
011110
000100
000000
CHAR 191
000100
000000
000100
001100
010000
010010
001100
000000
000000
CHAR 192
010000
001000
001000
010100
011100
100010
100010
000000
000000
CHAR 193
000100
001000
001000
010100
011100
100010
100010
000000
000000
CHAR 194
001000
010100
001000
010100
011100
100010
100010
000000
000000
CHAR 195
001010
010100
001000
010100
011100
100010
100010
000000
000000
CHAR 196
010100
000000
001000
010100
011100
100010
100010
000000
000000
CHAR 197
001000
010100
001000
010100
011100
100010
100010
000000
000000
CHAR 198
000000
011110
101000
111100
101000
101000
101110
000000
000000
CHAR 199
000000
001100
010010
010000
010000
010010
001100
000100
001000
CHAR 200
001000
000100
011110
010000
011100
010000
011110
000000
000000
CHAR 201
000100
001000
011110
010000
011100
010000
011110
000000
000000
CHAR 202
000100
001010
011110
010000
011100
010000
011110
000000
000000
CHAR 203
001010
000000
011110
010000
011100
010000
011110
000000
000000
CHAR 204
010000
001000
011100
001000
001000
001000
011100
000000
000000
CHAR 205
000100
001000
011100
001000
001000
001000
011100
000000
000000
CHAR 206
001000
010100
011100
001000
001000
001000
011100
000000
000000
CHAR 207
010100
000000
011100
001000
001000
001000
011100
000000
000000
CHAR 208
000000
011100
010010
111010
010010
010010
011100
000000
000000
CHAR 209
001010
010100
010010
011010
010110
010010
010010
000000
000000
CHAR 210
001000
000100
001100
010010
010010
010010
001100
000000
000000
CHAR 211
000100
001000
001100
010010
010010
010010
001100
000000
000000
CHAR 212
000100
001010
001100
010010
010010
010010
001100
000000
000000
CHAR 213
001010
010100
001100
010010
010010
010010
001100
000000
000000
CHAR 214
001010
000000
001100
010010
010010
010010
001100
000000
000000
CHAR 215
000000
000000
100010
010100
001000
010100
100010
000000
000000
CHAR 216
000010
001110
010110
010110
011010
011010
011100
010000
000000
CHAR 217
001000
000100
010010
010010
010010
010010
001100
000000
000000
CHAR 218
000100
001000
010010
010010
010010
010010
001100
000000
000000
CHAR 219
000100
001010
010010
010010
010010
010010
001100
000000
000000
CHAR 220
001010
000000
010010
010010
010010
010010
001100
000000
000000
CHAR 221
000100
001000
100010
010100
001000
001000
001000
000000
000000
CHAR 222
000000
010000
011100
010010
010010
011100
010000
000000
000000
CHAR 223
000000
001100
010010
010100
010100
010010
010100
000000
000000
CHAR 224
001000
000100
000000
001110
010010
010010
001110
000000
000000
CHAR 225
000100
001000
000000
001110
010010
010010
001110
000000
000000
CHAR 226
000100
001010
000000
001110
010010
010010
001110
000000
000000
CHAR 227
001010
010100
000000
001110
010010
010010
001110
000000
000000
CHAR 228
000000
001010
000000
001110
010010
010010
001110
000000
000000
CHAR 229
000100
001010
000100
001110
010010
010010
001110
000000
000000
CHAR 230
000000
000000
000000
011100
101010
101100
011110
000000
000000
CHAR 231
000000
000000
000000
001110
010000
010000
001110
000100
001000
CHAR 232
001000
000100
000000
001100
010110
011000
001110
000000
000000
CHAR 233
000100
001000
000000
001100
010110
011000
001110
000000
000000
CHAR 234
000100
001010
000000
001100
010110
011000
001110
000000
000000
CHAR 235
000000
001010
000000
001100
010110
011000
001110
000000
000000
CHAR 236
010000
001000
000000
011000
001000
001000
011100
000000
000000
CHAR 237
000100
001000
000000
011000
001000
001000
011100
000000
000000
CHAR 238
001000
010100
000000
011000
001000
001000
011100
000000
000000
CHAR 239
000000
010100
000000
011000
001000
001000
011100
000000
000000
CHAR 240
000110
001100
000010
001110
010010
010010
001100
000000
000000
CHAR 241
001010
010100
000000
011100
010010
010010
010010
000000
000000
CHAR 242
001000
000100
000000
001100
010010
010010
001100
000000
000000
CHAR 243
000100
001000
000000
001100
010010
010010
001100
000000
000000
CHAR 244
000100
001010
000000
001100
010010
010010
001100
000000
000000
CHAR 245
001010
010100
000000
001100
010010
010010
001100
000000
000000
CHAR 246
000000
001010
000000
001100
010010
010010
001100
000000
000000
CHAR 247
000000
000000
001000
000000
111110
000000
001000
000000
000000
CHAR 248
000000
000000
000000
001110
010110
011010
011100
000000
000000
CHAR 249
001000
000100
000000
010010
010010
010010
001110
000000
000000
CHAR 250
000100
001000
000000
010010
010010
010010
001110
000000
000000
CHAR 251
000100
001010
000000
010010
010010
010010
001110
000000
000000
CHAR 252
000000
001010
000000
010010
010010
010010
001110
000000
000000
CHAR 253
000100
001000
000000
010010
010010
010010
001110
010010
001100
CHAR 254
000000
010000
010000
011100
010010
010010
011100
010000
010000
CHAR 255
000000
001010
000000
010010
010010
010010
001110
010010
001100
CHAR 256
011100
000000
001000
010100
011100
100010
100010
000000
000000
CHAR 257
000000
001110
000000
001110
010010
010010
001110
000000
000000
CHAR 258
100100
011000
001000
010100
011100
100010
100010
000000
000000
CHAR 259
010010
001100
000000
001110
010010
010010
001110
000000
000000
CHAR 260
000000
001000
010100
100010
111110
100010
100010
000100
000010
CHAR 261
000000
000000
000000
001110
010010
010010
001110
000100
000010
CHAR 262
000100
001000
001100
010010
010000
010010
001100
000000
000000
CHAR 263
000100
001000
000000
001110
010000
010000
001110
000000
000000
CHAR 264
000100
001010
001100
010010
010000
010010
001100
000000
000000
CHAR 265
000100
001010
000000
001110
010000
010000
001110
000000
000000
CHAR 266
000100
000000
001100
010010
010000
010010
001100
000000
000000
CHAR 267
000000
000100
000000
001110
010000
010000
001110
000000
000000
CHAR 268
001010
000100
001100
010010
010000
010010
001100
000000
000000
CHAR 269
001010
000100
000000
001110
010000
010000
001110
000000
000000
CHAR 270
001010
000100
011100
010010
010010
010010
011100
000000
000000
CHAR 271
010100
001010
000010
001110
010010
010010
001110
000000
000000
CHAR 272
000000
011100
010010
111010
010010
010010
011100
000000
000000
CHAR 273
000000
000100
001110
011100
100100
100100
011100
000000
000000
CHAR 274
011110
000000
011110
010000
011100
010000
011110
000000
000000
CHAR 275
000000
011110
000000
001100
010110
011000
001110
000000
000000
CHAR 276
010010
001100
011110
010000
011100
010000
011110
000000
000000
CHAR 277
010010
001100
000000
001100
010110
011000
001110
000000
000000
CHAR 278
001000
000000
011110
010000
011100
010000
011110
000000
000000
CHAR 279
000000
001000
000000
001100
010110
011000
001110
000000
000000
CHAR 280
000000
011110
010000
011100
010000
010000
011110
001000
000100
CHAR 281
000000
000000
000000
001100
010110
011000
001110
001000
000100
CHAR 282
001010
000100
011110
010000
011100
010000
011110
000000
000000
CHAR 283
001010
000100
000000
001100
010110
011000
001110
000000
000000
CHAR 284
000100
001010
001110
010000
010110
010010
001100
000000
000000
CHAR 285
000100
001010
000000
001100
010010
010010
001110
000010
001100
CHAR 286
010010
001100
001110
010000
010110
010010
001100
000000
000000
CHAR 287
010010
001100
000000
001100
010010
010010
001110
000010
001100
CHAR 288
000100
000000
001110
010000
010110
010010
001100
000000
000000
CHAR 289
000000
000100
000000
001100
010010
010010
001110
000010
001100
CHAR 290
000000
001100
010010
010000
010110
010010
001100
000100
001000
CHAR 291
000000
000100
001000
001100
010010
010010
001110
000010
001100
CHAR 292
000100
001010
000000
010010
011110
010010
010010
000000
000000
CHAR 293
000100
101010
100000
111000
100100
100100
100100
000000
000000
CHAR 294
000000
010100
111110
010100
011100
010100
010100
000000
000000
CHAR 295
000000
010000
111000
011100
010010
010010
010010
000000
000000
CHAR 296
001010
010100
001110
000100
000100
000100
001110
000000
000000
CHAR 297
001010
010100
000000
001100
000100
000100
001110
000000
000000
CHAR 298
011100
000000
011100
001000
001000
001000
011100
000000
000000
CHAR 299
000000
011100
000000
011000
001000
001000
011100
000000
000000
CHAR 300
010010
001100
000000
001110
000100
000100
001110
000000
000000
CHAR 301
010010
001100
000000
001100
000100
000100
001110
000000
000000
CHAR 302
000000
011100
001000
001000
001000
001000
011100
001000
000100
CHAR 303
000000
001000
000000
011000
001000
001000
011100
001000
000100
CHAR 304
001000
000000
011100
001000
001000
001000
011100
000000
000000
CHAR 305
000000
000000
000000
011000
001000
001000
011100
000000
000000
CHAR 306
000000
101110
100010
100010
100010
101010
100100
000000
000000
CHAR 307
000000
100010
000000
100110
100010
100010
100010
001010
000100
CHAR 308
000100
001010
001110
000100
000100
100100
011000
000000
000000
CHAR 309
000100
001010
000000
001100
000100
000100
000100
010100
001000
CHAR 310
000000
010010
010100
011000
010100
010010
010010
001000
010000
CHAR 311
000000
010000
010000
010100
011000
010100
010010
001000
010000
CHAR 312
000000
000000
000000
010110
011000
010100
010010
000000
000000
CHAR 313
000010
000100
010000
010000
010000
010000
011110
000000
000000
CHAR 314
001000
010000
011000
001000
001000
001000
011100
000000
000000
CHAR 315
000000
010000
010000
010000
010000
010000
011110
000100
001000
CHAR 316
000000
011000
001000
001000
001000
001000
011100
001000
010000
CHAR 317
001010
000100
010000
010000
010000
010000
011110
000000
000000
CHAR 318
010100
001000
011000
001000
001000
001000
011100
000000
000000
CHAR 319
000000
010000
010000
010100
010000
010000
011110
000000
000000
CHAR 320
000000
011000
001000
001010
001000
001000
011100
000000
000000
CHAR 321
000000
010000
010000
011000
110000
010000
011110
000000
000000
CHAR 322
000000
011000
001000
001100
011000
001000
011100
000000
000000
CHAR 323
000100
001000
010010
011010
010110
010010
010010
000000
000000
CHAR 324
000100
001000
000000
011100
010010
010010
010010
000000
000000
CHAR 325
000000
010010
011010
010110
010010
010010
010010
001000
010000
CHAR 326
000000
000000
000000
011100
010010
010010
010010
001000
010000
CHAR 327
001010
000100
010010
011010
010110
010010
010010
000000
000000
CHAR 328
010100
001000
000000
011100
010010
010010
010010
000000
000000
CHAR 329
000000
110000
010000
101100
001010
001010
001010
000000
000000
CHAR 330
000000
010010
011010
010110
010010
010010
010010
000010
000100
CHAR 331
000000
000000
000000
011100
010010
010010
010010
000010
000100
CHAR 332
111110
000000
011100
100010
100010
100010
011100
000000
000000
CHAR 333
000000
011110
000000
001100
010010
010010
001100
000000
000000
CHAR 334
100010
011100
011100
100010
100010
100010
011100
000000
000000
CHAR 335
010010
001100
000000
001100
010010
010010
001100
000000
000000
CHAR 336
010010
100100
011100
100010
100010
100010
011100
000000
000000
CHAR 337
010010
100100
000000
011000
100100
100100
011000
000000
000000
CHAR 338
000000
011110
101000
101100
101000
101000
011110
000000
000000
CHAR 339
000000
000000
000000
010100
101010
101100
010110
000000
000000
CHAR 340
000100
001000
011100
010010
011100
010100
010010
000000
000000
CHAR 341
000100
001000
000000
010100
011010
010000
010000
000000
000000
CHAR 342
000000
011100
010010
010010
011100
010010
010010
001000
010000
CHAR 343
000000
000000
000000
010100
011010
010000
010000
001000
010000
CHAR 344
010100
001000
011100
010010
011100
010100
010010
000000
000000
CHAR 345
010100
001000
000000
010100
011010
010000
010000
000000
000000
CHAR 346
000100
001000
001110
010000
001100
000010
011100
000000
000000
CHAR 347
000100
001000
000000
001110
011000
000110
011100
000000
000000
CHAR 348
000100
001010
001110
010000
001100
000010
011100
000000
000000
CHAR 349
000100
001010
000000
001110
011000
000110
011100
000000
000000
CHAR 350
000000
001100
010010
001000
000100
010010
001100
000100
001000
CHAR 351
000000
000000
000000
001110
011000
000110
011100
000100
001000
CHAR 352
001010
000100
001110
010000
001100
000010
011100
000000
000000
CHAR 353
001010
000100
000000
001110
011000
000110
011100
000000
000000
CHAR 354
000000
111110
001000
001000
001000
001000
001000
000100
001000
CHAR 355
000000
001000
001000
011100
001000
001010
000100
000100
001000
CHAR 356
010100
001000
111110
001000
001000
001000
001000
000000
000000
CHAR 357
001010
000100
001000
011100
001000
001010
000100
000000
000000
CHAR 358
000000
111110
001000
001000
011100
001000
001000
000000
000000
CHAR 359
000000
001000
001000
011100
011100
001010
000100
000000
000000
CHAR 360
001010
010100
000000
010010
010010
010010
001100
000000
000000
CHAR 361
001010
010100
000000
010010
010010
010010
001110
000000
000000
CHAR 362
011110
000000
010010
010010
010010
010010
001100
000000
000000
CHAR 363
000000
011110
000000
010010
010010
010010
001110
000000
000000
CHAR 364
010010
001100
000000
010010
010010
010010
001100
000000
000000
CHAR 365
010010
001100
000000
010010
010010
010010
001110
000000
000000
CHAR 366
001100
010010
001100
010010
010010
010010
001100
000000
000000
CHAR 367
001100
010010
001100
010010
010010
010010
001110
000000
000000
CHAR 368
010010
100100
000000
100100
100100
100100
011000
000000
000000
CHAR 369
010010
100100
000000
100100
100100
100100
011100
000000
000000
CHAR 370
000000
010010
010010
010010
010010
010010
001100
001000
000100
CHAR 371
000000
000000
000000
010010
010010
010010
001110
001000
000100
CHAR 372
001000
010100
000000
100010
101010
110110
100010
000000
000000
CHAR 373
001000
010100
000000
100010
101010
101010
010100
000000
000000
CHAR 374
001000
010100
000000
100010
010100
001000
001000
000000
000000
CHAR 375
000100
001010
000000
010010
010010
010010
001110
010010
001100
CHAR 376
010100
000000
100010
010100
001000
001000
001000
000000
000000
CHAR 377
000100
001000
011110
000100
001000
010000
011110
000000
000000
CHAR 378
000100
001000
000000
011110
000100
001000
011110
000000
000000
CHAR 379
000100
000000
011110
000100
001000
010000
011110
000000
000000
CHAR 380
000000
000100
000000
011110
000100
001000
011110
000000
000000
CHAR 381
001010
000100
011110
000100
001000
010000
011110
000000
000000
CHAR 382
001010
000100
000000
011110
000100
001000
011110
000000
000000
CHAR 383
000000
000100
001010
011000
001000
001000
001000
000000
000000
CHAR 399
000000
001100
010010
000010
011110
010010
001100
000000
000000
CHAR 402
000000
000100
001010
001000
011100
001000
001000
001000
010000
CHAR 416
000000
011001
100101
100110
100100
100100
011000
000000
000000
CHAR 417
000000
000000
000000
001101
010010
010010
001100
000000
000000
CHAR 431
000000
010101
010101
010110
010100
010100
001000
000000
000000
CHAR 432
000000
000000
000000
010101
010110
010100
001100
000000
000000
CHAR 437
000000
011110
000010
011110
001000
010000
011110
000000
000000
CHAR 438
000000
000000
000000
011110
011110
001000
011110
000000
000000
CHAR 465
001010
000100
001100
010010
010010
010010
001100
000000
000000
CHAR 466
001010
000100
000000
001100
010010
010010
001100
000000
000000
CHAR 486
001010
000100
001110
010000
010110
010010
001100
000000
000000
CHAR 487
001010
000100
000000
001100
010010
010010
001110
000010
001100
CHAR 506
000100
001000
010100
001000
010100
011100
010100
000000
000000
CHAR 507
000010
000100
001010
001110
010010
010010
001110
000000
000000
CHAR 508
000100
001000
011110
101000
111100
101000
101110
000000
000000
CHAR 509
000100
001000
000000
011100
101010
101100
011110
000000
000000
CHAR 510
000010
000100
001110
010110
011010
011010
011100
000000
000000
CHAR 511
000100
001000
000000
001110
010110
011010
011100
000000
000000
CHAR 536
000000
001100
010010
001000
000100
010010
001100
000100
001000
CHAR 537
000000
000000
000000
001110
011000
000110
011100
000100
001000
CHAR 538
000000
111110
001000
001000
001000
001000
001000
000100
001000
CHAR 539
000000
001000
001000
011100
001000
001010
000100
000100
001000
CHAR 600
000000
000000
000000
001100
011010
000110
011100
000000
000000
CHAR 601
000000
000000
000000
011100
000110
011010
001100
000000
000000
CHAR 699
000000
000100
001000
001100
000000
000000
000000
000000
000000
CHAR 700
000000
001100
000100
001000
000000
000000
000000
000000
000000
CHAR 701
000000
001100
001000
000100
000000
000000
000000
000000
000000
CHAR 710
001000
010100
000000
000000
000000
000000
000000
000000
000000
CHAR 711
010100
001000
000000
000000
000000
000000
000000
000000
000000
CHAR 713
000000
011100
000000
000000
000000
000000
000000
000000
000000
CHAR 728
010010
001100
000000
000000
000000
000000
000000
000000
000000
CHAR 729
000000
001000
000000
000000
000000
000000
000000
000000
000000
CHAR 730
001000
010100
001000
000000
000000
000000
000000
000000
000000
CHAR 731
000000
000000
000000
000000
000000
000000
000000
001000
000100
CHAR 732
001010
010100
000000
000000
000000
000000
000000
000000
000000
CHAR 733
010010
100100
000000
000000
000000
000000
000000
000000
000000
CHAR 768
010000
001000
000000
000000
000000
000000
000000
000000
000000
CHAR 769
000100
001000
000000
000000
000000
000000
000000
000000
000000
CHAR 770
001000
010100
000000
000000
000000
000000
000000
000000
000000
CHAR 771
001010
010100
000000
000000
000000
000000
000000
000000
000000
CHAR 772
011100
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 773
111110
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 774
100010
011100
000000
000000
000000
000000
000000
000000
000000
CHAR 775
001000
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 776
010100
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 777
011000
000100
001000
000000
000000
000000
000000
000000
000000
CHAR 778
001000
010100
001000
000000
000000
000000
000000
000000
000000
CHAR 779
010010
100100
000000
000000
000000
000000
000000
000000
000000
CHAR 780
010100
001000
000000
000000
000000
000000
000000
000000
000000
CHAR 781
001000
001000
000000
000000
000000
000000
000000
000000
000000
CHAR 782
010100
010100
000000
000000
000000
000000
000000
000000
000000
CHAR 783
100100
010010
000000
000000
000000
000000
000000
000000
000000
CHAR 784
101010
011100
000000
000000
000000
000000
000000
000000
000000
CHAR 785
011100
100010
000000
000000
000000
000000
000000
000000
000000
CHAR 786
000100
001000
001100
000000
000000
000000
000000
000000
000000
CHAR 787
001100
000100
001000
000000
000000
000000
000000
000000
000000
CHAR 788
001100
001000
000100
000000
000000
000000
000000
000000
000000
CHAR 803
000000
000000
000000
000000
000000
000000
000000
000000
001000
CHAR 804
000000
000000
000000
000000
000000
000000
000000
000000
010100
CHAR 884
000100
001000
000000
000000
000000
000000
000000
000000
000000
CHAR 885
000000
000000
000000
000000
000000
000000
000000
000100
001000
CHAR 890
000000
000000
000000
000000
000000
000000
000000
001000
001100
CHAR 894
000000
000000
001100
001100
000000
001100
000100
000100
001000
CHAR 900
001000
001000
000000
000000
000000
000000
000000
000000
000000
CHAR 901
001000
101010
000000
000000
000000
000000
000000
000000
000000
CHAR 902
100000
101100
010010
010010
011110
010010
010010
000000
000000
CHAR 903
000000
000000
000000
000000
001000
000000
000000
000000
000000
CHAR 904
100000
101110
001000
001100
001000
001000
001110
000000
000000
CHAR 905
100000
101010
001010
001110
001010
001010
001010
000000
000000
CHAR 906
100000
101110
000100
000100
000100
000100
001110
000000
000000
CHAR 908
100000
101100
010010
010010
010010
010010
001100
000000
000000
CHAR 910
100000
101010
001010
001010
000100
000100
000100
000000
000000
CHAR 911
100000
101100
010010
010010
010010
001100
011110
000000
000000
CHAR 912
001000
101010
000000
001000
001000
001000
000100
000000
000000
CHAR 913
000000
001000
010100
100010
111110
100010
100010
000000
000000
CHAR 914
000000
111100
100010
111100
100010
100010
111100
000000
000000
CHAR 915
000000
011110
010000
010000
010000
010000
010000
000000
000000
CHAR 916
000000
001000
001000
010100
010100
100010
111110
000000
000000
CHAR 917
000000
011110
010000
011100
010000
010000
011110
000000
000000
CHAR 918
000000
011110
000010
000100
001000
010000
011110
000000
000000
CHAR 919
000000
010010
010010
011110
010010
010010
010010
000000
000000
CHAR 920
000000
011100
100010
111110
100010
100010
011100
000000
000000
CHAR 921
000000
011100
001000
001000
001000
001000
011100
000000
000000
CHAR 922
000000
010010
010100
011000
010100
010010
010010
000000
000000
CHAR 923
000000
001000
001000
010100
010100
100010
100010
000000
000000
CHAR 924
000000
100010
110110
101010
101010
100010
100010
000000
000000
CHAR 925
000000
010010
011010
010110
010010
010010
010010
000000
000000
CHAR 926
000000
011110
000000
001100
000000
000000
011110
000000
000000
CHAR 927
000000
011100
100010
100010
100010
100010
011100
000000
000000
CHAR 928
000000
011110
010010
010010
010010
010010
010010
000000
000000
CHAR 929
000000
011100
010010
010010
011100
010000
010000
000000
000000
CHAR 931
000000
011110
010000
001000
001000
010000
011110
000000
000000
CHAR 932
000000
111110
001000
001000
001000
001000
001000
000000
000000
CHAR 933
000000
100010
100010
010100
001000
001000
001000
000000
000000
CHAR 934
000000
001000
011100
101010
101010
011100
001000
000000
000000
CHAR 935
000000
100010
010100
001000
001000
010100
100010
000000
000000
CHAR 936
000000
101010
101010
101010
011100
001000
001000
000000
000000
CHAR 937
000000
011100
100010
100010
100010
010100
110110
000000
000000
CHAR 938
010100
000000
011100
001000
001000
001000
011100
000000
000000
CHAR 939
010100
000000
100010
010100
001000
001000
001000
000000
000000
CHAR 940
000010
000100
000000
001110
010010
010010
001110
000000
000000
CHAR 941
000010
000100
000000
001100
010110
011000
001110
000000
000000
CHAR 942
000100
001000
000000
101100
110010
100010
100010
000010
000010
CHAR 943
001000
010000
000000
010000
010000
010100
001000
000000
000000
CHAR 944
001000
101010
000000
100010
100010
100010
011100
000000
000000
CHAR 945
000000
000000
000000
001110
010010
010010
001110
000000
000000
CHAR 946
000000
001100
010010
011100
010010
010010
011100
010000
010000
CHAR 947
000000
000000
000000
100010
100010
010100
010100
001000
001000
CHAR 948
000000
011100
100000
011100
100010
100010
011100
000000
000000
CHAR 949
000000
000000
000000
001100
010110
011000
001110
000000
000000
CHAR 950
000000
111110
001000
010000
010000
001100
000010
001100
000000
CHAR 951
000000
000000
000000
101100
110010
100010
100010
000010
000010
CHAR 952
000000
001100
010010
011110
010010
010010
001100
000000
000000
CHAR 953
000000
000000
000000
010000
010000
010100
001000
000000
000000
CHAR 954
000000
000000
000000
010010
010100
011000
010110
000000
000000
CHAR 955
000000
011100
100010
000010
011010
100110
100010
000000
000000
CHAR 956
000000
000000
000000
100010
100010
100110
111010
100000
100000
CHAR 957
000000
000000
000000
100010
100010
010100
001000
000000
000000
CHAR 958
000000
111110
001000
010000
011100
100000
011100
000010
000100
CHAR 959
000000
000000
000000
001100
010010
010010
001100
000000
000000
CHAR 960
000000
000000
000000
111110
010100
010100
010100
000000
000000
CHAR 961
000000
000000
000000
011100
100010
100010
111100
100000
100000
CHAR 962
000000
000000
000000
011100
100010
100000
011100
000010
001100
CHAR 963
000000
000000
000000
011110
100100
100010
011100
000000
000000
CHAR 964
000000
000000
000000
011110
001000
001010
000100
000000
000000
CHAR 965
000000
000000
000000
100010
100010
100010
011100
000000
000000
CHAR 966
000000
000000
000000
100100
101010
101010
011100
001000
001000
CHAR 967
000000
000000
000000
100010
010100
001000
010100
100010
100010
CHAR 968
000000
000000
000000
101010
101010
101010
011100
001000
001000
CHAR 969
000000
000000
000000
010100
100010
101010
010100
000000
000000
CHAR 970
000000
010100
000000
001000
001000
001010
000100
000000
000000
CHAR 971
000000
010100
000000
100010
100010
100010
011100
000000
000000
CHAR 972
000100
001000
000000
011100
100010
100010
011100
000000
000000
CHAR 973
000100
001000
000000
100010
100010
100010
011100
000000
000000
CHAR 974
000100
001000
000000
010100
100010
101010
010100
000000
000000
CHAR 976
000000
011000
100100
100100
111100
100010
011100
000000
000000
CHAR 977
000000
001000
010100
001110
110100
010100
001000
000000
000000
CHAR 978
000000
100100
101010
010000
010000
010000
010000
000000
000000
CHAR 979
000000
110100
001010
011000
101000
001000
001000
000000
000000
CHAR 980
101000
000000
100100
101010
010000
010000
010000
000000
000000
CHAR 981
000000
001000
001000
011100
101010
101010
011100
001000
001000
CHAR 982
000000
000000
000000
111110
100010
101010
010100
000000
000000
CHAR 983
000100
001000
000000
100010
010010
011100
100010
000010
001100
CHAR 986
000000
001100
010010
100000
100000
100000
011100
000010
000100
CHAR 987
000000
000000
000010
011100
100000
100000
011100
000010
001100
CHAR 988
000000
111110
100000
100000
111000
100000
100000
000000
000000
CHAR 989
000000
000000
000000
011110
010000
010000
011100
010000
010000
CHAR 990
000000
100000
100010
100110
101010
110010
000010
000000
000000
CHAR 991
000000
001000
010000
100000
111110
000010
000100
001000
001000
CHAR 992
000000
001000
010100
010100
100110
101010
101010
000000
000000
CHAR 993
000000
111000
000100
001100
010010
000110
001010
000010
000010
CHAR 994
000000
101010
101010
101010
101010
011110
000010
111100
000000
CHAR 995
000000
000000
000000
101010
101010
011110
000010
111100
000000
CHAR 996
000000
010010
101010
100010
011110
000010
000010
000000
000000
CHAR 997
000000
000000
000000
001010
010010
001110
000010
000000
000000
CHAR 998
000000
100000
100000
101100
110010
100010
000010
111100
000000
CHAR 999
000000
001000
011100
101010
010010
000010
111100
000000
000000
CHAR 1000
000000
011100
100010
000010
011100
100000
011110
000000
000000
CHAR 1001
000000
000000
011100
100010
011100
100000
011110
000000
000000
CHAR 1002
000000
010100
101010
001000
010100
100010
111110
000000
000000
CHAR 1003
000000
000000
010100
101010
001000
010100
011100
000000
000000
CHAR 1004
000000
000010
011100
100000
111100
100010
011100
000000
000000
CHAR 1005
000000
000000
000010
011100
100000
110110
011100
000000
000000
CHAR 1006
000000
011100
001000
111110
101010
001000
011100
000000
000000
CHAR 1007
000000
001000
001100
001000
111110
101000
001000
011000
001000
CHAR 1008
000000
000000
000000
100010
010010
011100
100010
000000
000000
CHAR 1009
000000
000000
000000
011100
100010
100010
111100
100000
011110
CHAR 1010
000000
000000
000000
011100
100010
100000
011110
000000
000000
CHAR 1011
000000
000010
000000
000110
000010
000010
010010
010010
001100
CHAR 1012
000000
011100
100010
111110
100010
100010
011100
000000
000000
CHAR 1013
000000
000000
000000
001110
011100
010000
001110
000000
000000
CHAR 1024
001000
000100
011110
010000
011100
010000
011110
000000
000000
CHAR 1025
001010
000000
011110
010000
011100
010000
011110
000000
000000
CHAR 1026
000000
111110
001000
001100
001010
001010
001010
000010
000100
CHAR 1027
000100
001000
011110
010000
010000
010000
010000
000000
000000
CHAR 1028
000000
011100
100010
111000
100000
100010
011100
000000
000000
CHAR 1029
000000
001100
010010
001000
000100
010010
001100
000000
000000
CHAR 1030
000000
011100
001000
001000
001000
001000
011100
000000
000000
CHAR 1031
010100
000000
011100
001000
001000
001000
011100
000000
000000
CHAR 1032
000000
001110
000100
000100
000100
100100
011000
000000
000000
CHAR 1033
000000
011000
101000
101100
101010
101010
101100
000000
000000
CHAR 1034
000000
101000
101000
111100
101010
101010
101100
000000
000000
CHAR 1035
000000
111110
001000
001100
001010
001010
001010
000000
000000
CHAR 1036
000010
000100
010010
010100
011000
010100
010010
000000
000000
CHAR 1037
010000
001000
100010
100110
101010
110010
100010
000000
000000
CHAR 1038
010010
001100
100010
100010
011110
000010
011100
000000
000000
CHAR 1039
000000
100010
100010
100010
100010
100010
111110
001000
001000
CHAR 1040
000000
001000
010100
100010
111110
100010
100010
000000
000000
CHAR 1041
000000
111100
100000
111100
100010
100010
111100
000000
000000
CHAR 1042
000000
111100
100010
111100
100010
100010
111100
000000
000000
CHAR 1043
000000
011110
010000
010000
010000
010000
010000
000000
000000
CHAR 1044
000000
001100
010100
010100
010100
010100
111110
100010
000000
CHAR 1045
000000
011110
010000
011100
010000
010000
011110
000000
000000
CHAR 1046
000000
101010
101010
011100
101010
101010
101010
000000
000000
CHAR 1047
000000
011100
100010
001100
000010
100010
011100
000000
000000
CHAR 1048
000000
010010
010110
011010
010010
010010
010010
000000
000000
CHAR 1049
010010
001100
010010
010110
011010
010010
010010
000000
000000
CHAR 1050
000000
010010
010100
011000
010100
010010
010010
000000
000000
CHAR 1051
000000
001110
010010
010010
010010
010010
100010
000000
000000
CHAR 1052
000000
100010
110110
101010
101010
100010
100010
000000
000000
CHAR 1053
000000
010010
010010
011110
010010
010010
010010
000000
000000
CHAR 1054
000000
011100
100010
100010
100010
100010
011100
000000
000000
CHAR 1055
000000
111110
100010
100010
100010
100010
100010
000000
000000
CHAR 1056
000000
011100
010010
010010
011100
010000
010000
000000
000000
CHAR 1057
000000
001100
010010
010000
010000
010010
001100
000000
000000
CHAR 1058
000000
111110
001000
001000
001000
001000
001000
000000
000000
CHAR 1059
000000
100010
100010
100010
011110
000010
011100
000000
000000
CHAR 1060
000000
001000
011100
101010
101010
011100
001000
000000
000000
CHAR 1061
000000
100010
010100
001000
001000
010100
100010
000000
000000
CHAR 1062
000000
100100
100100
100100
100100
100100
111110
000010
000100
CHAR 1063
000000
100010
100010
100010
011110
000010
000010
000000
000000
CHAR 1064
000000
101010
101010
101010
101010
101010
111110
000000
000000
CHAR 1065
000000
101010
101010
101010
101010
101010
111110
000010
000100
CHAR 1066
000000
110000
010000
011100
010010
010010
011100
000000
000000
CHAR 1067
000000
100010
100010
111010
100110
100110
111010
000000
000000
CHAR 1068
000000
010000
010000
011100
010010
010010
011100
000000
000000
CHAR 1069
000000
011100
100010
001110
000010
100010
011100
000000
000000
CHAR 1070
000000
100100
101010
111010
111010
101010
100100
000000
000000
CHAR 1071
000000
001110
010010
010010
001110
010010
010010
000000
000000
CHAR 1072
000000
000000
000000
011100
100100
100100
011110
000000
000000
CHAR 1073
000010
001100
010000
011100
010010
010010
001100
000000
000000
CHAR 1074
000000
000000
000000
011000
010100
011010
011100
000000
000000
CHAR 1075
000000
000000
000000
011110
010000
010000
010000
000000
000000
CHAR 1076
000000
000000
000000
001100
010100
010100
111110
100010
000000
CHAR 1077
000000
000000
000000
011000
100100
111000
011100
000000
000000
CHAR 1078
000000
000000
000000
101010
011100
011100
101010
000000
000000
CHAR 1079
000000
000000
000000
001100
001010
000110
011100
000000
000000
CHAR 1080
000000
000000
000000
100010
100110
101010
110010
000000
000000
CHAR 1081
100010
011100
000000
100010
100110
101010
110010
000000
000000
CHAR 1082
000000
000000
000000
010010
010100
011100
010010
000000
000000
CHAR 1083
000000
000000
000000
001110
010010
010010
100010
000000
000000
CHAR 1084
000000
000000
000000
100010
110110
101010
100010
000000
000000
CHAR 1085
000000
000000
000000
100010
111110
100010
100010
000000
000000
CHAR 1086
000000
000000
000000
011100
100010
100010
011100
000000
000000
CHAR 1087
000000
000000
000000
111110
100010
100010
100010
000000
000000
CHAR 1088
000000
000000
000000
111100
100010
100010
111100
100000
100000
CHAR 1089
000000
000000
000000
011100
100010
100000
011110
000000
000000
CHAR 1090
000000
000000
000000
111110
001000
001000
001000
000000
000000
CHAR 1091
000000
000000
000000
100010
100010
100010
011110
000010
011100
CHAR 1092
000000
001000
001000
011100
101010
101010
011100
001000
001000
CHAR 1093
000000
000000
000000
010010
001100
001100
010010
000000
000000
CHAR 1094
000000
000000
000000
100100
100100
100100
111110
000010
000100
CHAR 1095
000000
000000
000000
100010
100010
011110
000010
000000
000000
CHAR 1096
000000
000000
000000
101010
101010
101010
111110
000000
000000
CHAR 1097
000000
000000
000000
101010
101010
101010
111110
000010
000100
CHAR 1098
000000
000000
000000
110000
011100
010010
011100
000000
000000
CHAR 1099
000000
000000
000000
100010
111010
100110
111010
000000
000000
CHAR 1100
000000
000000
000000
010000
011100
010010
011100
000000
000000
CHAR 1101
000000
000000
000000
111000
010100
001100
111000
000000
000000
CHAR 1102
000000
000000
000000
100100
111010
111010
100100
000000
000000
CHAR 1103
000000
000000
000000
011100
100100
011100
100100
000000
000000
CHAR 1104
001000
000100
000000
001100
010010
011100
001110
000000
000000
CHAR 1105
000000
010100
000000
001100
010010
011100
001110
000000
000000
CHAR 1106
000000
010000
111000
010000
011100
010010
010010
000010
000100
CHAR 1107
000100
001000
000000
011110
010000
010000
010000
000000
000000
CHAR 1108
000000
000000
000000
001110
010100
011000
001110
000000
000000
CHAR 1109
000000
000000
000000
001110
011000
000110
011100
000000
000000
CHAR 1110
000000
001000
000000
011000
001000
001000
011100
000000
000000
CHAR 1111
000000
010100
000000
011000
001000
001000
011100
000000
000000
CHAR 1112
000000
000010
000000
000110
000010
000010
000010
010010
001100
CHAR 1113
000000
000000
000000
011000
101100
101010
101100
000000
000000
CHAR 1114
000000
000000
000000
101000
111100
101010
101100
000000
000000
CHAR 1115
000000
010000
111000
010000
011100
010010
010010
000000
000000
CHAR 1116
000100
001000
000000
010010
010100
011100
010010
000000
000000
CHAR 1117
010000
001000
000000
100010
100110
101010
110010
000000
000000
CHAR 1118
000000
010010
001100
000000
100010
100010
011110
000010
011100
CHAR 1119
000000
000000
000000
100010
100010
100010
111110
001000
001000
CHAR 1122
010000
111000
010000
011100
010010
010010
011100
000000
000000
CHAR 1123
000000
010000
010000
111000
011100
010010
011100
000000
000000
CHAR 1136
000000
101010
101010
101010
011100
001000
001000
000000
000000
CHAR 1137
000000
000000
000000
101010
101010
011100
001000
000000
000000
CHAR 1138
000000
011100
100010
111110
100010
100010
011100
000000
000000
CHAR 1139
000000
000000
000000
011100
101010
110110
011100
000000
000000
CHAR 1140
000000
010000
010010
010110
011100
001000
001000
000000
000000
CHAR 1141
000000
000000
000000
010000
010110
001100
001000
000000
000000
CHAR 1168
000010
011110
010000
010000
010000
010000
010000
000000
000000
CHAR 1169
000000
000000
000010
011110
010000
010000
010000
000000
000000
CHAR 1170
000000
011110
010000
111100
010000
010000
010000
000000
000000
CHAR 1171
000000
000000
000000
011110
010000
111000
010000
000000
000000
CHAR 1174
000000
101010
101010
011100
101010
101010
101011
000001
000001
CHAR 1175
000000
000000
000000
101010
011100
011100
101010
000001
000001
CHAR 1178
000000
010010
010100
011000
010100
010010
010010
000001
000001
CHAR 1179
000000
000000
000000
010010
010100
011100
010010
000001
000001
CHAR 1198
000000
100010
100010
010100
001000
001000
001000
000000
000000
CHAR 1199
000000
000000
000000
100010
100010
010100
001000
001000
001000
CHAR 1200
000000
100010
100010
010100
111110
001000
001000
000000
000000
CHAR 1201
000000
000000
000000
100010
100010
010100
111110
001000
001000
CHAR 1202
000000
100010
010100
001000
001000
010100
100010
000001
000001
CHAR 1203
000000
000000
000000
010010
001100
001100
010010
000001
000001
CHAR 1210
000000
100000
100000
111100
100010
100010
100010
000000
000000
CHAR 1211
000000
010000
010000
011100
010010
010010
010010
000000
000000
CHAR 1240
000000
001100
010010
000010
011110
010010
001100
000000
000000
CHAR 1241
000000
000000
000000
011100
000110
011010
001100
000000
000000
CHAR 1250
011100
000000
011100
001000
001000
001000
011100
000000
000000
CHAR 1251
000000
011100
000000
011000
001000
001000
011100
000000
000000
CHAR 1256
000000
011100
100010
111110
100010
100010
011100
000000
000000
CHAR 1257
000000
000000
000000
001100
011110
010010
001100
000000
000000
CHAR 1262
011110
000000
010010
010010
010010
010010
001100
000000
000000
CHAR 1263
000000
011110
000000
010010
010010
010010
001110
000000
000000
CHAR 1488
000000
000000
000000
100100
010010
101100
100010
000000
000000
CHAR 1489
000000
000000
000000
111100
000100
000100
111110
000000
000000
CHAR 1490
000000
000000
000000
010000
001000
001100
010100
000000
000000
CHAR 1491
000000
000000
000000
111110
000100
000100
000100
000000
000000
CHAR 1492
000000
000000
000000
111110
000010
100010
100010
000000
000000
CHAR 1493
000000
000000
000000
001100
000100
000100
000100
000000
000000
CHAR 1494
000000
000000
000000
111110
001000
000100
000100
000000
000000
CHAR 1495
000000
000000
000000
111110
010010
010010
010010
000000
000000
CHAR 1496
000000
000000
000000
100110
101010
100010
111110
000000
000000
CHAR 1497
000000
000000
000000
001100
000100
000000
000000
000000
000000
CHAR 1498
000000
000000
000000
111110
000010
000010
000010
000010
000010
CHAR 1499
000000
000000
000000
111110
000010
000010
111100
000000
000000
CHAR 1500
000000
100000
100000
111110
000010
000100
011000
000000
000000
CHAR 1501
000000
000000
000000
111110
010010
010010
011110
000000
000000
CHAR 1502
000000
000000
000000
100100
101010
010010
100110
000000
000000
CHAR 1503
000000
000000
000000
001100
000100
000100
000100
000100
000100
CHAR 1504
000000
000000
000000
000110
000010
000010
011110
000000
000000
CHAR 1505
000000
000000
000000
011110
001010
001010
001100
000000
000000
CHAR 1506
000000
000000
000000
110110
010010
010100
111000
000000
000000
CHAR 1507
000000
000000
000000
111110
010010
010010
000010
000010
000010
CHAR 1508
000000
000000
000000
111110
010010
000010
111100
000000
000000
CHAR 1509
000000
000000
000000
100100
010010
010100
011000
010000
010000
CHAR 1510
000000
000000
000000
100100
010010
001100
111110
000000
000000
CHAR 1511
000000
000000
000000
111110
000010
100010
101100
100000
100000
CHAR 1512
000000
000000
000000
111100
000010
000010
000010
000000
000000
CHAR 1513
000000
000000
000000
101010
111010
100010
111100
000000
000000
CHAR 1514
000000
000000
000000
111110
010010
010010
110010
000000
000000
CHAR 1520
000000
000000
000000
110110
010010
010010
010010
000000
000000
CHAR 1521
000000
000000
000000
110110
010010
000010
000010
000000
000000
CHAR 1522
000000
000000
000000
110110
010010
000000
000000
000000
000000
CHAR 1523
000000
000000
000000
000100
001000
000000
000000
000000
000000
CHAR 1524
000000
000000
000000
010010
100100
000000
000000
000000
000000
CHAR 7682
001000
000000
111100
100010
111100
100010
111100
000000
000000
CHAR 7683
000100
010000
010000
011100
010010
010010
011100
000000
000000
CHAR 7690
001000
000000
011100
010010
010010
010010
011100
000000
000000
CHAR 7691
001000
000010
000010
001110
010010
010010
001110
000000
000000
CHAR 7710
001000
000000
011110
010000
011100
010000
010000
000000
000000
CHAR 7711
001000
000000
000100
001010
011100
001000
001000
000000
000000
CHAR 7744
001000
100010
110110
101010
101010
100010
100010
000000
000000
CHAR 7745
000000
001000
000000
110100
101010
101010
100010
000000
000000
CHAR 7766
001000
000000
011100
010010
011100
010000
010000
000000
000000
CHAR 7767
000000
001000
000000
011100
010010
010010
011100
010000
010000
CHAR 7776
000100
000000
001110
010000
001100
000010
011100
000000
000000
CHAR 7777
000000
000100
000000
001110
011000
000110
011100
000000
000000
CHAR 7786
001000
000000
111110
001000
001000
001000
001000
000000
000000
CHAR 7787
001000
000000
001000
011100
001000
001010
000100
000000
000000
CHAR 7808
010000
001000
100010
100010
101010
110110
100010
000000
000000
CHAR 7809
010000
001000
000000
100010
101010
101010
010100
000000
000000
CHAR 7810
000100
001000
100010
100010
101010
110110
100010
000000
000000
CHAR 7811
000100
001000
000000
100010
101010
101010
010100
000000
000000
CHAR 7812
010100
000000
100010
100010
101010
110110
100010
000000
000000
CHAR 7813
000000
010100
000000
100010
101010
101010
010100
000000
000000
CHAR 7922
010000
001000
100010
010100
001000
001000
001000
000000
000000
CHAR 7923
001000
000100
000000
010010
010010
010010
001110
010010
001100
CHAR 8208
000000
000000
000000
000000
011110
000000
000000
000000
000000
CHAR 8209
000000
000000
000000
000000
011110
000000
000000
000000
000000
CHAR 8210
000000
000000
000000
000000
111110
000000
000000
000000
000000
CHAR 8211
000000
000000
000000
000000
111110
000000
000000
000000
000000
CHAR 8212
000000
000000
000000
000000
111111
000000
000000
000000
000000
CHAR 8213
000000
000000
000000
000000
111111
000000
000000
000000
000000
CHAR 8214
000000
010100
010100
010100
010100
010100
010100
000000
000000
CHAR 8215
000000
000000
000000
000000
000000
000000
111111
000000
111111
CHAR 8216
000000
000100
001000
001100
000000
000000
000000
000000
000000
CHAR 8217
000000
001100
000100
001000
000000
000000
000000
000000
000000
CHAR 8218
000000
000000
000000
000000
000000
000000
001100
000100
001000
CHAR 8219
000000
001100
001000
000100
000000
000000
000000
000000
000000
CHAR 8220
000000
010010
100100
110110
000000
000000
000000
000000
000000
CHAR 8221
000000
110110
010010
100100
000000
000000
000000
000000
000000
CHAR 8222
000000
000000
000000
000000
000000
000000
110110
010010
100100
CHAR 8223
000000
110110
100100
010010
000000
000000
000000
000000
000000
CHAR 8224
000000
001000
001000
111110
001000
001000
001000
001000
000000
CHAR 8225
000000
001000
001000
111110
001000
111110
001000
001000
000000
CHAR 8226
000000
000000
001100
011110
011110
001100
000000
000000
000000
CHAR 8227
000000
000000
010000
011000
011100
011000
010000
000000
000000
CHAR 8228
000000
000000
000000
000000
000000
000000
001000
000000
000000
CHAR 8229
000000
000000
000000
000000
000000
000000
010100
000000
000000
CHAR 8230
000000
000000
000000
000000
000000
000000
101010
000000
000000
CHAR 8231
000000
000000
000000
000000
001100
000000
000000
000000
000000
CHAR 8240
010000
101010
010010
000100
001000
011010
110101
001010
000000
CHAR 8242
000000
000100
000100
001000
000000
000000
000000
000000
000000
CHAR 8243
000000
010010
010010
100100
000000
000000
000000
000000
000000
CHAR 8244
000000
010101
010101
101010
000000
000000
000000
000000
000000
CHAR 8245
000000
001000
001000
000100
000000
000000
000000
000000
000000
CHAR 8246
000000
100100
100100
010010
000000
000000
000000
000000
000000
CHAR 8247
000000
101010
101010
010101
000000
000000
000000
000000
000000
CHAR 8249
000000
000000
000100
001000
010000
001000
000100
000000
000000
CHAR 8250
000000
000000
010000
001000
000100
001000
010000
000000
000000
CHAR 8252
000000
010100
010100
010100
010100
000000
010100
000000
000000
CHAR 8254
000000
111111
000000
000000
000000
000000
000000
000000
000000
CHAR 8260
000000
000010
000010
000100
001000
010000
010000
000000
000000
CHAR 8304
000000
001000
010100
010100
010100
001000
000000
000000
000000
CHAR 8305
000000
001000
000000
011000
001000
011100
000000
000000
000000
CHAR 8308
000000
010100
010100
011100
000100
000100
000000
000000
000000
CHAR 8309
000000
011100
010000
011000
000100
011000
000000
000000
000000
CHAR 8310
000000
001000
010000
011000
010100
001000
000000
000000
000000
CHAR 8311
000000
011100
000100
001000
001000
001000
000000
000000
000000
CHAR 8312
000000
001000
010100
001000
010100
001000
000000
000000
000000
CHAR 8313
000000
001000
010100
001100
000100
001000
000000
000000
000000
CHAR 8314
000000
000000
000000
001000
011100
001000
000000
000000
000000
CHAR 8315
000000
000000
000000
000000
011100
000000
000000
000000
000000
CHAR 8316
000000
000000
000000
011100
000000
011100
000000
000000
000000
CHAR 8317
000000
001000
010000
010000
010000
001000
000000
000000
000000
CHAR 8318
000000
001000
000100
000100
000100
001000
000000
000000
000000
CHAR 8319
000000
000000
011000
010100
010100
010100
000000
000000
000000
CHAR 8320
000000
000000
000000
000000
001000
010100
010100
010100
001000
CHAR 8321
000000
000000
000000
000000
001000
011000
001000
001000
011100
CHAR 8322
000000
000000
000000
000000
001000
010100
000100
001000
011100
CHAR 8323
000000
000000
000000
000000
011000
000100
001000
000100
011000
CHAR 8324
000000
000000
000000
000000
010100
010100
011100
000100
000100
CHAR 8325
000000
000000
000000
000000
011100
010000
011000
000100
011000
CHAR 8326
000000
000000
000000
000000
001000
010000
011000
010100
001000
CHAR 8327
000000
000000
000000
000000
011100
000100
001000
001000
001000
CHAR 8328
000000
000000
000000
000000
001000
010100
001000
010100
001000
CHAR 8329
000000
000000
000000
000000
001000
010100
001100
000100
001000
CHAR 8330
000000
000000
000000
000000
000000
000000
001000
011100
001000
CHAR 8331
000000
000000
000000
000000
000000
000000
000000
011100
000000
CHAR 8332
000000
000000
000000
000000
000000
000000
011100
000000
011100
CHAR 8333
000000
000000
000000
000000
001000
010000
010000
010000
001000
CHAR 8334
000000
000000
000000
000000
001000
000100
000100
000100
001000
CHAR 8355
000000
111110
100000
111010
101100
101000
101000
000000
000000
CHAR 8356
000000
001100
010010
111000
010000
111000
010000
111110
000000
CHAR 8359
000000
011000
010100
111110
010100
011000
010000
000000
000000
CHAR 8363
000000
000010
000111
001110
010010
010010
001110
000000
011110
CHAR 8364
000000
001110
010000
111100
111100
010000
001110
000000
000000
CHAR 8367
010000
111000
010100
010010
010010
111010
110100
000000
000000
CHAR 8400
010000
111110
000000
000000
000000
000000
000000
000000
000000
CHAR 8401
000100
111110
000000
000000
000000
000000
000000
000000
000000
CHAR 8402
001000
001000
001000
001000
001000
001000
001000
001000
001000
CHAR 8403
000000
000000
001000
001000
001000
001000
001000
001000
000000
CHAR 8404
101100
110010
111000
000000
000000
000000
000000
000000
000000
CHAR 8405
011010
100110
001110
000000
000000
000000
000000
000000
000000
CHAR 8406
010000
111110
010000
000000
000000
000000
000000
000000
000000
CHAR 8407
000100
111110
000100
000000
000000
000000
000000
000000
000000
CHAR 8450
000000
011100
101010
101000
101000
101010
011100
000000
000000
CHAR 8453
000000
010000
100000
010000
000100
001010
000100
000000
000000
CHAR 8467
000000
000100
001010
001010
001100
001000
010110
000000
000000
CHAR 8469
000000
110010
111010
111010
110110
110110
110010
000000
000000
CHAR 8470
000000
100100
110100
110100
101110
101101
100110
000000
000000
CHAR 8474
000000
011100
101010
101010
101010
101010
011100
000110
000000
CHAR 8477
000000
111100
101010
101010
101100
101010
101010
000000
000000
CHAR 8482
000000
111111
010111
010101
000000
000000
000000
000000
000000
CHAR 8484
000000
111110
001010
010100
010100
101000
111110
000000
000000
CHAR 8486
000000
011100
100010
100010
100010
010100
110110
000000
000000
CHAR 8494
000000
000000
011100
110110
111110
110000
011100
000000
000000
CHAR 8539
010000
110000
010000
010100
011010
000100
001010
000100
000000
CHAR 8540
110000
001000
010000
001100
111010
000100
001010
000100
000000
CHAR 8541
111000
100000
110000
001100
111010
000100
001010
000100
000000
CHAR 8542
111000
001000
010000
010100
011010
000100
001010
000100
000000
CHAR 8592
000000
000000
001000
010000
111110
010000
001000
000000
000000
CHAR 8593
000000
001000
011100
101010
001000
001000
001000
000000
000000
CHAR 8594
000000
000000
001000
000100
111110
000100
001000
000000
000000
CHAR 8595
000000
001000
001000
001000
101010
011100
001000
000000
000000
CHAR 8596
000000
000000
000000
010010
111111
010010
000000
000000
000000
CHAR 8597
000000
001000
011100
101010
001000
101010
011100
001000
000000
CHAR 8612
000000
000000
001000
010010
111110
010010
001000
000000
000000
CHAR 8613
000000
001000
011100
101010
001000
001000
011100
000000
000000
CHAR 8614
000000
000000
001000
100100
111110
100100
001000
000000
000000
CHAR 8615
000000
011100
001000
001000
101010
011100
001000
000000
000000
CHAR 8616
001000
011100
101010
001000
101010
011100
001000
111110
000000
CHAR 8656
000000
000000
001000
011110
100000
011110
001000
000000
000000
CHAR 8657
000000
001000
010100
110110
010100
010100
010100
000000
000000
CHAR 8658
000000
000000
001000
111100
000010
111100
001000
000000
000000
CHAR 8659
000000
010100
010100
010100
110110
011100
001000
000000
000000
CHAR 8660
000000
000000
001100
011110
100001
011110
001100
000000
000000
CHAR 8661
000000
001000
011100
110110
010100
110110
011100
001000
000000
CHAR 8704
000000
100010
100010
111110
100010
010100
001000
000000
000000
CHAR 8705
000000
001000
010100
010000
010000
010000
010100
001000
000000
CHAR 8706
000000
001100
000010
001110
010010
010010
001100
000000
000000
CHAR 8707
000000
011110
000010
001110
000010
000010
011110
000000
000000
CHAR 8708
001000
011110
001010
001110
001010
001010
011110
001000
000000
CHAR 8709
000000
011110
100110
101010
101010
110010
111100
000000
000000
CHAR 8710
000000
001000
001000
010100
010100
100010
111110
000000
000000
CHAR 8711
000000
111110
100010
010100
010100
001000
001000
000000
000000
CHAR 8712
000000
000000
001110
010000
011110
010000
001110
000000
000000
CHAR 8713
000000
000100
001110
010100
011110
010100
001110
000100
000000
CHAR 8715
000000
000000
011100
000010
011110
000010
011100
000000
000000
CHAR 8716
000000
001000
011100
001010
011110
001010
011100
001000
000000
CHAR 8719
111110
010100
010100
010100
010100
010100
010100
010100
000000
CHAR 8720
010100
010100
010100
010100
010100
010100
010100
111110
000000
CHAR 8721
000000
111110
010000
001000
001000
010000
111110
000000
000000
CHAR 8722
000000
000000
000000
000000
111110
000000
000000
000000
000000
CHAR 8723
000000
111110
000000
001000
001000
111110
001000
001000
000000
CHAR 8725
000000
000010
000010
000100
001000
010000
010000
000000
000000
CHAR 8728
000000
000000
000000
001000
010100
001000
000000
000000
000000
CHAR 8729
000000
000000
000000
001000
011100
001000
000000
000000
000000
CHAR 8730
000011
000010
000010
000010
000100
110100
001100
001100
000100
CHAR 8733
000000
000000
001010
010100
010100
001010
000000
000000
000000
CHAR 8734
000000
000000
010100
101010
101010
010100
000000
000000
000000
CHAR 8735
000000
000000
100000
100000
100000
100000
111110
000000
000000
CHAR 8737
000000
000000
010100
001000
010100
100100
111110
000100
000000
CHAR 8740
000000
001000
001000
001100
011000
001000
001000
000000
000000
CHAR 8741
000000
010100
010100
010100
010100
010100
010100
000000
000000
CHAR 8742
000000
010100
010110
011100
110100
010100
010100
000000
000000
CHAR 8743
000000
000000
000000
001000
010100
010100
100010
000000
000000
CHAR 8744
000000
000000
000000
100010
010100
010100
001000
000000
000000
CHAR 8745
000000
000000
000000
011100
100010
100010
100010
000000
000000
CHAR 8746
000000
000000
000000
100010
100010
100010
011100
000000
000000
CHAR 8747
000100
001010
001000
001000
001000
001000
001000
101000
010000
CHAR 8750
000100
001010
001000
011100
101010
011100
001000
101000
010000
CHAR 8756
000000
000000
001000
000000
000000
100010
000000
000000
000000
CHAR 8757
000000
000000
100010
000000
000000
001000
000000
000000
000000
CHAR 8758
000000
000000
001000
000000
000000
001000
000000
000000
000000
CHAR 8759
000000
000000
010010
000000
000000
010010
000000
000000
000000
CHAR 8760
000000
000000
001000
000000
111110
000000
000000
000000
000000
CHAR 8761
000000
000000
000010
000000
111000
000000
000010
000000
000000
CHAR 8762
000000
000000
100010
000000
111110
000000
100010
000000
000000
CHAR 8763
000000
000000
000100
000000
001010
010100
000000
001000
000000
CHAR 8764
000000
000000
000000
000000
001010
010100
000000
000000
000000
CHAR 8765
000000
000000
000000
000000
010100
001010
000000
000000
000000
CHAR 8771
000000
000000
000000
001010
010100
000000
011110
000000
000000
CHAR 8773
000000
000000
001010
010100
000000
011110
000000
011110
000000
CHAR 8776
000000
000000
010000
101010
010100
101010
000100
000000
000000
CHAR 8777
000000
000100
010100
101010
011100
101010
010100
010000
000000
CHAR 8793
001000
010100
000000
111110
000000
111110
000000
000000
000000
CHAR 8799
011000
000100
001000
000000
001000
000000
111110
000000
111110
CHAR 8800
000000
000000
000100
111110
001000
111110
010000
000000
000000
CHAR 8801
000000
000000
111110
000000
111110
000000
111110
000000
000000
CHAR 8802
000000
000100
111110
001000
111110
001000
111110
010000
000000
CHAR 8803
000000
111110
000000
111110
000000
111110
000000
111110
000000
CHAR 8804
000000
000110
011000
100000
011000
100110
011000
000110
000000
CHAR 8805
000000
110000
001100
000010
001100
110010
001100
110000
000000
CHAR 8810
000000
000000
001010
010100
101000
010100
001010
000000
000000
CHAR 8811
000000
000000
101000
010100
001010
010100
101000
000000
000000
CHAR 8834
000000
000000
001110
010000
010000
001110
000000
000000
000000
CHAR 8835
000000
000000
011100
000010
000010
011100
000000
000000
000000
CHAR 8836
000000
000100
001110
010100
010100
001110
000100
000000
000000
CHAR 8837
000000
001000
011100
001010
001010
011100
001000
000000
000000
CHAR 8838
000000
001110
010000
010000
001110
000000
011110
000000
000000
CHAR 8839
000000
011100
000010
000010
011100
000000
011110
000000
000000
CHAR 8840
000100
001110
010100
010100
001110
000100
011110
000100
000000
CHAR 8841
001000
011100
001010
001010
011100
001000
011110
001000
000000
CHAR 8842
000000
001110
010000
010000
001110
000100
011110
001000
000000
CHAR 8843
000000
011100
000010
000010
011100
000100
011110
001000
000000
CHAR 8853
000000
000000
011100
101010
111110
101010
011100
000000
000000
CHAR 8854
000000
000000
011100
100010
111110
100010
011100
000000
000000
CHAR 8855
000000
000000
011100
110110
101010
110110
011100
000000
000000
CHAR 8856
000000
000000
011100
100110
101010
110010
011100
000000
000000
CHAR 8857
000000
000000
011100
100010
101010
100010
011100
000000
000000
CHAR 8866
000000
000000
100000
100000
111110
100000
100000
000000
000000
CHAR 8867
000000
000000
000010
000010
111110
000010
000010
000000
000000
CHAR 8868
000000
111110
001000
001000
001000
001000
001000
000000
000000
CHAR 8869
000000
001000
001000
001000
001000
001000
111110
000000
000000
CHAR 8870
000000
000000
010000
010000
011100
010000
010000
000000
000000
CHAR 8871
000000
000000
010000
011100
010000
011100
010000
000000
000000
CHAR 8872
000000
000000
100000
111110
100000
111110
100000
000000
000000
CHAR 8896
001000
001000
010100
010100
010100
100010
100010
100010
000000
CHAR 8897
100010
100010
100010
010100
010100
010100
001000
001000
000000
CHAR 8898
011100
100010
100010
100010
100010
100010
100010
100010
000000
CHAR 8899
100010
100010
100010
100010
100010
100010
100010
011100
000000
CHAR 8901
000000
000000
000000
000000
001000
000000
000000
000000
000000
CHAR 8942
000000
001000
000000
000000
001000
000000
000000
001000
000000
CHAR 8943
000000
000000
000000
000000
101010
000000
000000
000000
000000
CHAR 8944
000000
000010
000000
000000
001000
000000
000000
100000
000000
CHAR 8945
000000
100000
000000
000000
001000
000000
000000
000010
000000
CHAR 8960
000000
000000
011110
100110
101010
110010
111100
000000
000000
CHAR 8962
000000
001000
010100
100010
100010
100010
111110
000000
000000
CHAR 8968
000000
011100
010000
010000
010000
010000
010000
000000
000000
CHAR 8969
000000
011100
000100
000100
000100
000100
000100
000000
000000
CHAR 8970
000000
010000
010000
010000
010000
010000
011100
000000
000000
CHAR 8971
000000
000100
000100
000100
000100
000100
011100
000000
000000
CHAR 8976
000000
000000
000000
000000
011110
010000
010000
000000
000000
CHAR 8992
000000
000010
000101
000100
000100
000100
000100
000100
000100
CHAR 8993
000100
000100
000100
000100
000100
000100
010100
001000
000000
CHAR 9146
111111
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 9147
000000
000000
111111
000000
000000
000000
000000
000000
000000
CHAR 9148
000000
000000
000000
000000
000000
000000
111111
000000
000000
CHAR 9149
000000
000000
000000
000000
000000
000000
000000
000000
111111
CHAR 9225
000000
101000
111000
101000
000000
001110
000100
000100
000000
CHAR 9226
000000
100000
100000
100000
110000
001110
001000
001100
001000
CHAR 9227
000000
101000
101000
010000
010000
001110
000100
000100
000100
CHAR 9228
000000
111000
100000
110000
100000
001110
001000
001100
001000
CHAR 9229
000000
011000
100000
011000
000000
001100
001010
001100
001010
CHAR 9252
000000
100100
110100
101100
100100
001000
001000
001000
001110
CHAR 9472
000000
000000
000000
000000
111111
000000
000000
000000
000000
CHAR 9473
000000
000000
000000
111111
111111
000000
000000
000000
000000
CHAR 9474
000100
000100
000100
000100
000100
000100
000100
000100
000100
CHAR 9475
001100
001100
001100
001100
001100
001100
001100
001100
001100
CHAR 9484
000000
000000
000000
000000
000111
000100
000100
000100
000100
CHAR 9488
000000
000000
000000
000000
111100
000100
000100
000100
000100
CHAR 9492
000100
000100
000100
000100
000111
000000
000000
000000
000000
CHAR 9496
000100
000100
000100
000100
111100
000000
000000
000000
000000
CHAR 9500
000100
000100
000100
000100
000111
000100
000100
000100
000100
CHAR 9508
000100
000100
000100
000100
111100
000100
000100
000100
000100
CHAR 9516
000000
000000
000000
000000
111111
000100
000100
000100
000100
CHAR 9524
000100
000100
000100
000100
111111
000000
000000
000000
000000
CHAR 9532
000100
000100
000100
000100
111111
000100
000100
000100
000100
CHAR 9548
000000
000000
000000
000000
110110
000000
000000
000000
000000
CHAR 9549
000000
000000
000000
110110
110110
000000
000000
000000
000000
CHAR 9550
000100
000100
000100
000100
000000
000100
000100
000100
000000
CHAR 9551
001100
001100
001100
001100
000000
001100
001100
001100
000000
CHAR 9552
000000
000000
000000
111111
000000
111111
000000
000000
000000
CHAR 9553
001010
001010
001010
001010
001010
001010
001010
001010
001010
CHAR 9554
000000
000000
000000
000111
000100
000111
000100
000100
000100
CHAR 9555
000000
000000
000000
000000
001111
001010
001010
001010
001010
CHAR 9556
000000
000000
000000
001111
001000
001011
001010
001010
001010
CHAR 9557
000000
000000
000000
111100
000100
111100
000100
000100
000100
CHAR 9558
000000
000000
000000
000000
111110
001010
001010
001010
001010
CHAR 9559
000000
000000
000000
111110
000010
111010
001010
001010
001010
CHAR 9560
000100
000100
000100
000111
000100
000111
000000
000000
000000
CHAR 9561
001010
001010
001010
001010
001111
000000
000000
000000
000000
CHAR 9562
001010
001010
001010
001011
001000
001111
000000
000000
000000
CHAR 9563
000100
000100
000100
111100
000100
111100
000000
000000
000000
CHAR 9564
001010
001010
001010
001010
111110
000000
000000
000000
000000
CHAR 9565
001010
001010
001010
111010
000010
111110
000000
000000
000000
CHAR 9566
000100
000100
000100
000111
000100
000111
000100
000100
000100
CHAR 9567
001010
001010
001010
001010
001011
001010
001010
001010
001010
CHAR 9568
001010
001010
001010
001011
001000
001011
001010
001010
001010
CHAR 9569
000100
000100
000100
111100
000100
111100
000100
000100
000100
CHAR 9570
001010
001010
001010
001010
111010
001010
001010
001010
001010
CHAR 9571
001010
001010
001010
111010
000010
111010
001010
001010
001010
CHAR 9572
000000
000000
000000
111111
000000
111111
000100
000100
000100
CHAR 9573
000000
000000
000000
000000
111111
001010
001010
001010
001010
CHAR 9574
000000
000000
000000
111111
000000
111011
001010
001010
001010
CHAR 9575
000100
000100
000100
111111
000000
111111
000000
000000
000000
CHAR 9576
001010
001010
001010
001010
111111
000000
000000
000000
000000
CHAR 9577
001010
001010
001010
111011
000000
111111
000000
000000
000000
CHAR 9578
000100
000100
000100
111111
000100
111111
000100
000100
000100
CHAR 9579
001010
001010
001010
001010
111111
001010
001010
001010
001010
CHAR 9580
001010
001010
001010
111011
000000
111011
001010
001010
001010
CHAR 9581
000000
000000
000000
000000
000001
000010
000100
000100
000100
CHAR 9582
000000
000000
000000
000000
110000
001000
000100
000100
000100
CHAR 9583
000100
000100
000100
001000
110000
000000
000000
000000
000000
CHAR 9584
000100
000100
000100
000010
000001
000000
000000
000000
000000
CHAR 9585
000001
000001
000010
000100
000100
001000
010000
010000
100000
CHAR 9586
100000
100000
010000
001000
001000
000100
000010
000010
000001
CHAR 9587
100001
100001
010010
001100
001100
001100
010010
010010
100001
CHAR 9600
111111
111111
111111
111111
000000
000000
000000
000000
000000
CHAR 9601
000000
000000
000000
000000
000000
000000
000000
000000
111111
CHAR 9602
000000
000000
000000
000000
000000
000000
000000
111111
111111
CHAR 9603
000000
000000
000000
000000
000000
111111
111111
111111
111111
CHAR 9604
000000
000000
000000
000000
111111
111111
111111
111111
111111
CHAR 9605
000000
000000
000000
111111
111111
111111
111111
111111
111111
CHAR 9606
000000
000000
111111
111111
111111
111111
111111
111111
111111
CHAR 9607
000000
111111
111111
111111
111111
111111
111111
111111
111111
CHAR 9608
111111
111111
111111
111111
111111
111111
111111
111111
111111
CHAR 9609
111110
111110
111110
111110
111110
111110
111110
111110
111110
CHAR 9610
111100
111100
111100
111100
111100
111100
111100
111100
111100
CHAR 9611
111100
111100
111100
111100
111100
111100
111100
111100
111100
CHAR 9612
111000
111000
111000
111000
111000
111000
111000
111000
111000
CHAR 9613
110000
110000
110000
110000
110000
110000
110000
110000
110000
CHAR 9614
110000
110000
110000
110000
110000
110000
110000
110000
110000
CHAR 9615
100000
100000
100000
100000
100000
100000
100000
100000
100000
CHAR 9616
000111
000111
000111
000111
000111
000111
000111
000111
000111
CHAR 9617
101010
000000
010101
000000
101010
000000
010101
000000
101010
CHAR 9618
010101
101010
010101
101010
010101
101010
010101
101010
010101
CHAR 9619
111111
101010
111111
010101
111111
101010
111111
010101
111111
CHAR 9620
111111
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 9621
000001
000001
000001
000001
000001
000001
000001
000001
000001
CHAR 9622
000000
000000
000000
000000
111000
111000
111000
111000
111000
CHAR 9623
000000
000000
000000
000000
000111
000111
000111
000111
000111
CHAR 9624
111000
111000
111000
111000
000000
000000
000000
000000
000000
CHAR 9625
111000
111000
111000
111000
111111
111111
111111
111111
111111
CHAR 9626
111000
111000
111000
111000
000111
000111
000111
000111
000111
CHAR 9627
111111
111111
111111
111111
111000
111000
111000
111000
111000
CHAR 9628
111111
111111
111111
111111
000111
000111
000111
000111
000111
CHAR 9629
000111
000111
000111
000111
000000
000000
000000
000000
000000
CHAR 9630
000111
000111
000111
000111
111000
111000
111000
111000
111000
CHAR 9631
000111
000111
000111
000111
111111
111111
111111
111111
111111
CHAR 9632
000000
000000
111110
111110
111110
111110
111110
000000
000000
CHAR 9633
000000
000000
111110
100010
100010
100010
111110
000000
000000
CHAR 9634
000000
000000
011100
100010
100010
100010
011100
000000
000000
CHAR 9635
000000
000000
111110
100010
101010
100010
111110
000000
000000
CHAR 9642
000000
000000
000000
011100
011100
011100
000000
000000
000000
CHAR 9643
000000
000000
000000
011100
010100
011100
000000
000000
000000
CHAR 9644
000000
000000
000000
111110
111110
111110
000000
000000
000000
CHAR 9645
000000
000000
000000
111110
100010
111110
000000
000000
000000
CHAR 9646
000000
011110
011110
011110
011110
011110
011110
000000
000000
CHAR 9647
000000
011110
010010
010010
010010
010010
011110
000000
000000
CHAR 9648
000000
000000
000000
011110
111110
111100
000000
000000
000000
CHAR 9649
000000
000000
000000
011110
100010
111100
000000
000000
000000
CHAR 9650
000000
001000
001000
011100
011100
111110
111110
000000
000000
CHAR 9651
000000
001000
001000
010100
010100
100010
111110
000000
000000
CHAR 9652
000000
000000
001000
001000
011100
011100
000000
000000
000000
CHAR 9653
000000
000000
001000
001000
010100
011100
000000
000000
000000
CHAR 9654
000000
000000
110000
111100
111110
111100
110000
000000
000000
CHAR 9655
000000
000000
110000
101100
100010
101100
110000
000000
000000
CHAR 9656
000000
000000
000000
011000
011110
011000
000000
000000
000000
CHAR 9657
000000
000000
000000
011000
010110
011000
000000
000000
000000
CHAR 9658
000000
000000
000000
111000
111110
111000
000000
000000
000000
CHAR 9659
000000
000000
000000
111000
100110
111000
000000
000000
000000
CHAR 9660
000000
111110
111110
011100
011100
001000
001000
000000
000000
CHAR 9661
000000
111110
100010
010100
010100
001000
001000
000000
000000
CHAR 9662
000000
000000
011100
011100
001000
001000
000000
000000
000000
CHAR 9663
000000
000000
011100
010100
001000
001000
000000
000000
000000
CHAR 9664
000000
000000
000110
011110
111110
011110
000110
000000
000000
CHAR 9665
000000
000000
000110
011010
100010
011010
000110
000000
000000
CHAR 9666
000000
000000
000000
000110
011110
000110
000000
000000
000000
CHAR 9667
000000
000000
000000
000110
011010
000110
000000
000000
000000
CHAR 9668
000000
000000
000000
001110
111110
001110
000000
000000
000000
CHAR 9669
000000
000000
000000
001110
110010
001110
000000
000000
000000
CHAR 9670
000000
000000
001100
011110
111111
011110
001100
000000
000000
CHAR 9674
000000
001000
010100
010100
100010
010100
010100
001000
000000
CHAR 9675
000000
000000
011100
100010
100010
100010
011100
000000
000000
CHAR 9679
000000
000000
011100
111110
111110
111110
011100
000000
000000
CHAR 9688
111111
111111
110011
100001
100001
110011
111111
111111
111111
CHAR 9689
111111
111111
110011
101101
101101
110011
111111
111111
111111
CHAR 9702
000000
000000
001100
010010
010010
001100
000000
000000
000000
CHAR 9728
000000
001000
101010
011100
111110
011100
101010
001000
000000
CHAR 9785
011110
100001
110011
100001
101101
110011
100001
011110
000000
CHAR 9786
011110
100001
110011
100001
110011
101101
100001
011110
000000
CHAR 9787
011110
111111
101101
111111
101101
110011
111111
011110
000000
CHAR 9788
000000
001000
101010
011100
110110
011100
101010
001000
000000
CHAR 9791
100010
011100
100010
100010
011100
001000
111110
001000
000000
CHAR 9792
000000
011100
100010
100010
011100
001000
111110
001000
000000
CHAR 9793
000000
001000
111110
001000
011100
100010
100010
011100
000000
CHAR 9794
000000
000111
000011
000101
011100
100010
100010
011100
000000
CHAR 9824
000000
001000
011100
111110
111110
001000
011100
000000
000000
CHAR 9825
000000
010100
101010
100010
100010
010100
001000
000000
000000
CHAR 9826
000000
000000
001000
010100
100010
010100
001000
000000
000000
CHAR 9827
001000
011100
101010
111110
101010
001000
011100
000000
000000
CHAR 9828
000000
001000
010100
100010
111110
001000
011100
000000
000000
CHAR 9829
000000
010100
111110
111110
111110
011100
001000
000000
000000
CHAR 9830
000000
000000
001000
011100
111110
011100
001000
000000
000000
CHAR 9833
000000
000100
000100
000100
000100
011100
011000
000000
000000
CHAR 9834
000000
001100
001010
001000
001000
111000
110000
000000
000000
CHAR 9835
000000
011000
010110
010010
110010
110110
000110
000000
000000
CHAR 10216
000000
000100
000100
001000
001000
001000
000100
000100
000000
CHAR 10217
000000
001000
001000
000100
000100
000100
001000
001000
000000
CHAR 10240
000000
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 10241
000000
010000
000000
000000
000000
000000
000000
000000
000000
CHAR 10242
000000
000000
000000
010000
000000
000000
000000
000000
000000
CHAR 10243
000000
010000
000000
010000
000000
000000
000000
000000
000000
CHAR 10244
000000
000000
000000
000000
000000
010000
000000
000000
000000
CHAR 10245
000000
010000
000000
000000
000000
010000
000000
000000
000000
CHAR 10246
000000
000000
000000
010000
000000
010000
000000
000000
000000
CHAR 10247
000000
010000
000000
010000
000000
010000
000000
000000
000000
CHAR 10248
000000
000100
000000
000000
000000
000000
000000
000000
000000
CHAR 10249
000000
010100
000000
000000
000000
000000
000000
000000
000000
CHAR 10250
000000
000100
000000
010000
000000
000000
000000
000000
000000
CHAR 10251
000000
010100
000000
010000
000000
000000
000000
000000
000000
CHAR 10252
000000
000100
000000
000000
000000
010000
000000
000000
000000
CHAR 10253
000000
010100
000000
000000
000000
010000
000000
000000
000000
CHAR 10254
000000
000100
000000
010000
000000
010000
000000
000000
000000
CHAR 10255
000000
010100
000000
010000
000000
010000
000000
000000
000000
CHAR 10256
000000
000000
000000
000100
000000
000000
000000
000000
000000
CHAR 10257
000000
010000
000000
000100
000000
000000
000000
000000
000000
CHAR 10258
000000
000000
000000
010100
000000
000000
000000
000000
000000
CHAR 10259
000000
010000
000000
010100
000000
000000
000000
000000
000000
CHAR 10260
000000
000000
000000
000100
000000
010000
000000
000000
000000
CHAR 10261
000000
010000
000000
000100
000000
010000
000000
000000
000000
CHAR 10262
000000
000000
000000
010100
000000
010000
000000
000000
000000
CHAR 10263
000000
010000
000000
010100
000000
010000
000000
000000
000000
CHAR 10264
000000
000100
000000
000100
000000
000000
000000
000000
000000
CHAR 10265
000000
010100
000000
000100
000000
000000
000000
000000
000000
CHAR 10266
000000
000100
000000
010100
000000
000000
000000
000000
000000
CHAR 10267
000000
010100
000000
010100
000000
000000
000000
000000
000000
CHAR 10268
000000
000100
000000
000100
000000
010000
000000
000000
000000
CHAR 10269
000000
010100
000000
000100
000000
010000
000000
000000
000000
CHAR 10270
000000
000100
000000
010100
000000
010000
000000
000000
000000
CHAR 10271
000000
010100
000000
010100
000000
010000
000000
000000
000000
CHAR 10272
000000
000000
000000
000000
000000
000100
000000
000000
000000
CHAR 10273
000000
010000
000000
000000
000000
000100
000000
000000
000000
CHAR 10274
000000
000000
000000
010000
000000
000100
000000
000000
000000
CHAR 10275
000000
010000
000000
010000
000000
000100
000000
000000
000000
CHAR 10276
000000
000000
000000
000000
000000
010100
000000
000000
000000
CHAR 10277
000000
010000
000000
000000
000000
010100
000000
000000
000000
CHAR 10278
000000
000000
000000
010000
000000
010100
000000
000000
000000
CHAR 10279
000000
010000
000000
010000
000000
010100
000000
000000
000000
CHAR 10280
000000
000100
000000
000000
000000
000100
000000
000000
000000
CHAR 10281
000000
010100
000000
000000
000000
000100
000000
000000
000000
CHAR 10282
000000
000100
000000
010000
000000
000100
000000
000000
000000
CHAR 10283
000000
010100
000000
010000
000000
000100
000000
000000
000000
CHAR 10284
000000
000100
000000
000000
000000
010100
000000
000000
000000
CHAR 10285
000000
010100
000000
000000
000000
010100
000000
000000
000000
CHAR 10286
000000
000100
000000
010000
000000
010100
000000
000000
000000
CHAR 10287
000000
010100
000000
010000
000000
010100
000000
000000
000000
CHAR 10288
000000
000000
000000
000100
000000
000100
000000
000000
000000
CHAR 10289
000000
010000
000000
000100
000000
000100
000000
000000
000000
CHAR 10290
000000
000000
000000
010100
000000
000100
000000
000000
000000
CHAR 10291
000000
010000
000000
010100
000000
000100
000000
000000
000000
CHAR 10292
000000
000000
000000
000100
000000
010100
000000
000000
000000
CHAR 10293
000000
010000
000000
000100
000000
010100
000000
000000
000000
CHAR 10294
000000
000000
000000
010100
000000
010100
000000
000000
000000
CHAR 10295
000000
010000
000000
010100
000000
010100
000000
000000
000000
CHAR 10296
000000
000100
000000
000100
000000
000100
000000
000000
000000
CHAR 10297
000000
010100
000000
000100
000000
000100
000000
000000
000000
CHAR 10298
000000
000100
000000
010100
000000
000100
000000
000000
000000
CHAR 10299
000000
010100
000000
010100
000000
000100
000000
000000
000000
CHAR 10300
000000
000100
000000
000100
000000
010100
000000
000000
000000
CHAR 10301
000000
010100
000000
000100
000000
010100
000000
000000
000000
CHAR 10302
000000
000100
000000
010100
000000
010100
000000
000000
000000
CHAR 10303
000000
010100
000000
010100
000000
010100
000000
000000
000000
CHAR 10304
000000
000000
000000
000000
000000
000000
000000
010000
000000
CHAR 10305
000000
010000
000000
000000
000000
000000
000000
010000
000000
CHAR 10306
000000
000000
000000
010000
000000
000000
000000
010000
000000
CHAR 10307
000000
010000
000000
010000
000000
000000
000000
010000
000000
CHAR 10308
000000
000000
000000
000000
000000
010000
000000
010000
000000
CHAR 10309
000000
010000
000000
000000
000000
010000
000000
010000
000000
CHAR 10310
000000
000000
000000
010000
000000
010000
000000
010000
000000
CHAR 10311
000000
010000
000000
010000
000000
010000
000000
010000
000000
CHAR 10312
000000
000100
000000
000000
000000
000000
000000
010000
000000
CHAR 10313
000000
010100
000000
000000
000000
000000
000000
010000
000000
CHAR 10314
000000
000100
000000
010000
000000
000000
000000
010000
000000
CHAR 10315
000000
010100
000000
010000
000000
000000
000000
010000
000000
CHAR 10316
000000
000100
000000
000000
000000
010000
000000
010000
000000
CHAR 10317
000000
010100
000000
000000
000000
010000
000000
010000
000000
CHAR 10318
000000
000100
000000
010000
000000
010000
000000
010000
000000
CHAR 10319
000000
010100
000000
010000
000000
010000
000000
010000
000000
CHAR 10320
000000
000000
000000
000100
000000
000000
000000
010000
000000
CHAR 10321
000000
010000
000000
000100
000000
000000
000000
010000
000000
CHAR 10322
000000
000000
000000
010100
000000
000000
000000
010000
000000
CHAR 10323
000000
010000
000000
010100
000000
000000
000000
010000
000000
CHAR 10324
000000
000000
000000
000100
000000
010000
000000
010000
000000
CHAR 10325
000000
010000
000000
000100
000000
010000
000000
010000
000000
CHAR 10326
000000
000000
000000
010100
000000
010000
000000
010000
000000
CHAR 10327
000000
010000
000000
010100
000000
010000
000000
010000
000000
CHAR 10328
000000
000100
000000
000100
000000
000000
000000
010000
000000
CHAR 10329
000000
010100
000000
000100
000000
000000
000000
010000
000000
CHAR 10330
000000
000100
000000
010100
000000
000000
000000
010000
000000
CHAR 10331
000000
010100
000000
010100
000000
000000
000000
010000
000000
CHAR 10332
000000
000100
000000
000100
000000
010000
000000
010000
000000
CHAR 10333
000000
010100
000000
000100
000000
010000
000000
010000
000000
CHAR 10334
000000
000100
000000
010100
000000
010000
000000
010000
000000
CHAR 10335
000000
010100
000000
010100
000000
010000
000000
010000
000000
CHAR 10336
000000
000000
000000
000000
000000
000100
000000
010000
000000
CHAR 10337
000000
010000
000000
000000
000000
000100
000000
010000
000000
CHAR 10338
000000
000000
000000
010000
000000
000100
000000
010000
000000
CHAR 10339
000000
010000
000000
010000
000000
000100
000000
010000
000000
CHAR 10340
000000
000000
000000
000000
000000
010100
000000
010000
000000
CHAR 10341
000000
010000
000000
000000
000000
010100
000000
010000
000000
CHAR 10342
000000
000000
000000
010000
000000
010100
000000
010000
000000
CHAR 10343
000000
010000
000000
010000
000000
010100
000000
010000
000000
CHAR 10344
000000
000100
000000
000000
000000
000100
000000
010000
000000
CHAR 10345
000000
010100
000000
000000
000000
000100
000000
010000
000000
CHAR 10346
000000
000100
000000
010000
000000
000100
000000
010000
000000
CHAR 10347
000000
010100
000000
010000
000000
000100
000000
010000
000000
CHAR 10348
000000
000100
000000
000000
000000
010100
000000
010000
000000
CHAR 10349
000000
010100
000000
000000
000000
010100
000000
010000
000000
CHAR 10350
000000
000100
000000
010000
000000
010100
000000
010000
000000
CHAR 10351
000000
010100
000000
010000
000000
010100
000000
010000
000000
CHAR 10352
000000
000000
000000
000100
000000
000100
000000
010000
000000
CHAR 10353
000000
010000
000000
000100
000000
000100
000000
010000
000000
CHAR 10354
000000
000000
000000
010100
000000
000100
000000
010000
000000
CHAR 10355
000000
010000
000000
010100
000000
000100
000000
010000
000000
CHAR 10356
000000
000000
000000
000100
000000
010100
000000
010000
000000
CHAR 10357
000000
010000
000000
000100
000000
010100
000000
010000
000000
CHAR 10358
000000
000000
000000
010100
000000
010100
000000
010000
000000
CHAR 10359
000000
010000
000000
010100
000000
010100
000000
010000
000000
CHAR 10360
000000
000100
000000
000100
000000
000100
000000
010000
000000
CHAR 10361
000000
010100
000000
000100
000000
000100
000000
010000
000000
CHAR 10362
000000
000100
000000
010100
000000
000100
000000
010000
000000
CHAR 10363
000000
010100
000000
010100
000000
000100
000000
010000
000000
CHAR 10364
000000
000100
000000
000100
000000
010100
000000
010000
000000
CHAR 10365
000000
010100
000000
000100
000000
010100
000000
010000
000000
CHAR 10366
000000
000100
000000
010100
000000
010100
000000
010000
000000
CHAR 10367
000000
010100
000000
010100
000000
010100
000000
010000
000000
CHAR 10368
000000
000000
000000
000000
000000
000000
000000
000100
000000
CHAR 10369
000000
010000
000000
000000
000000
000000
000000
000100
000000
CHAR 10370
000000
000000
000000
010000
000000
000000
000000
000100
000000
CHAR 10371
000000
010000
000000
010000
000000
000000
000000
000100
000000
CHAR 10372
000000
000000
000000
000000
000000
010000
000000
000100
000000
CHAR 10373
000000
010000
000000
000000
000000
010000
000000
000100
000000
CHAR 10374
000000
000000
000000
010000
000000
010000
000000
000100
000000
CHAR 10375
000000
010000
000000
010000
000000
010000
000000
000100
000000
CHAR 10376
000000
000100
000000
000000
000000
000000
000000
000100
000000
CHAR 10377
000000
010100
000000
000000
000000
000000
000000
000100
000000
CHAR 10378
000000
000100
000000
010000
000000
000000
000000
000100
000000
CHAR 10379
000000
010100
000000
010000
000000
000000
000000
000100
000000
CHAR 10380
000000
000100
000000
000000
000000
010000
000000
000100
000000
CHAR 10381
000000
010100
000000
000000
000000
010000
000000
000100
000000
CHAR 10382
000000
000100
000000
010000
000000
010000
000000
000100
000000
CHAR 10383
000000
010100
000000
010000
000000
010000
000000
000100
000000
CHAR 10384
000000
000000
000000
000100
000000
000000
000000
000100
000000
CHAR 10385
000000
010000
000000
000100
000000
000000
000000
000100
000000
CHAR 10386
000000
000000
000000
010100
000000
000000
000000
000100
000000
CHAR 10387
000000
010000
000000
010100
000000
000000
000000
000100
000000
CHAR 10388
000000
000000
000000
000100
000000
010000
000000
000100
000000
CHAR 10389
000000
010000
000000
000100
000000
010000
000000
000100
000000
CHAR 10390
000000
000000
000000
010100
000000
010000
000000
000100
000000
CHAR 10391
000000
010000
000000
010100
000000
010000
000000
000100
000000
CHAR 10392
000000
000100
000000
000100
000000
000000
000000
000100
000000
CHAR 10393
000000
010100
000000
000100
000000
000000
000000
000100
000000
CHAR 10394
000000
000100
000000
010100
000000
000000
000000
000100
000000
CHAR 10395
000000
010100
000000
010100
000000
000000
000000
000100
000000
CHAR 10396
000000
000100
000000
000100
000000
010000
000000
000100
000000
CHAR 10397
000000
010100
000000
000100
000000
010000
000000
000100
000000
CHAR 10398
000000
000100
000000
010100
000000
010000
000000
000100
000000
CHAR 10399
000000
010100
000000
010100
000000
010000
000000
000100
000000
CHAR 10400
000000
000000
000000
000000
000000
000100
000000
000100
000000
CHAR 10401
000000
010000
000000
000000
000000
000100
000000
000100
000000
CHAR 10402
000000
000000
000000
010000
000000
000100
000000
000100
000000
CHAR 10403
000000
010000
000000
010000
000000
000100
000000
000100
000000
CHAR 10404
000000
000000
000000
000000
000000
010100
000000
000100
000000
CHAR 10405
000000
010000
000000
000000
000000
010100
000000
000100
000000
CHAR 10406
000000
000000
000000
010000
000000
010100
000000
000100
000000
CHAR 10407
000000
010000
000000
010000
000000
010100
000000
000100
000000
CHAR 10408
000000
000100
000000
000000
000000
000100
000000
000100
000000
CHAR 10409
000000
010100
000000
000000
000000
000100
000000
000100
000000
CHAR 10410
000000
000100
000000
010000
000000
000100
000000
000100
000000
CHAR 10411
000000
010100
000000
010000
000000
000100
000000
000100
000000
CHAR 10412
000000
000100
000000
000000
000000
010100
000000
000100
000000
CHAR 10413
000000
010100
000000
000000
000000
010100
000000
000100
000000
CHAR 10414
000000
000100
000000
010000
000000
010100
000000
000100
000000
CHAR 10415
000000
010100
000000
010000
000000
010100
000000
000100
000000
CHAR 10416
000000
000000
000000
000100
000000
000100
000000
000100
000000
CHAR 10417
000000
010000
000000
000100
000000
000100
000000
000100
000000
CHAR 10418
000000
000000
000000
010100
000000
000100
000000
000100
000000
CHAR 10419
000000
010000
000000
010100
000000
000100
000000
000100
000000
CHAR 10420
000000
000000
000000
000100
000000
010100
000000
000100
000000
CHAR 10421
000000
010000
000000
000100
000000
010100
000000
000100
000000
CHAR 10422
000000
000000
000000
010100
000000
010100
000000
000100
000000
CHAR 10423
000000
010000
000000
010100
000000
010100
000000
000100
000000
CHAR 10424
000000
000100
000000
000100
000000
000100
000000
000100
000000
CHAR 10425
000000
010100
000000
000100
000000
000100
000000
000100
000000
CHAR 10426
000000
000100
000000
010100
000000
000100
000000
000100
000000
CHAR 10427
000000
010100
000000
010100
000000
000100
000000
000100
000000
CHAR 10428
000000
000100
000000
000100
000000
010100
000000
000100
000000
CHAR 10429
000000
010100
000000
000100
000000
010100
000000
000100
000000
CHAR 10430
000000
000100
000000
010100
000000
010100
000000
000100
000000
CHAR 10431
000000
010100
000000
010100
000000
010100
000000
000100
000000
CHAR 10432
000000
000000
000000
000000
000000
000000
000000
010100
000000
CHAR 10433
000000
010000
000000
000000
000000
000000
000000
010100
000000
CHAR 10434
000000
000000
000000
010000
000000
000000
000000
010100
000000
CHAR 10435
000000
010000
000000
010000
000000
000000
000000
010100
000000
CHAR 10436
000000
000000
000000
000000
000000
010000
000000
010100
000000
CHAR 10437
000000
010000
000000
000000
000000
010000
000000
010100
000000
CHAR 10438
000000
000000
000000
010000
000000
010000
000000
010100
000000
CHAR 10439
000000
010000
000000
010000
000000
010000
000000
010100
000000
CHAR 10440
000000
000100
000000
000000
000000
000000
000000
010100
000000
CHAR 10441
000000
010100
000000
000000
000000
000000
000000
010100
000000
CHAR 10442
000000
000100
000000
010000
000000
000000
000000
010100
000000
CHAR 10443
000000
010100
000000
010000
000000
000000
000000
010100
000000
CHAR 10444
000000
000100
000000
000000
000000
010000
000000
010100
000000
CHAR 10445
000000
010100
000000
000000
000000
010000
000000
010100
000000
CHAR 10446
000000
000100
000000
010000
000000
010000
000000
010100
000000
CHAR 10447
000000
010100
000000
010000
000000
010000
000000
010100
000000
CHAR 10448
000000
000000
000000
000100
000000
000000
000000
010100
000000
CHAR 10449
000000
010000
000000
000100
000000
000000
000000
010100
000000
CHAR 10450
000000
000000
000000
010100
000000
000000
000000
010100
000000
CHAR 10451
000000
010000
000000
010100
000000
000000
000000
010100
000000
CHAR 10452
000000
000000
000000
000100
000000
010000
000000
010100
000000
CHAR 10453
000000
010000
000000
000100
000000
010000
000000
010100
000000
CHAR 10454
000000
000000
000000
010100
000000
010000
000000
010100
000000
CHAR 10455
000000
010000
000000
010100
000000
010000
000000
010100
000000
CHAR 10456
000000
000100
000000
000100
000000
000000
000000
010100
000000
CHAR 10457
000000
010100
000000
000100
000000
000000
000000
010100
000000
CHAR 10458
000000
000100
000000
010100
000000
000000
000000
010100
000000
CHAR 10459
000000
010100
000000
010100
000000
000000
000000
010100
000000
CHAR 10460
000000
000100
000000
000100
000000
010000
000000
010100
000000
CHAR 10461
000000
010100
000000
000100
000000
010000
000000
010100
000000
CHAR 10462
000000
000100
000000
010100
000000
010000
000000
010100
000000
CHAR 10463
000000
010100
000000
010100
000000
010000
000000
010100
000000
CHAR 10464
000000
000000
000000
000000
000000
000100
000000
010100
000000
CHAR 10465
000000
010000
000000
000000
000000
000100
000000
010100
000000
CHAR 10466
000000
000000
000000
010000
000000
000100
000000
010100
000000
CHAR 10467
000000
010000
000000
010000
000000
000100
000000
010100
000000
CHAR 10468
000000
000000
000000
000000
000000
010100
000000
010100
000000
CHAR 10469
000000
010000
000000
000000
000000
010100
000000
010100
000000
CHAR 10470
000000
000000
000000
010000
000000
010100
000000
010100
000000
CHAR 10471
000000
010000
000000
010000
000000
010100
000000
010100
000000
CHAR 10472
000000
000100
000000
000000
000000
000100
000000
010100
000000
CHAR 10473
000000
010100
000000
000000
000000
000100
000000
010100
000000
CHAR 10474
000000
000100
000000
010000
000000
000100
000000
010100
000000
CHAR 10475
000000
010100
000000
010000
000000
000100
000000
010100
000000
CHAR 10476
000000
000100
000000
000000
000000
010100
000000
010100
000000
CHAR 10477
000000
010100
000000
000000
000000
010100
000000
010100
000000
CHAR 10478
000000
000100
000000
010000
000000
010100
000000
010100
000000
CHAR 10479
000000
010100
000000
010000
000000
010100
000000
010100
000000
CHAR 10480
000000
000000
000000
000100
000000
000100
000000
010100
000000
CHAR 10481
000000
010000
000000
000100
000000
000100
000000
010100
000000
CHAR 10482
000000
000000
000000
010100
000000
000100
000000
010100
000000
CHAR 10483
000000
010000
000000
010100
000000
000100
000000
010100
000000
CHAR 10484
000000
000000
000000
000100
000000
010100
000000
010100
000000
CHAR 10485
000000
010000
000000
000100
000000
010100
000000
010100
000000
CHAR 10486
000000
000000
000000
010100
000000
010100
000000
010100
000000
CHAR 10487
000000
010000
000000
010100
000000
010100
000000
010100
000000
CHAR 10488
000000
000100
000000
000100
000000
000100
000000
010100
000000
CHAR 10489
000000
010100
000000
000100
000000
000100
000000
010100
000000
CHAR 10490
000000
000100
000000
010100
000000
000100
000000
010100
000000
CHAR 10491
000000
010100
000000
010100
000000
000100
000000
010100
000000
CHAR 10492
000000
000100
000000
000100
000000
010100
000000
010100
000000
CHAR 10493
000000
010100
000000
000100
000000
010100
000000
010100
000000
CHAR 10494
000000
000100
000000
010100
000000
010100
000000
010100
000000
CHAR 10495
000000
010100
000000
010100
000000
010100
000000
010100
000000
CHAR 64257
000000
000100
001010
001000
011110
001010
001010
000000
000000
CHAR 64258
000000
000110
001010
001010
011110
001010
001010
000000
000000
CHAR 65533
011100
110110
101010
111010
110110
110110
111110
110110
011100
</script>
</script>

<style>
html {
	margin:0px;
	padding:0px;
}

body {
	margin:0px;
	padding:0px;
	overflow:hidden;
	background:#ffffff;
}

#game {
	background:black;
	width:100vw;
	max-width:100vh;
	margin:auto;
	display:block;
}
</style>

<!-- SCRIPTS -->
<script>
function startExportedGame() {
	attachCanvas( document.getElementById("game") );
	load_game( document.getElementById("exportedGameData").text.slice(1) );
}
</script>

<script>
//hex-to-rgb method borrowed from stack overflow
function hexToRgb(hex) {
	// Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
	var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
	hex = hex.replace(shorthandRegex, function(m, r, g, b) {
		return r + r + g + g + b + b;
	});

	var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
	return result ? {
		r: parseInt(result[1], 16),
		g: parseInt(result[2], 16),
		b: parseInt(result[3], 16)
	} : null;
}
function componentToHex(c) {
    var hex = c.toString(16);
    return hex.length == 1 ? "0" + hex : hex;
}
function rgbToHex(r, g, b) {
    return "#" + componentToHex(Math.floor(r)) + componentToHex(Math.floor(g)) + componentToHex(Math.floor(b));
}

function hslToHex(h,s,l) {
    var rgbArr = hslToRgb(h,s,l);
    return rgbToHex( Math.floor(rgbArr[0]), Math.floor(rgbArr[1]), Math.floor(rgbArr[2]) );
}

function hexToHsl(hex) {
    var rgb = hexToRgb(hex);
    return rgbToHsl(rgb.r, rgb.g, rgb.b);
}

// really just a vector distance
function colorDistance(a1,b1,c1,a2,b2,c2) {
    return Math.sqrt( Math.pow(a1 - a2, 2) + Math.pow(b1 - b2, 2) + Math.pow(c1 - c2, 2) );
}

function hexColorDistance(hex1,hex2) {
    var color1 = hexToRgb(hex1);
    var color2 = hexToRgb(hex2);
    return rgbColorDistance(color1.r, color1.g, color1.b, color2.r, color2.g, color2.b);
}


// source : http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
/* accepts parameters
 * h  Object = {h:x, s:y, v:z}
 * OR 
 * h, s, v
*/
function HSVtoRGB(h, s, v) {
    var r, g, b, i, f, p, q, t;
    if (arguments.length === 1) {
        s = h.s, v = h.v, h = h.h;
    }
    i = Math.floor(h * 6);
    f = h * 6 - i;
    p = v * (1 - s);
    q = v * (1 - f * s);
    t = v * (1 - (1 - f) * s);
    switch (i % 6) {
        case 0: r = v, g = t, b = p; break;
        case 1: r = q, g = v, b = p; break;
        case 2: r = p, g = v, b = t; break;
        case 3: r = p, g = q, b = v; break;
        case 4: r = t, g = p, b = v; break;
        case 5: r = v, g = p, b = q; break;
    }
    return {
        r: Math.round(r * 255),
        g: Math.round(g * 255),
        b: Math.round(b * 255)
    };
}

/* accepts parameters
 * r  Object = {r:x, g:y, b:z}
 * OR 
 * r, g, b
*/
function RGBtoHSV(r, g, b) {
    if (arguments.length === 1) {
        g = r.g, b = r.b, r = r.r;
    }
    var max = Math.max(r, g, b), min = Math.min(r, g, b),
        d = max - min,
        h,
        s = (max === 0 ? 0 : d / max),
        v = max / 255;

    switch (max) {
        case min: h = 0; break;
        case r: h = (g - b) + d * (g < b ? 6: 0); h /= 6 * d; break;
        case g: h = (b - r) + d * 2; h /= 6 * d; break;
        case b: h = (r - g) + d * 4; h /= 6 * d; break;
    }

    return {
        h: h,
        s: s,
        v: v
    };
}

// source : https://gist.github.com/mjackson/5311256
/**
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes h, s, and l are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 255].
 *
 * @param   Number  h       The hue
 * @param   Number  s       The saturation
 * @param   Number  l       The lightness
 * @return  Array           The RGB representation
 */
function hslToRgb(h, s, l) {
  var r, g, b;

  if (s == 0) {
    r = g = b = l; // achromatic
  } else {
    function hue2rgb(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    }

    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;

    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }

  return [ Math.floor(r * 255), Math.floor(g * 255), Math.floor(b * 255) ];
}

/**
 * From: http://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion
 *
 * Converts an RGB color value to HSL. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes r, g, and b are contained in the set [0, 255] and
 * returns h, s, and l in the set [0, 1].
 *
 * @param   {number}  r       The red color value
 * @param   {number}  g       The green color value
 * @param   {number}  b       The blue color value
 * @return  {Array}           The HSL representation
 */
function rgbToHsl(r, g, b){
    r /= 255, g /= 255, b /= 255;
    var max = Math.max(r, g, b), min = Math.min(r, g, b);
    var h, s, l = (max + min) / 2;

    if(max == min){
        h = s = 0; // achromatic
    }else{
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch(max){
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }

    return [h, s, l];
}
</script>

<script>
var TransitionManager = function() {
	var transitionStart = null;
	var transitionEnd = null;
	var effectImage = null;

	var isTransitioning = false;
	var transitionTime = 0; // milliseconds
	var frameRate = 8; // cap the FPS
	var prevStep = -1; // used to avoid running post-process effect constantly

	this.BeginTransition = function(startRoom,startX,startY,endRoom,endX,endY,effectName) {
		// console.log("--- START ROOM TRANSITION ---");

		curEffect = effectName;

		var tmpRoom = player().room;
		var tmpX = player().x;
		var tmpY = player().y;

		if (transitionEffects[curEffect].showPlayerStart) {
			player().room = startRoom;
			player().x = startX;
			player().y = startY;
		}
		else {
			player().room = "_transition_none"; // kind of hacky!!
		}

		drawRoom(room[startRoom]);
		var startPalette = getPal( room[startRoom].pal );
		var startImage = new PostProcessImage( ctx.getImageData(0,0,canvas.width,canvas.height) ); // TODO : don't use global ctx?
		transitionStart = new TransitionInfo(startImage, startPalette, startX, startY);

		if (transitionEffects[curEffect].showPlayerEnd) {
			player().room = endRoom;
			player().x = endX;
			player().y = endY;
		}
		else {
			player().room = "_transition_none";
		}

		drawRoom(room[endRoom]);
		var endPalette = getPal( room[endRoom].pal );
		var endImage = new PostProcessImage( ctx.getImageData(0,0,canvas.width,canvas.height) );
		transitionEnd = new TransitionInfo(endImage, endPalette, endX, endY);

		effectImage = new PostProcessImage( ctx.createImageData(canvas.width,canvas.height) );

		isTransitioning = true;
		transitionTime = 0;
		prevStep = -1;

		player().room = tmpRoom;
		player().x = tmpX;
		player().y = tmpY;
	}

	this.UpdateTransition = function(dt) {
		if (!isTransitioning) {
			return;
		}

		transitionTime += dt;

		var transitionDelta = transitionTime / transitionEffects[curEffect].duration;
		var maxStep = Math.floor(frameRate * (transitionEffects[curEffect].duration / 1000));
		var step = Math.floor(transitionDelta * maxStep);

		if (step != prevStep) {
			// console.log("step! " + step + " " + transitionDelta);
			for (var y = 0; y < effectImage.Height; y++) {
				for (var x = 0; x < effectImage.Width; x++) {
					var color = transitionEffects[curEffect].pixelEffectFunc(transitionStart,transitionEnd,x,y,(step / maxStep));
					effectImage.SetPixel(x,y,color);
				}
			}
		}
		prevStep = step;

		ctx.putImageData(effectImage.GetData(), 0, 0);

		if (transitionTime >= transitionEffects[curEffect].duration) {
			isTransitioning = false;
			transitionTime = 0;
			transitionStart = null;
			transitionEnd = null;
			effectImage = null;
			prevStep = -1;

			if (transitionCompleteCallback != null) {
				transitionCompleteCallback();
			}
			transitionCompleteCallback = null;
		}
	}

	this.IsTransitionActive = function() {
		return isTransitioning;
	}

	// todo : should this be part of the constructor?
	var transitionCompleteCallback = null;
	this.OnTransitionComplete = function(callback) {
		if (isTransitioning) { // TODO : safety check necessary?
			transitionCompleteCallback = callback;
		}
	}

	var transitionEffects = {};
	var curEffect = "none";
	this.RegisterTransitionEffect = function(name, effect) {
		transitionEffects[name] = effect;
	}

	this.RegisterTransitionEffect("none", {
		showPlayerStart : false,
		showPlayerEnd : false,
		pixelEffectFunc : function() {},
	});

	this.RegisterTransitionEffect("fade_w", { // TODO : have it linger on full white briefly?
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 750,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var pixelColorA = delta < 0.5 ? start.Image.GetPixel(pixelX,pixelY) : {r:255,g:255,b:255,a:255};
			var pixelColorB = delta < 0.5 ? {r:255,g:255,b:255,a:255} : end.Image.GetPixel(pixelX,pixelY);

			delta = delta < 0.5 ? (delta / 0.5) : ((delta - 0.5) / 0.5); // hacky

			return PostProcessUtilities.LerpColor(pixelColorA, pixelColorB, delta);
		}
	});

	this.RegisterTransitionEffect("fade_b", {
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 750,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var pixelColorA = delta < 0.5 ? start.Image.GetPixel(pixelX,pixelY) : {r:0,g:0,b:0,a:255};
			var pixelColorB = delta < 0.5 ? {r:0,g:0,b:0,a:255} : end.Image.GetPixel(pixelX,pixelY);

			delta = delta < 0.5 ? (delta / 0.5) : ((delta - 0.5) / 0.5); // hacky

			return PostProcessUtilities.LerpColor(pixelColorA, pixelColorB, delta);
		}
	});

	this.RegisterTransitionEffect("wave", {
		showPlayerStart : true,
		showPlayerEnd : true,
		duration : 1500,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var waveDelta = delta < 0.5 ? delta / 0.5 : 1 - ((delta - 0.5) / 0.5);

			var offset = (pixelY + (waveDelta * waveDelta * 0.2 * start.Image.Height));
			var freq = 4;
			var size = 2 + (14 * waveDelta);
			pixelX += Math.floor(Math.sin(offset / freq) * size);

			if (pixelX < 0) {
				pixelX += start.Image.Width;
			}
			else if (pixelX >= start.Image.Width) {
				pixelX -= start.Image.Width;
			}

			var curImage = delta < 0.5 ? start.Image : end.Image;
			return curImage.GetPixel(pixelX,pixelY);
		}
	});

	this.RegisterTransitionEffect("tunnel", {
		showPlayerStart : true,
		showPlayerEnd : true,
		duration : 1500,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			if (delta <= 0.4) {
				var tunnelDelta = 1 - (delta / 0.4);

				var xDist = start.PlayerCenter.x - pixelX;
				var yDist = start.PlayerCenter.y - pixelY;
				var dist = Math.sqrt((xDist * xDist) + (yDist * yDist));

				if (dist > start.Image.Width * tunnelDelta) {
					return {r:0,g:0,b:0,a:255};
				}
				else {
					return start.Image.GetPixel(pixelX,pixelY);
				}
			}
			else if (delta <= 0.6)
			{
				return {r:0,g:0,b:0,a:255};
			}
			else {
				var tunnelDelta = (delta - 0.6) / 0.4;

				var xDist = end.PlayerCenter.x - pixelX;
				var yDist = end.PlayerCenter.y - pixelY;
				var dist = Math.sqrt((xDist * xDist) + (yDist * yDist));

				if (dist > end.Image.Width * tunnelDelta) {
					return {r:0,g:0,b:0,a:255};
				}
				else {
					return end.Image.GetPixel(pixelX,pixelY);
				}
			}
		}
	});

	this.RegisterTransitionEffect("slide_u", {
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 1000,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var pixelOffset = -1 * Math.floor(start.Image.Height * delta);
			var slidePixelY = pixelY + pixelOffset;

			var colorDelta = clampLerp(delta, 0.4);

			if (slidePixelY >= 0) {
				var colorA = start.Image.GetPixel(pixelX,slidePixelY);
				var colorB = PostProcessUtilities.GetCorrespondingColorFromPal(colorA,start.Palette,end.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
			else {
				slidePixelY += start.Image.Height;
				var colorB = end.Image.GetPixel(pixelX,slidePixelY);
				var colorA = PostProcessUtilities.GetCorrespondingColorFromPal(colorB,end.Palette,start.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
		}
	});

	this.RegisterTransitionEffect("slide_d", {
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 1000,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var pixelOffset = Math.floor(start.Image.Height * delta);
			var slidePixelY = pixelY + pixelOffset;

			var colorDelta = clampLerp(delta, 0.4);

			if (slidePixelY < start.Image.Height) {
				var colorA = start.Image.GetPixel(pixelX,slidePixelY);
				var colorB = PostProcessUtilities.GetCorrespondingColorFromPal(colorA,start.Palette,end.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
			else {
				slidePixelY -= start.Image.Height;
				var colorB = end.Image.GetPixel(pixelX,slidePixelY);
				var colorA = PostProcessUtilities.GetCorrespondingColorFromPal(colorB,end.Palette,start.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
		}
	});

	this.RegisterTransitionEffect("slide_l", {
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 1000,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var pixelOffset = -1 * Math.floor(start.Image.Width * delta);
			var slidePixelX = pixelX + pixelOffset;

			var colorDelta = clampLerp(delta, 0.4);

			if (slidePixelX >= 0) {
				var colorA = start.Image.GetPixel(slidePixelX,pixelY);
				var colorB = PostProcessUtilities.GetCorrespondingColorFromPal(colorA,start.Palette,end.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
			else {
				slidePixelX += start.Image.Width;
				var colorB = end.Image.GetPixel(slidePixelX,pixelY);
				var colorA = PostProcessUtilities.GetCorrespondingColorFromPal(colorB,end.Palette,start.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
		}
	});

	this.RegisterTransitionEffect("slide_r", {
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 1000,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var pixelOffset = Math.floor(start.Image.Width * delta);
			var slidePixelX = pixelX + pixelOffset;

			var colorDelta = clampLerp(delta, 0.4);

			if (slidePixelX < start.Image.Width) {
				var colorA = start.Image.GetPixel(slidePixelX,pixelY);
				var colorB = PostProcessUtilities.GetCorrespondingColorFromPal(colorA,start.Palette,end.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
			else {
				slidePixelX -= start.Image.Width;
				var colorB = end.Image.GetPixel(slidePixelX,pixelY);
				var colorA = PostProcessUtilities.GetCorrespondingColorFromPal(colorB,end.Palette,start.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
		}
	});

	function clampLerp(deltaIn, clampDuration) {
		var clampOffset = (1.0 - clampDuration) / 2;
		var deltaOut = Math.min(clampDuration, Math.max(0.0, deltaIn - clampOffset)) / clampDuration;
		return deltaOut;
	}

	// TODO : WIP
	// this.RegisterTransitionEffect("fuzz", {
	// 	showPlayerStart : true,
	// 	showPlayerEnd : true,
	// 	duration : 1500,
	// 	pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
	// 		var curImage = delta <= 0.5 ? start : end;
	// 		var sampleSize = delta <= 0.5 ? (2 + Math.floor(14 * (delta/0.5))) : (16 - Math.floor(14 * ((delta-0.5)/0.5)));

	// 		var palIndex = 0;

	// 		var sampleX = Math.floor(pixelX / sampleSize) * sampleSize;
	// 		var sampleY = Math.floor(pixelY / sampleSize) * sampleSize;

	// 		var frameState = transitionEffects["fuzz"].frameState;

	// 		if (frameState.time != delta) {
	// 			frameState.time = delta;
	// 			frameState.preCalcSampleValues = {};
	// 		}

	// 		if (frameState.preCalcSampleValues[[sampleX,sampleY]]) {
	// 			palIndex = frameState.preCalcSampleValues[[sampleX,sampleY]];
	// 		}
	// 		else {
	// 			var paletteCount = {};
	// 			var foregroundValue = 1.0;
	// 			var backgroundValue = 0.4;
	// 			for (var y = sampleY; y < sampleY + sampleSize; y++) {
	// 				for (var x = sampleX; x < sampleX + sampleSize; x++) {
	// 					var color = curImage.Image.GetPixel(x,y)
	// 					var palIndex = PostProcessUtilities.GetColorPalIndex(color,curImage.Palette);
	// 					if (palIndex != -1) {
	// 						if (paletteCount[palIndex]) {
	// 							paletteCount[palIndex] += (palIndex != 0) ? foregroundValue : backgroundValue;
	// 						}
	// 						else {
	// 							paletteCount[palIndex] = (palIndex != 0) ? foregroundValue : backgroundValue;
	// 						}
	// 					}
	// 				}
	// 			}

	// 			var maxCount = 0;
	// 			for (var i in paletteCount) {
	// 				if (paletteCount[i] > maxCount) {
	// 					palIndex = i;
	// 					maxCount = paletteCount[i];
	// 				}
	// 			}

	// 			frameState.preCalcSampleValues[[sampleX,sampleY]] = palIndex;
	// 		}

	// 		return PostProcessUtilities.GetPalColor(curImage.Palette,palIndex);
	// 	},
	// 	frameState : { // ok this is hacky but it's for performance ok
	// 		time : -1,
	// 		preCalcSampleValues : {}
	// 	}
	// });
}; // TransitionManager()


// TODO : extract the scale variable so it can be changed?
var PostProcessUtilities = {
	SamplePixelColor : function(image,x,y) {
		var pixelIndex = (y * scale * image.width * 4) + (x * scale * 4);
		var r = image.data[pixelIndex + 0];
		var g = image.data[pixelIndex + 1];
		var b = image.data[pixelIndex + 2];
		var a = image.data[pixelIndex + 3];
		return { r:r, g:g, b:b, a:a };
	},
	SetPixelColor : function(image,x,y,colorRgba) {
		for (var yDelta = 0; yDelta < scale; yDelta++) {
			for (var xDelta = 0; xDelta < scale; xDelta++) {
				var pixelIndex = (((y * scale) + yDelta) * image.width * 4) + (((x * scale) + xDelta) * 4);
				image.data[pixelIndex + 0] = colorRgba.r;
				image.data[pixelIndex + 1] = colorRgba.g;
				image.data[pixelIndex + 2] = colorRgba.b;
				image.data[pixelIndex + 3] = colorRgba.a;
			}
		}
	},
	LerpColor : function(colorA,colorB,t) {
		// TODO: move to color_util.js?
		return {
			r : colorA.r + ((colorB.r - colorA.r) * t),
			g : colorA.g + ((colorB.g - colorA.g) * t),
			b : colorA.b + ((colorB.b - colorA.b) * t),
			a : colorA.a + ((colorB.a - colorA.a) * t),
		};
	},
	GetColorPalIndex : function(colorIn,curPal) {
		var colorIndex = -1;

		for (var i = 0; i < curPal.length; i++) {
			if (colorIn.r == curPal[i][0] && colorIn.g == curPal[i][1] && colorIn.b == curPal[i][2]) {
				colorIndex = i;
			}
		}

		return colorIndex;
	},
	GetPalColor : function(palette,index) {
		return { r: palette[index][0], g: palette[index][1], b: palette[index][2], a: 255 }
	},
	GetCorrespondingColorFromPal : function(colorIn,curPal,otherPal) { // this is kind of hacky!
		var colorIndex = PostProcessUtilities.GetColorPalIndex(colorIn,curPal);

		if (colorIndex >= 0 && colorIndex <= otherPal.length) {
			return PostProcessUtilities.GetPalColor(otherPal,colorIndex);
		}
		else {
			return colorIn;
		}
	},
};

var PostProcessImage = function(imageData) {
	this.Width = imageData.width / scale;
	this.Height = imageData.height / scale;

	this.GetPixel = function(x,y) {
		return PostProcessUtilities.SamplePixelColor(imageData,x,y);
	};

	this.SetPixel = function(x,y,colorRgba) {
		PostProcessUtilities.SetPixelColor(imageData,x,y,colorRgba);
	};

	this.GetData = function() {
		return imageData;
	};
};

var TransitionInfo = function(image, palette, playerX, playerY) {
	this.Image = image;
	this.Palette = palette;
	this.PlayerTilePos = { x: playerX, y: playerY };
	this.PlayerCenter = { x: Math.floor((playerX * tilesize) + (tilesize / 2)), y: Math.floor((playerY * tilesize) + (tilesize / 2)) };
};
</script>

<script>
/*
TODO:
- can I simplify this more now that I've removed the external resources stuff?
*/

function FontManager(packagedFontNames) {

var self = this;

var fontExtension = ".bitsyfont";
this.GetExtension = function() {
	return fontExtension;
}

// place to store font data
var fontResources = {};

// load fonts from the editor
if (packagedFontNames != undefined && packagedFontNames != null && packagedFontNames.length > 0
		&& Resources != undefined && Resources != null) {

	for (var i = 0; i < packagedFontNames.length; i++) {
		var filename = packagedFontNames[i];
		fontResources[filename] = Resources[filename];
	}
}

// manually add resource
this.AddResource = function(filename, fontdata) {
	fontResources[filename] = fontdata;
}

this.ContainsResource = function(filename) {
	return fontResources[filename] != null;
}

function GetData(fontName) {
	return fontResources[fontName + fontExtension];
}
this.GetData = GetData;

function Create(fontData) {
	return new Font(fontData);
}
this.Create = Create;

this.Get = function(fontName) {
	var fontData = self.GetData(fontName);
	return self.Create(fontData);
}

function Font(fontData) {
	var name = "unknown";
	var width = 6; // default size so if you have NO font or an invalid font it displays boxes
	var height = 8;
	var chardata = {};

	// create invalid char data at default size in case the font is missing
	var invalidCharData = {};
	updateInvalidCharData();

	this.getName = function() {
		return name;
	}

	this.getData = function() {
		return chardata;
	}

	this.getWidth = function() {
		return width;
	}

	this.getHeight = function() {
		return height;
	}

	this.hasChar = function(char) {
		var codepoint = char.charCodeAt(0);
		return chardata[codepoint] != null;
	}

	this.getChar = function(char) {

		var codepoint = char.charCodeAt(0);

		if (chardata[codepoint] != null) {
			return chardata[codepoint];
		}
		else {
			return invalidCharData;
		}
	}

	this.allCharCodes = function() {
		var codeList = [];
		for (var code in chardata) {
			codeList.push(code);
		}
		return codeList;
	}

	function createCharData() {
		return { 
			width: width,
			height: height,
			offset: {
				x: 0,
				y: 0
			},
			spacing: width,
			data: [],
		};
	}

	function updateInvalidCharData() {
		invalidCharData = createCharData();
		for (var y = 0; y < height; y++) {
			for (var x = 0; x < width; x++) {
				if (x < width-1 && y < height-1) {
					invalidCharData.data.push(1);
				}
				else {
					invalidCharData.data.push(0);
				}
			}
		}
	}

	function parseFont(fontData) {
		if (fontData == null) {
			return;
		}

		var lines = fontData.split("\n");

		var isReadingChar = false;
		var isReadingCharProperties = false;
		var curCharLineCount = 0;
		var curCharCode = 0;

		for (var i = 0; i < lines.length; i++) {
			var line = lines[i];

			if (line[0] === "#") {
				continue; // skip comment lines
			}

			if (!isReadingChar) {
				// READING NON CHARACTER DATA LINE
				var args = line.split(" ");
				if (args[0] == "FONT") {
					name = args[1];
				}
				else if (args[0] == "SIZE") {
					width = parseInt(args[1]);
					height = parseInt(args[2]);
				}
				else if (args[0] == "CHAR") {
					isReadingChar = true;
					isReadingCharProperties = true;

					curCharLineCount = 0;
					curCharCode = parseInt(args[1]);
					chardata[curCharCode] = createCharData();
				}
			}
			else {
				// CHAR PROPERTIES
				if (isReadingCharProperties) {
					var args = line.split(" ");
					if (args[0].indexOf("CHAR_") == 0) { // Sub-properties start with "CHAR_"
						if (args[0] == "CHAR_SIZE") {
							// Custom character size - overrides the default character size for the font
							chardata[curCharCode].width = parseInt(args[1]);
							chardata[curCharCode].height = parseInt(args[2]);
							chardata[curCharCode].spacing = parseInt(args[1]); // HACK : assumes CHAR_SIZE is always declared first
						}
						else if (args[0] == "CHAR_OFFSET") {
							// Character offset - shift the origin of the character on the X or Y axis
							chardata[curCharCode].offset.x = parseInt(args[1]);
							chardata[curCharCode].offset.y = parseInt(args[2]);
						}
						else if (args[0] == "CHAR_SPACING") {
							// Character spacing:
							// specify total horizontal space taken up by the character
							// lets chars take up more or less space on a line than its bitmap does
							chardata[curCharCode].spacing = parseInt(args[1]);
						}
					}
					else {
						isReadingCharProperties = false;
					}
				}

				// CHAR DATA
				if (!isReadingCharProperties) {
					// READING CHARACTER DATA LINE
					for (var j = 0; j < chardata[curCharCode].width; j++)
					{
						chardata[curCharCode].data.push( parseInt(line[j]) );
					}

					curCharLineCount++;
					if (curCharLineCount >= height) {
						isReadingChar = false;
					}
				}
			}
		}

		// re-init invalid character box at the actual font size once it's loaded
		updateInvalidCharData();
	}

	parseFont(fontData);
}

} // FontManager
</script>

<script>
function Script() {

this.CreateInterpreter = function() {
	return new Interpreter();
};

this.CreateUtils = function() {
	return new Utils();
};

var Interpreter = function() {
	var env = new Environment();
	var parser = new Parser( env );

	this.SetDialogBuffer = function(buffer) { env.SetDialogBuffer( buffer ); };

	// TODO -- maybe this should return a string instead othe actual script??
	this.Compile = function(scriptName, scriptStr) {
		// console.log("COMPILE");
		var script = parser.Parse(scriptStr, scriptName);
		env.SetScript(scriptName, script);
	}
	this.Run = function(scriptName, exitHandler, objectContext) { // Runs pre-compiled script
		var localEnv = new LocalEnvironment(env);

		if (objectContext) {
			localEnv.SetObject(objectContext); // PROTO : should this be folded into the constructor?
		}

		var script = env.GetScript(scriptName);

		script.Eval( localEnv, function(result) { OnScriptReturn(localEnv, exitHandler); } );
	}
	this.Interpret = function(scriptStr, exitHandler, objectContext) { // Compiles and runs code immediately
		// console.log("INTERPRET");
		var localEnv = new LocalEnvironment(env);

		if (objectContext) {
			localEnv.SetObject(objectContext); // PROTO : should this be folded into the constructor?
		}

		var script = parser.Parse(scriptStr, "anonymous");
		script.Eval( localEnv, function(result) { OnScriptReturn(localEnv, exitHandler); } );
	}
	this.HasScript = function(name) { return env.HasScript(name); };

	this.ResetEnvironment = function() {
		env = new Environment();
		parser = new Parser( env );
	}

	this.Parse = function(scriptStr, rootId) { // parses a script but doesn't save it
		return parser.Parse(scriptStr, rootId);
	}

	// TODO : add back in if needed later...
	// this.CompatibilityParse = function(scriptStr, compatibilityFlags) {
	// 	env.compatibilityFlags = compatibilityFlags;

	// 	var result = parser.Parse(scriptStr);

	// 	delete env.compatibilityFlags;

	// 	return result;
	// }

	this.Eval = function(scriptTree, exitHandler) { // runs a script stored externally
		var localEnv = new LocalEnvironment(env); // TODO : does this need an object context?
		scriptTree.Eval(
			localEnv,
			function(result) {
				OnScriptReturn(result, exitHandler);
			});
	}

	function OnScriptReturn(result, exitHandler) {
		if (exitHandler != null) {
			exitHandler(result);
		}
	}

	this.CreateExpression = function(expStr) {
		return parser.CreateExpression(expStr);
	}

	this.SetVariable = function(name,value,useHandler) {
		env.SetVariable(name,value,useHandler);
	}

	this.DeleteVariable = function(name,useHandler) {
		env.DeleteVariable(name,useHandler);
	}
	this.HasVariable = function(name) {
		return env.HasVariable(name);
	}

	this.SetOnVariableChangeHandler = function(onVariableChange) {
		env.SetOnVariableChangeHandler(onVariableChange);
	}
	this.GetVariableNames = function() {
		return env.GetVariableNames();
	}
	this.GetVariable = function(name) {
		return env.GetVariable(name);
	}

	function DebugVisualizeScriptTree(scriptTree) {
		var printVisitor = {
			Visit : function(node,depth) {
				console.log("-".repeat(depth) + "- " + node.ToString());
			},
		};

		scriptTree.VisitAll( printVisitor );
	}

	this.DebugVisualizeScriptTree = DebugVisualizeScriptTree;

	this.DebugVisualizeScript = function(scriptName) {
		DebugVisualizeScriptTree(env.GetScript(scriptName));
	}
}


var Utils = function() {
	// for editor ui
	this.CreateDialogBlock = function(children,doIndentFirstLine) {
		if (doIndentFirstLine === undefined) {
			doIndentFirstLine = true;
		}

		var block = new DialogBlockNode(doIndentFirstLine);

		for (var i = 0; i < children.length; i++) {
			block.AddChild(children[i]);
		}
		return block;
	}

	this.CreateOptionBlock = function() {
		var block = new DialogBlockNode(false);
		block.AddChild(new FuncNode("print", [new LiteralNode(" ")]));
		return block;
	}

	this.CreateItemConditionPair = function() {
		var itemFunc = this.CreateFunctionBlock("item", ["0"]);
		var condition = new ExpNode("==", itemFunc, new LiteralNode(1));
		var result = new DialogBlockNode(true);
		result.AddChild(new FuncNode("print", [new LiteralNode(" ")]));
		var conditionPair = new ConditionPairNode(condition, result);
		return conditionPair;
	}

	this.CreateVariableConditionPair = function() {
		var varNode = this.CreateVariableNode("a");
		var condition = new ExpNode("==", varNode, new LiteralNode(1));
		var result = new DialogBlockNode(true);
		result.AddChild(new FuncNode("print", [new LiteralNode(" ")]));
		var conditionPair = new ConditionPairNode(condition, result);
		return conditionPair;
	}

	this.CreateDefaultConditionPair = function() {
		var condition = this.CreateElseNode();
		var result = new DialogBlockNode(true);
		result.AddChild(new FuncNode("print", [new LiteralNode(" ")]));
		var conditionPair = new ConditionPairNode(condition, result);
		return conditionPair;
	}

	this.CreateEmptyPrintFunc = function() {
		return new FuncNode("print", [new LiteralNode("...")]);
	}

	this.CreateFunctionBlock = function(name, initParamValues) {
		var parameters = [];
		for (var i = 0; i < initParamValues.length; i++) {
			parameters.push(new LiteralNode(initParamValues[i]));
		}

		var node = new FuncNode(name, parameters);
		var block = new CodeBlockNode();
		block.AddChild(node);
		return block;
	}

	// TODO : rename ParseStringToLiteralNode?
	this.CreateLiteralNode = function(str) {
		if (str === "true") {
			return new LiteralNode(true);
		}
		else if (str === "false") {
			return new LiteralNode(false);
		}
		else if (!isNaN(parseFloat(str))) {
			return new LiteralNode(parseFloat(str));
		}
		else {
			return new LiteralNode(str);
		}
	}

	this.CreateVariableNode = function(variableName) {
		return new VarNode(variableName);
	}

	this.CreatePropertyNode = function(propertyName, literalValue) {
		var varNode = new VarNode(propertyName);
		var valNode = new LiteralNode(literalValue);
		var node = new FuncNode("property", [varNode, valNode]);
		var block = new CodeBlockNode();
		block.AddChild(node);
		return block;
	}

	this.CreateElseNode = function() {
		return new ElseNode();
	}

	this.CreateStringLiteralNode = function(str) {
		return new LiteralNode(str);
	}

	// TODO : need to split up code & dialog blocks :|
	this.CreateCodeBlock = function() {
		return new CodeBlockNode();
	}

	this.ChangeSequenceType = function(oldSequence, type) {
		if(type === "sequence") {
			return new SequenceNode(oldSequence.children);
		}
		else if(type === "cycle") {
			return new CycleNode(oldSequence.children);
		}
		else if(type === "shuffle") {
			return new ShuffleNode(oldSequence.children);
		}
		return oldSequence;
	}

	this.CreateSequenceBlock = function() {
		var option1 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option1.AddChild(new FuncNode("print", [new LiteralNode("...")]));

		var option2 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option2.AddChild(new FuncNode("print", [new LiteralNode("...")]));

		var sequence = new SequenceNode( [ option1, option2 ] );
		var block = new CodeBlockNode();
		block.AddChild( sequence );
		return block;
	}

	this.CreateCycleBlock = function() {
		var option1 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option1.AddChild(new FuncNode("print", [new LiteralNode("...")]));

		var option2 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option2.AddChild(new FuncNode("print", [new LiteralNode("...")]));

		var sequence = new CycleNode( [ option1, option2 ] );
		var block = new CodeBlockNode();
		block.AddChild( sequence );
		return block;
	}

	this.CreateShuffleBlock = function() {
		var option1 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option1.AddChild(new FuncNode("print", [new LiteralNode("...")]));

		var option2 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option2.AddChild(new FuncNode("print", [new LiteralNode("...")]));

		var sequence = new ShuffleNode( [ option1, option2 ] );
		var block = new CodeBlockNode();
		block.AddChild( sequence );
		return block;
	}

	this.CreateIfBlock = function() {
		var leftNode = new CodeBlockNode();
		leftNode.AddChild( new FuncNode("item", [new LiteralNode("0")] ) );
		var rightNode = new LiteralNode( 1 );
		var condition1 = new ExpNode("==", leftNode, rightNode );

		var condition2 = new ElseNode();

		var result1 = new DialogBlockNode();
		result1.AddChild(new FuncNode("print", [new LiteralNode("...")]));

		var result2 = new DialogBlockNode();
		result2.AddChild(new FuncNode("print", [new LiteralNode("...")]));

		var ifNode = new IfNode( [ condition1, condition2 ], [ result1, result2 ] );
		var block = new CodeBlockNode();
		block.AddChild( ifNode );
		return block;
	}

	this.ReadDialogScript = function(lines, i) {
		var scriptStr = "";
		if (lines[i] === Sym.DialogOpen) {
			scriptStr += lines[i] + "\n";
			i++;
			while(lines[i] != Sym.DialogClose) {
				scriptStr += lines[i] + "\n";
				i++;
			}
			scriptStr += lines[i];
			i++;
		}
		else {
			scriptStr += lines[i];
			i++;
		}
		return { script:scriptStr, index:i };
	}

	// TODO this.ReadCodeScript (reads through code open and close symbols), and this.ReadScript

	this.EnsureDialogBlockFormat = function(dialogStr) {
		// TODO -- what if it's already enclosed in dialog symbols??
		if(dialogStr.indexOf('\n') > -1) {
			dialogStr = Sym.DialogOpen + "\n" + dialogStr + "\n" + Sym.DialogClose;
		}
		return dialogStr;
	}

	this.RemoveDialogBlockFormat = function(source) {
		var sourceLines = source.split("\n");
		var dialogStr = "";
		if(sourceLines[0] === Sym.DialogOpen) {
			// multi line
			var i = 1;
			while (i < sourceLines.length && sourceLines[i] != Sym.DialogClose) {
				dialogStr += sourceLines[i] + (sourceLines[i+1] != Sym.DialogClose ? '\n' : '');
				i++;
			}
		}
		else {
			// single line
			dialogStr = source;
		}
		return dialogStr;
	}

	this.SerializeDialogNodeList = function(nodeList) {
		var tempBlock = new DialogBlockNode(false);
		 // set children directly to avoid breaking the parenting chain for this temp operation
		tempBlock.children = nodeList;
		return tempBlock.Serialize();
	}

	this.GetOperatorList = function() {
		return [Sym.Set].concat(Sym.Operators);
	}

	this.IsInlineCode = function(node) {
		return isInlineCode(node);
	}
}


/* BUILT-IN FUNCTIONS */ // TODO: better way to encapsulate these?
function deprecatedFunc(environment,parameters,onReturn) {
	console.log("BITSY SCRIPT WARNING: Tried to use deprecated function");
	onReturn(null);
}

function printFunc(environment, parameters, onReturn) {
	if (parameters[0] != undefined && parameters[0] != null) {
		var textStr = "" + parameters[0];
		environment.GetDialogBuffer().AddText(textStr);
		environment.GetDialogBuffer().AddScriptReturn(function() { onReturn(null); });
	}
	else {
		onReturn(null);
	}
}

function linebreakFunc(environment, parameters, onReturn) {
	// console.log("LINEBREAK FUNC");
	environment.GetDialogBuffer().AddLinebreak();
	environment.GetDialogBuffer().AddScriptReturn(function() { onReturn(null); });
}

function pagebreakFunc(environment, parameters, onReturn) {
	environment.GetDialogBuffer().AddPagebreak(function() { onReturn(null); });
}

function printDrawingFunc(environment, parameters, onReturn) {
	var drawingId = parameters[0];
	environment.GetDialogBuffer().AddDrawing(drawingId);
	environment.GetDialogBuffer().AddScriptReturn(function() { onReturn(null); });
}

function printSpriteFunc(environment,parameters,onReturn) {
	var spriteId = parameters[0];
	if(names.sprite.has(spriteId)) spriteId = names.sprite.get(spriteId); // id is actually a name
	var drawingId = sprite[spriteId].drw;
	printDrawingFunc(environment, [drawingId], onReturn);
}

function printTileFunc(environment,parameters,onReturn) {
	var tileId = parameters[0];
	if(names.tile.has(tileId)) tileId = names.tile.get(tileId); // id is actually a name
	var drawingId = tile[tileId].drw;
	printDrawingFunc(environment, [drawingId], onReturn);
}

function printItemFunc(environment,parameters,onReturn) {
	var itemId = parameters[0];
	if(names.item.has(itemId)) itemId = names.item.get(itemId); // id is actually a name
	var drawingId = item[itemId].drw;
	printDrawingFunc(environment, [drawingId], onReturn);
}

function printFontFunc(environment, parameters, onReturn) {
	var allCharacters = "";
	var font = fontManager.Get( fontName );
	var codeList = font.allCharCodes();
	for (var i = 0; i < codeList.length; i++) {
		allCharacters += String.fromCharCode(codeList[i]) + " ";
	}
	printFunc(environment, [allCharacters], onReturn);
}

function itemFunc(environment,parameters,onReturn) {
	var itemId = parameters[0];

	if (names.item.has(itemId)) {
		// id is actually a name
		itemId = names.item.get(itemId);
	}

	var curItemCount = player().inventory[itemId] ? player().inventory[itemId] : 0;

	if (parameters.length > 1) {
		// TODO : is it a good idea to force inventory to be >= 0?
		player().inventory[itemId] = Math.max(0, parseInt(parameters[1]));
		curItemCount = player().inventory[itemId];

		if (onInventoryChanged != null) {
			onInventoryChanged(itemId);
		}
	}

	onReturn(curItemCount);
}

function addOrRemoveTextEffect(environment,name) {
	if( environment.GetDialogBuffer().HasTextEffect(name) )
		environment.GetDialogBuffer().RemoveTextEffect(name);
	else
		environment.GetDialogBuffer().AddTextEffect(name);
}

function rainbowFunc(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"rbw");
	onReturn(null);
}

// TODO : should the colors use a parameter instead of special names?
function color1Func(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"clr1");
	onReturn(null);
}

function color2Func(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"clr2");
	onReturn(null);
}

function color3Func(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"clr3");
	onReturn(null);
}

function wavyFunc(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"wvy");
	onReturn(null);
}

function shakyFunc(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"shk");
	onReturn(null);
}

function propertyFunc(environment, parameters, onReturn) {
	var outValue = null;

	if (parameters.length > 0 && parameters[0]) {
		var propertyName = parameters[0];

		if (environment.HasProperty(propertyName)) {
			// TODO : in a future update I can handle the case of initializing a new property
			// after which we can move this block outside the HasProperty check
			if (parameters.length > 1) {
				var inValue = parameters[1];
				environment.SetProperty(propertyName, inValue);
			}

			outValue = environment.GetProperty(propertyName);
		}
	}

	console.log("PROPERTY! " + propertyName + " " + outValue);

	onReturn(outValue);
}

function endFunc(environment,parameters,onReturn) {
	isEnding = true;
	isNarrating = true;
	dialogRenderer.SetCentered(true);
	onReturn(null);
}

function exitFunc(environment,parameters,onReturn) {
	var destRoom = parameters[0];

	if (names.room.has(destRoom)) {
		// it's a name, not an id! (note: these could cause trouble if people names things weird)
		destRoom = names.room.get(destRoom);
	}

	var destX = parseInt(parameters[1]);
	var destY = parseInt(parameters[2]);

	if (parameters.length >= 4) {
		var transitionEffect = parameters[3];

		transition.BeginTransition(
			player().room,
			player().x,
			player().y,
			destRoom,
			destX,
			destY,
			transitionEffect);
		transition.UpdateTransition(0);
	}

	player().room = destRoom;
	player().x = destX;
	player().y = destY;
	curRoom = destRoom;
	initRoom(curRoom);

	// TODO : this doesn't play nice with pagebreak because it thinks the dialog is finished!
	if (transition.IsTransitionActive()) {
		transition.OnTransitionComplete(function() { onReturn(null); });
	}
	else {
		onReturn(null);
	}
}

/* BUILT-IN OPERATORS */
function setExp(environment,left,right,onReturn) {
	// console.log("SET " + left.name);

	if(left.type != "variable") {
		// not a variable! return null and hope for the best D:
		onReturn( null );
		return;
	}

	right.Eval(environment,function(rVal) {
		environment.SetVariable( left.name, rVal );
		// console.log("VAL " + environment.GetVariable( left.name ) );
		left.Eval(environment,function(lVal) {
			onReturn( lVal );
		});
	});
}
function equalExp(environment,left,right,onReturn) {
	// console.log("EVAL EQUAL");
	// console.log(left);
	// console.log(right);
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal === rVal );
		});
	});
}
function greaterExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal > rVal );
		});
	});
}
function lessExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal < rVal );
		});
	});
}
function greaterEqExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal >= rVal );
		});
	});
}
function lessEqExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal <= rVal );
		});
	});
}
function multExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal * rVal );
		});
	});
}
function divExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal / rVal );
		});
	});
}
function addExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal + rVal );
		});
	});
}
function subExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal - rVal );
		});
	});
}

/* ENVIRONMENT */
var Environment = function() {
	var dialogBuffer = null;
	this.SetDialogBuffer = function(buffer) { dialogBuffer = buffer; };
	this.GetDialogBuffer = function() { return dialogBuffer; };

	var functionMap = new Map();
	functionMap.set("print", printFunc);
	functionMap.set("say", printFunc);
	functionMap.set("br", linebreakFunc);
	functionMap.set("item", itemFunc);
	functionMap.set("rbw", rainbowFunc);
	functionMap.set("clr1", color1Func);
	functionMap.set("clr2", color2Func);
	functionMap.set("clr3", color3Func);
	functionMap.set("wvy", wavyFunc);
	functionMap.set("shk", shakyFunc);
	functionMap.set("printSprite", printSpriteFunc);
	functionMap.set("printTile", printTileFunc);
	functionMap.set("printItem", printItemFunc);
	functionMap.set("debugOnlyPrintFont", printFontFunc); // DEBUG ONLY
	functionMap.set("end", endFunc);
	functionMap.set("exit", exitFunc);
	functionMap.set("pg", pagebreakFunc);
	functionMap.set("property", propertyFunc);

	this.HasFunction = function(name) { return functionMap.has(name); };
	this.EvalFunction = function(name,parameters,onReturn,env) {
		if (env == undefined || env == null) {
			env = this;
		}

		functionMap.get(name)(env, parameters, onReturn);
	}

	var variableMap = new Map();

	this.HasVariable = function(name) { return variableMap.has(name); };
	this.GetVariable = function(name) { return variableMap.get(name); };
	this.SetVariable = function(name,value,useHandler) {
		// console.log("SET VARIABLE " + name + " = " + value);
		if(useHandler === undefined) useHandler = true;
		variableMap.set(name, value);
		if(onVariableChangeHandler != null && useHandler){
			onVariableChangeHandler(name);
		}
	};
	this.DeleteVariable = function(name,useHandler) {
		if(useHandler === undefined) useHandler = true;
		if(variableMap.has(name)) {
			variableMap.delete(name);
			if(onVariableChangeHandler != null && useHandler) {
				onVariableChangeHandler(name);
			}
		}
	};

	var operatorMap = new Map();
	operatorMap.set("=", setExp);
	operatorMap.set("==", equalExp);
	operatorMap.set(">", greaterExp);
	operatorMap.set("<", lessExp);
	operatorMap.set(">=", greaterEqExp);
	operatorMap.set("<=", lessEqExp);
	operatorMap.set("*", multExp);
	operatorMap.set("/", divExp);
	operatorMap.set("+", addExp);
	operatorMap.set("-", subExp);

	this.HasOperator = function(sym) { return operatorMap.get(sym); };
	this.EvalOperator = function(sym,left,right,onReturn) {
		operatorMap.get( sym )( this, left, right, onReturn );
	}

	var scriptMap = new Map();
	this.HasScript = function(name) { return scriptMap.has(name); };
	this.GetScript = function(name) { return scriptMap.get(name); };
	this.SetScript = function(name,script) { scriptMap.set(name, script); };

	var onVariableChangeHandler = null;
	this.SetOnVariableChangeHandler = function(onVariableChange) {
		onVariableChangeHandler = onVariableChange;
	}
	this.GetVariableNames = function() {
		return Array.from( variableMap.keys() );
	}
}

// Local environment for a single run of a script: knows local context
var LocalEnvironment = function(parentEnvironment) {
	// this.SetDialogBuffer // not allowed in local environment?
	this.GetDialogBuffer = function() { return parentEnvironment.GetDialogBuffer(); };

	this.HasFunction = function(name) { return parentEnvironment.HasFunction(name); };
	this.EvalFunction = function(name,parameters,onReturn,env) {
		if (env == undefined || env == null) {
			env = this;
		}

		parentEnvironment.EvalFunction(name,parameters,onReturn,env);
	}

	this.HasVariable = function(name) { return parentEnvironment.HasVariable(name); };
	this.GetVariable = function(name) { return parentEnvironment.GetVariable(name); };
	this.SetVariable = function(name,value,useHandler) { parentEnvironment.SetVariable(name,value,useHandler); };
	// this.DeleteVariable // not needed in local environment?

	this.HasOperator = function(sym) { return parentEnvironment.HasOperator(sym); };
	this.EvalOperator = function(sym,left,right,onReturn,env) {
		if (env == undefined || env == null) {
			env = this;
		}

		parentEnvironment.EvalOperator(sym,left,right,onReturn,env);
	};

	// TODO : I don't *think* any of this is required by the local environment
	// this.HasScript
	// this.GetScript
	// this.SetScript

	// TODO : pretty sure these debug methods aren't required by the local environment either
	// this.SetOnVariableChangeHandler
	// this.GetVariableNames

	/* Here's where specific local context data goes:
	 * this includes access to the object running the script
	 * and any properties it may have (so far only "locked")
	 */

	// The local environment knows what object called it -- currently only used to access properties
	var curObject = null;
	this.HasObject = function() { return curObject != undefined && curObject != null; }
	this.SetObject = function(object) { curObject = object; }
	this.GetObject = function() { return curObject; }

	// accessors for properties of the object that's running the script
	this.HasProperty = function(name) {
		if (curObject && curObject.property && curObject.property.hasOwnProperty(name)) {
			return true;
		}
		else {
			return false;
		}
	};
	this.GetProperty = function(name) {
		if (curObject && curObject.property && curObject.property.hasOwnProperty(name)) {
			return curObject.property[name]; // TODO : should these be getters and setters instead?
		}
		else {
			return null;
		}
	};
	this.SetProperty = function(name, value) {
		// NOTE : for now, we need to gaurd against creating new properties
		if (curObject && curObject.property && curObject.property.hasOwnProperty(name)) {
			curObject.property[name] = value;
		}
	};
}

function leadingWhitespace(depth) {
	var str = "";
	for(var i = 0; i < depth; i++) {
		str += "  "; // two spaces per indent
	}
	// console.log("WHITESPACE " + depth + " ::" + str + "::");
	return str;
}

/* NODES */
var TreeRelationship = function() {
	this.parent = null;
	this.children = [];

	this.AddChild = function(node) {
		this.children.push(node);
		node.parent = this;
	};

	this.AddChildren = function(nodeList) {
		for (var i = 0; i < nodeList.length; i++) {
			this.AddChild(nodeList[i]);
		}
	};

	this.SetChildren = function(nodeList) {
		this.children = [];
		this.AddChildren(nodeList);
	};

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit(this, depth);
		for (var i = 0; i < this.children.length; i++) {
			this.children[i].VisitAll( visitor, depth + 1 );
		}
	};

	this.rootId = null; // for debugging
	this.GetId = function() {
		// console.log(this);
		if (this.rootId != null) {
			return this.rootId;
		}
		else if (this.parent != null) {
			var parentId = this.parent.GetId();
			if (parentId != null) {
				return parentId + "_" + this.parent.children.indexOf(this);
			}
		}
		else {
			return null;
		}
	}
}

var DialogBlockNode = function(doIndentFirstLine) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "dialog_block";

	this.Eval = function(environment, onReturn) {
		// console.log("EVAL BLOCK " + this.children.length);

		if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
			events.Raise("script_node_enter", { id: this.GetId() });
		}

		var lastVal = null;
		var i = 0;

		function evalChildren(children, done) {
			if (i < children.length) {
				// console.log(">> CHILD " + i);
				children[i].Eval(environment, function(val) {
					// console.log("<< CHILD " + i);
					lastVal = val;
					i++;
					evalChildren(children,done);
				});
			}
			else {
				done();
			}
		};

		var self = this;
		evalChildren(this.children, function() {
			if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
				events.Raise("script_node_exit", { id: self.GetId() });
			}

			onReturn(lastVal);
		});
	}

	if (doIndentFirstLine === undefined) {
		doIndentFirstLine = true; // This is just for serialization
	}

	this.Serialize = function(depth) {
		if (depth === undefined) {
			depth = 0;
		}

		var str = "";
		var lastNode = null;

		for (var i = 0; i < this.children.length; i++) {

			var curNode = this.children[i];

			var curNodeIsNonInlineCode = curNode.type === "code_block" && !isInlineCode(curNode);
			var prevNodeIsNonInlineCode = lastNode && lastNode.type === "code_block" && !isInlineCode(lastNode);

			var shouldIndentFirstLine = (i == 0 && doIndentFirstLine);
			var shouldIndentAfterLinebreak = (lastNode && lastNode.type === "function" && lastNode.name === "br");
			var shouldIndentCodeBlock = i > 0 && curNodeIsNonInlineCode;
			var shouldIndentAfterCodeBlock = prevNodeIsNonInlineCode;

			// need to insert a newline before the first block of non-inline code that isn't 
			// preceded by a {br}, since those will create their own newline
			if (i > 0 && curNodeIsNonInlineCode && !prevNodeIsNonInlineCode && !shouldIndentAfterLinebreak) {
				str += "\n";
			}

			if (shouldIndentFirstLine || shouldIndentAfterLinebreak || shouldIndentCodeBlock || shouldIndentAfterCodeBlock) {
				str += leadingWhitespace(depth);
			}

			str += curNode.Serialize(depth);

			if (i < this.children.length-1 && curNodeIsNonInlineCode) {
				str += "\n";
			}

			lastNode = curNode;
		}

		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.GetId();
	};
}

var CodeBlockNode = function() {
	Object.assign( this, new TreeRelationship() );
	this.type = "code_block";

	this.Eval = function(environment, onReturn) {
		// console.log("EVAL BLOCK " + this.children.length);

		if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
			events.Raise("script_node_enter", { id: this.GetId() });
		}

		var lastVal = null;
		var i = 0;

		function evalChildren(children, done) {
			if (i < children.length) {
				// console.log(">> CHILD " + i);
				children[i].Eval(environment, function(val) {
					// console.log("<< CHILD " + i);
					lastVal = val;
					i++;
					evalChildren(children,done);
				});
			}
			else {
				done();
			}
		};

		var self = this;
		evalChildren(this.children, function() {
			if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
				events.Raise("script_node_exit", { id: self.GetId() });
			}

			onReturn(lastVal);
		});
	}

	this.Serialize = function(depth) {
		if(depth === undefined) {
			depth = 0;
		}

		// console.log("SERIALIZE BLOCK!!!");
		// console.log(depth);
		// console.log(doIndentFirstLine);

		var str = "{"; // todo: increase scope of Sym?

		// TODO : do code blocks ever have more than one child anymore????
		for (var i = 0; i < this.children.length; i++) {
			var curNode = this.children[i];
			str += curNode.Serialize(depth);
		}

		str += "}";

		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.GetId();
	};
}

function isInlineCode(node) {
	return isTextEffectBlock(node) || isUndefinedBlock(node) || isMultilineListBlock(node);
}

function isUndefinedBlock(node) {
	return node.type === "code_block" && node.children.length > 0 && node.children[0].type === "undefined";
}

var textEffectBlockNames = ["clr1", "clr2", "clr3", "wvy", "shk", "rbw", "printSprite", "printItem", "printTile", "print", "say", "br"];
function isTextEffectBlock(node) {
	if (node.type === "code_block") {
		if (node.children.length > 0 && node.children[0].type === "function") {
			var func = node.children[0];
			return textEffectBlockNames.indexOf(func.name) != -1;
		}
	}
	return false;
}

var listBlockTypes = ["sequence", "cycle", "shuffle", "if"];
function isMultilineListBlock(node) {
	if (node.type === "code_block") {
		if (node.children.length > 0) {
			var child = node.children[0];
			return listBlockTypes.indexOf(child.type) != -1;
		}
	}
	return false;
}

// for round-tripping undefined code through the parser (useful for hacks!)
var UndefinedNode = function(sourceStr) {
	Object.assign(this, new TreeRelationship());
	this.type = "undefined";
	this.source = sourceStr;

	this.Eval = function(environment,onReturn) {
		addOrRemoveTextEffect(environment, "_debug_highlight");
		printFunc(environment, ["{" + sourceStr + "}"], function() {
			onReturn(null);
		});
		addOrRemoveTextEffect(environment, "_debug_highlight");
	}

	this.Serialize = function(depth) {
		return this.source;
	}

	this.ToString = function() {
		return "undefined" + " " + this.GetId();
	}
}

var FuncNode = function(name,args) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "function";
	this.name = name;
	this.args = args;

	this.Eval = function(environment,onReturn) {
		if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
			events.Raise("script_node_enter", { id: this.GetId() });
		}

		var self = this; // hack to deal with scope (TODO : move up higher?)

		var argumentValues = [];
		var i = 0;

		function evalArgs(args, done) {
			// TODO : really hacky way to make we get the first
			// symbol's NAME instead of its variable value
			// if we are trying to do something with a property
			if (self.name === "property" && i === 0 && i < args.length) {
				if (args[i].type === "variable") {
					argumentValues.push(args[i].name);
					i++;
				}
				else {
					// first argument for a property MUST be a variable symbol
					// -- so skip everything if it's not!
					i = args.length;
				}
			}

			if (i < args.length) {
				// Evaluate each argument
				args[i].Eval(
					environment,
					function(val) {
						argumentValues.push(val);
						i++;
						evalArgs(args, done);
					});
			}
			else {
				done();
			}
		};

		evalArgs(
			this.args,
			function() {
				if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
					events.Raise("script_node_exit", { id: self.GetId() });
				}

				environment.EvalFunction(self.name, argumentValues, onReturn);
			});
	}

	this.Serialize = function(depth) {
		var isDialogBlock = this.parent.type === "dialog_block";
		if (isDialogBlock && this.name === "print") {
			// TODO this could cause problems with "real" print functions
			return this.args[0].value; // first argument should be the text of the {print} func
		}
		else if (isDialogBlock && this.name === "br") {
			return "\n";
		}
		else {
			var str = "";
			str += this.name;
			for(var i = 0; i < this.args.length; i++) {
				str += " ";
				str += this.args[i].Serialize(depth);
			}
			return str;
		}
	}

	this.ToString = function() {
		return this.type + " " + this.name + " " + this.GetId();
	};
}

var LiteralNode = function(value) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "literal";
	this.value = value;

	this.Eval = function(environment,onReturn) {
		onReturn(this.value);
	}

	this.Serialize = function(depth) {
		var str = "";

		if (this.value === null) {
			return str;
		}

		if (typeof this.value === "string") {
			str += '"';
		}

		str += this.value;

		if (typeof this.value === "string") {
			str += '"';
		}

		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.value + " " + this.GetId();
	};
}

var VarNode = function(name) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "variable";
	this.name = name;

	this.Eval = function(environment,onReturn) {
		// console.log("EVAL " + this.name + " " + environment.HasVariable(this.name) + " " + environment.GetVariable(this.name));
		if( environment.HasVariable(this.name) )
			onReturn( environment.GetVariable( this.name ) );
		else
			onReturn(null); // not a valid variable -- return null and hope that's ok
	} // TODO: might want to store nodes in the variableMap instead of values???

	this.Serialize = function(depth) {
		var str = "" + this.name;
		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.name + " " + this.GetId();
	};
}

var ExpNode = function(operator, left, right) {
	Object.assign( this, new TreeRelationship() );
	this.type = "operator";
	this.operator = operator;
	this.left = left;
	this.right = right;

	this.Eval = function(environment,onReturn) {
		// console.log("EVAL " + this.operator);
		var self = this; // hack to deal with scope
		environment.EvalOperator( this.operator, this.left, this.right, 
			function(val){
				// console.log("EVAL EXP " + self.operator + " " + val);
				onReturn(val);
			} );
		// NOTE : sadly this pushes a lot of complexity down onto the actual operator methods
	}

	this.Serialize = function(depth) {
		var isNegativeNumber = this.operator === "-" && this.left.type === "literal" && this.left.value === null;

		if (!isNegativeNumber) {
			var str = "";

			if (this.left != undefined && this.left != null) {
				str += this.left.Serialize(depth) + " ";
			}

			str += this.operator;

			if (this.right != undefined && this.right != null) {
				str += " " + this.right.Serialize(depth);
			}

			return str;
		}
		else {
			return this.operator + this.right.Serialize(depth); // hacky but seems to work
		}
	}

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit( this, depth );
		if(this.left != null)
			this.left.VisitAll( visitor, depth + 1 );
		if(this.right != null)
			this.right.VisitAll( visitor, depth + 1 );
	};

	this.ToString = function() {
		return this.type + " " + this.operator + " " + this.GetId();
	};
}

var SequenceBase = function() {
	this.Serialize = function(depth) {
		var str = "";
		str += this.type + "\n";
		for (var i = 0; i < this.children.length; i++) {
			str += leadingWhitespace(depth + 1) + Sym.List + " ";
			str += this.children[i].Serialize(depth + 2);
			str += "\n";
		}
		str += leadingWhitespace(depth);
		return str;
	}

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit(this, depth);
		for (var i = 0; i < this.children.length; i++) {
			this.children[i].VisitAll( visitor, depth + 1 );
		}
	};

	this.ToString = function() {
		return this.type + " " + this.GetId();
	};
}

var SequenceNode = function(options) {
	Object.assign(this, new TreeRelationship());
	Object.assign(this, new SequenceBase());
	this.type = "sequence";
	this.AddChildren(options);

	var index = 0;
	this.Eval = function(environment, onReturn) {
		// console.log("SEQUENCE " + index);
		this.children[index].Eval(environment, onReturn);

		var next = index + 1;
		if (next < this.children.length) {
			index = next;
		}
	}
}

var CycleNode = function(options) {
	Object.assign(this, new TreeRelationship());
	Object.assign(this, new SequenceBase());
	this.type = "cycle";
	this.AddChildren(options);

	var index = 0;
	this.Eval = function(environment, onReturn) {
		// console.log("CYCLE " + index);
		this.children[index].Eval(environment, onReturn);

		var next = index + 1;
		if (next < this.children.length) {
			index = next;
		}
		else {
			index = 0;
		}
	}
}

var ShuffleNode = function(options) {
	Object.assign(this, new TreeRelationship());
	Object.assign(this, new SequenceBase());
	this.type = "shuffle";
	this.AddChildren(options);

	var optionsShuffled = [];
	function shuffle(options) {
		optionsShuffled = [];
		var optionsUnshuffled = options.slice();
		while (optionsUnshuffled.length > 0) {
			var i = Math.floor(Math.random() * optionsUnshuffled.length);
			optionsShuffled.push(optionsUnshuffled.splice(i,1)[0]);
		}
	}
	shuffle(this.children);

	var index = 0;
	this.Eval = function(environment, onReturn) {
		optionsShuffled[index].Eval(environment, onReturn);
		
		index++;
		if (index >= this.children.length) {
			shuffle(this.children);
			index = 0;
		}
	}
}

// TODO : rename? ConditionalNode?
var IfNode = function(conditions, results, isSingleLine) {
	Object.assign(this, new TreeRelationship());
	this.type = "if";

	for (var i = 0; i < conditions.length; i++) {
		this.AddChild(new ConditionPairNode(conditions[i], results[i]));
	}

	var self = this;
	this.Eval = function(environment, onReturn) {
		// console.log("EVAL IF");
		var i = 0;
		function TestCondition() {
			self.children[i].Eval(environment, function(result) {
				if (result.conditionValue == true) {
					onReturn(result.resultValue);
				}
				else if (i+1 < self.children.length) {
					i++;
					TestCondition();
				}
				else {
					onReturn(null);
				}
			});
		};
		TestCondition();
	}

	if (isSingleLine === undefined) {
		isSingleLine = false; // This is just for serialization
	}

	this.Serialize = function(depth) {
		var str = "";
		if(isSingleLine) {
			// HACKY - should I even keep this mode???
			str += this.children[0].children[0].Serialize() + " ? " + this.children[0].children[1].Serialize();
			if (this.children.length > 1 && this.children[1].children[0].type === Sym.Else) {
				str += " " + Sym.ElseExp + " " + this.children[1].children[1].Serialize();
			}
		}
		else {
			str += "\n";
			for (var i = 0; i < this.children.length; i++) {
				str += this.children[i].Serialize(depth);
			}
			str += leadingWhitespace(depth);
		}
		return str;
	}

	this.IsSingleLine = function() {
		return isSingleLine;
	}

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit(this, depth);

		for (var i = 0; i < this.children.length; i++) {
			this.children[i].VisitAll(visitor, depth + 1);
		}
	};

	this.ToString = function() {
		return this.type + " " + this.mode + " " + this.GetId();
	};
}

var ConditionPairNode = function(condition, result) {
	Object.assign(this, new TreeRelationship());

	this.type = "condition_pair";

	this.AddChild(condition);
	this.AddChild(result);

	var self = this;

	this.Eval = function(environment, onReturn) {
		self.children[0].Eval(environment, function(conditionSuccess) {
			if (conditionSuccess) {
				self.children[1].Eval(environment, function(resultValue) {
					onReturn({ conditionValue:true, resultValue:resultValue });
				});
			}
			else {
				onReturn({ conditionValue:false });
			}
		});
	}

	this.Serialize = function(depth) {
		var str = "";
		str += leadingWhitespace(depth + 1);
		str += Sym.List + " " + this.children[0].Serialize(depth) + " " + Sym.ConditionEnd + Sym.Linebreak;
		str += this.children[1].Serialize(depth + 2) + Sym.Linebreak;
		return str;
	}

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit(this, depth);

		for (var i = 0; i < this.children.length; i++) {
			this.children[i].VisitAll(visitor, depth + 1);
		}
	}

	this.ToString = function() {
		return this.type + " " + this.GetId();
	}
}

var ElseNode = function() {
	Object.assign( this, new TreeRelationship() );
	this.type = Sym.Else;

	this.Eval = function(environment, onReturn) {
		onReturn(true);
	}

	this.Serialize = function() {
		return Sym.Else;
	}

	this.ToString = function() {
		return this.type + " " + this.mode + " " + this.GetId();
	};
}

var Sym = {
	DialogOpen : '"""',
	DialogClose : '"""',
	CodeOpen : "{",
	CodeClose : "}",
	Linebreak : "\n", // just call it "break" ?
	Separator : ":",
	List : "-",
	String : '"',
	ConditionEnd : "?",
	Else : "else",
	ElseExp : ":", // special shorthand for expressions (deprecate?)
	Set : "=",
	Operators : ["==", ">=", "<=", ">", "<", "-", "+", "/", "*"], // operators need to be in reverse order of precedence
};

var Parser = function(env) {
	var environment = env;

	this.Parse = function(scriptStr, rootId) {
		var rootNode = new DialogBlockNode();
		rootNode.rootId = rootId;
		var state = new ParserState(rootNode, scriptStr);

		console.log(scriptStr);
		console.log(state.Source());

		if (state.MatchAhead(Sym.DialogOpen)) {
			// multi-line dialog block
			var dialogStr = state.ConsumeBlock(Sym.DialogOpen + Sym.Linebreak, Sym.Linebreak + Sym.DialogClose);
			rootNode = new DialogBlockNode();
			rootNode.rootId = rootId; // hacky!!
			state = new ParserState(rootNode, dialogStr);
			state = ParseDialog(state);
		}
		else {
			// single-line dialog block
			state = ParseDialog(state);
		}

		return state.rootNode;
	};

	var ParserState = function( rootNode, str ) {
		this.rootNode = rootNode;
		this.curNode = this.rootNode;

		var sourceStr = str;
		var i = 0;
		this.Index = function() { return i; };
		this.Count = function() { return sourceStr.length; };
		this.Done = function() { return i >= sourceStr.length; };
		this.Char = function() { return sourceStr[i]; };
		this.Step = function(n) { if(n===undefined) n=1; i += n; };
		this.MatchAhead = function(str) {
			// console.log(str);
			str = "" + str; // hack to turn single chars into strings
			// console.log(str);
			// console.log(str.length);
			for (var j = 0; j < str.length; j++) {
				if (i + j >= sourceStr.length) {
					return false;
				}
				else if (str[j] != sourceStr[i+j]) {
					return false;
				}
			}
			return true;
		}
		this.Peak = function(end) {
			var str = "";
			var j = i;
			// console.log(j);
			while (j < sourceStr.length && end.indexOf(sourceStr[j]) == -1) {
				str += sourceStr[j];
				j++;
			}
			// console.log("PEAK ::" + str + "::");
			return str;
		}
		this.ConsumeBlock = function(open, close, includeSymbols) {
			if (includeSymbols === undefined || includeSymbols === null) {
				includeSymbols = false;
			}

			var startIndex = i;

			var matchCount = 0;
			if (this.MatchAhead(open)) {
				matchCount++;
				this.Step(open.length);
			}

			while (matchCount > 0 && !this.Done()) {
				if (this.MatchAhead(close)) {
					matchCount--;
					this.Step( close.length );
				}
				else if (this.MatchAhead(open)) {
					matchCount++;
					this.Step(open.length);
				}
				else {
					this.Step();
				}
			}

			if (includeSymbols) {
				return sourceStr.slice(startIndex, i);
			}
			else {
				return sourceStr.slice(startIndex + open.length, i - close.length);
			}
		}

		this.Print = function() { console.log(sourceStr); };
		this.Source = function() { return sourceStr; };
	};

	/*
		ParseDialog():
		This function adds {print} nodes and linebreak {br} nodes to display text,
		interleaved with bracketed code nodes for functions and flow control,
		such as text effects {shk} {wvy} or sequences like {cycle} and {shuffle}.
		The parsing of those code blocks is handled by ParseCode.

		Note on parsing newline characters:
		- there should be an implicit linebreak {br} after each dialog line
		- a "dialog line" is defined as any line that either:
			- 1) contains dialog text (any text outside of a code block)
			- 2) is entirely empty (no text, no code)
			- *or* 3) contains a list block (sequence, cycle, shuffle, or conditional)
		- lines *only* containing {code} blocks are not dialog lines

		NOTE TO SELF: all the state I'm storing in here feels like
		evidence that the parsing system kind of broke down at this point :(
		Maybe it would feel better if I move into the "state" object
	*/
	function ParseDialog(state) {
		var curLineNodeList = [];
		var curText = "";
		var curLineIsEmpty = true;
		var curLineContainsDialogText = false;
		var prevLineIsDialogLine = false;

		var curLineIsDialogLine = function() {
			return curLineContainsDialogText || curLineIsEmpty;
		}

		var resetLineStateForNewLine = function() {
			prevLineIsDialogLine = curLineIsDialogLine();
			curLineContainsDialogText = false;
			curLineIsEmpty = true;
			curText = "";
			curLineNodeList = [];
		}

		var tryAddTextNodeToList = function() {
			if (curText.length > 0) {
				var printNode = new FuncNode("print", [new LiteralNode(curText)]);
				curLineNodeList.push(printNode);

				curText = "";
				curLineIsEmpty = false;
				curLineContainsDialogText = true;
			}
		}

		var addCodeNodeToList = function() {
			var codeSource = state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose);
			var codeState = new ParserState(new CodeBlockNode(), codeSource);
			codeState = ParseCode(codeState);
			var codeBlockNode = codeState.rootNode;
			curLineNodeList.push(codeBlockNode);

			curLineIsEmpty = false;

			// lists count as dialog text, because they can contain it
			if (isMultilineListBlock(codeBlockNode)) {
				curLineContainsDialogText = true;
			}
		}

		var tryAddLinebreakNodeToList = function() {
			if (prevLineIsDialogLine) {
				var linebreakNode = new FuncNode("br", []);
				curLineNodeList.unshift(linebreakNode);
			}
		}

		var addLineNodesToParent = function() {
			for (var i = 0; i < curLineNodeList.length; i++) {
				state.curNode.AddChild(curLineNodeList[i]);
			}
		}

		while (!state.Done()) {
			if (state.MatchAhead(Sym.CodeOpen)) { // process code block
				// add any buffered text to a print node, and parse the code
				tryAddTextNodeToList();
				addCodeNodeToList();
			}
			else if (state.MatchAhead(Sym.Linebreak)) { // process new line
				// add any buffered text to a print node, 
				// and add a linebreak if we are between two dialog lines
				tryAddTextNodeToList();
				tryAddLinebreakNodeToList();

				// since we've reached the end of a line
				// add stored nodes for this line to the parent node we are building,
				// and reset state for the next line
				addLineNodesToParent();
				resetLineStateForNewLine();

				state.Step();
			}
			else {
				// continue adding text to the current text buffer
				curText += state.Char();
				state.Step();
			}
		}

		// to make sure we don't leave anything behind:
		// add buffered text to a print node and add all nodes
		// to the current parent node
		tryAddTextNodeToList();
		tryAddLinebreakNodeToList();
		addLineNodesToParent();

		return state;
	}

	function ParseDialogBlock(state) {
		var dialogStr = state.ConsumeBlock( Sym.DialogOpen, Sym.DialogClose );

		var dialogState = new ParserState(new DialogBlockNode(), dialogStr);
		dialogState = ParseDialog( dialogState );

		state.curNode.AddChild( dialogState.rootNode );

		return state;
	}

	/*
		ParseConditional():
		A conditional contains a list of conditions that can be
		evaluated to true or false, followed by more dialog
		that will be evaluated if the condition is true. The first
		true condition is the one that gets evaluated.
	*/
	function ParseConditional(state) {
		var conditionStrings = [];
		var resultStrings = [];
		var curIndex = -1;
		var requiredLeadingWhitespace = -1;

		// TODO : very similar to sequence parsing - can we share anything?
		function parseConditionalItemLine(state) {
			var lineText = "";
			var whitespaceCount = 0;
			var isNewCondition = false;
			var encounteredNonWhitespace = false;
			var encounteredConditionEnd = false;

			while (!state.Done() && !(state.Char() === Sym.Linebreak)) {
				// count whitespace until we hit the first non-whitespace character
				if (!encounteredNonWhitespace) {
					if (state.Char() === " " || state.Char() === "\t") {
						whitespaceCount++;
					}
					else {
						encounteredNonWhitespace = true;

						if (state.Char() === Sym.List) {
							isNewCondition = true;
							whitespaceCount += 2; // count the list seperator AND the following extra space
						}
					}
				}

				// if this is the condition, we need to track whether we've
				// reached the end of the condition
				if (isNewCondition && !encounteredConditionEnd) {
					if (state.Char() === Sym.ConditionEnd) {
						encounteredConditionEnd = true;
					}
				}

				// add characters one at a time, unless it's a code block
				// since code blocks can contain additional sequences inside
				// them that will mess up our list item detection
				if (state.Char() === Sym.CodeOpen) {
					lineText += state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose, true /*includeSymbols*/);
				}
				else {
					if (!encounteredConditionEnd) { // skip all characters including & after the condition end
						lineText += state.Char();
					}
					state.Step();
				}
			}

			if (state.Char() === Sym.Linebreak) {
				state.Step();
			}

			return { text:lineText, whitespace:whitespaceCount, isNewCondition:isNewCondition };
		}

		// TODO : this is copied from sequence parsing; share?
		function trimLeadingWhitespace(text, trimLength) {
			var textSplit = text.split(Sym.linebreak);
			textSplit = textSplit.map(function(line) { return line.slice(trimLength) });
			return textSplit.join(Sym.linebreak);
		}

		while (!state.Done()) {
			var lineResults = parseConditionalItemLine(state);

			if (lineResults.isNewCondition) {
				requiredLeadingWhitespace = lineResults.whitespace;
				curIndex++;
				conditionStrings[curIndex] = "";
				resultStrings[curIndex] = "";
			}

			// to avoid extra newlines in nested conditionals, only count lines
			// that at least match the whitespace count of the initial line
			// NOTE: see the comment in sequence parsing for more details
			if (lineResults.whitespace >= requiredLeadingWhitespace) {
				var trimmedText = trimLeadingWhitespace(lineResults.text, requiredLeadingWhitespace);

				if (lineResults.isNewCondition) {
					conditionStrings[curIndex] += trimmedText;
				}
				else {
					resultStrings[curIndex] += trimmedText + Sym.Linebreak;
				}
			}
		}

		// hack: cut off the trailing newlines from all the result strings
		resultStrings = resultStrings.map(function(result) { return result.slice(0,-1); });

		var conditions = [];
		for (var i = 0; i < conditionStrings.length; i++) {
			var str = conditionStrings[i].trim();
			if (str === Sym.Else) {
				conditions.push(new ElseNode());
			}
			else {
				var exp = CreateExpression(str);
				conditions.push(exp);
			}
		}

		var results = [];
		for (var i = 0; i < resultStrings.length; i++) {
			var str = resultStrings[i];
			var dialogBlockState = new ParserState(new DialogBlockNode(), str);
			dialogBlockState = ParseDialog(dialogBlockState);
			var dialogBlock = dialogBlockState.rootNode;
			results.push(dialogBlock);
		}

		state.curNode.AddChild(new IfNode(conditions, results));

		return state;
	}

	function IsSequence(str) {
		// console.log("IsSequence? " + str);
		return str === "sequence" || str === "cycle" || str === "shuffle";
	}

	/*
		ParseSequence():
		Sequence nodes contain a list of dialog block nodes. The order those
		nodes are evaluated is determined by the type of sequence:
		- sequence: each child node evaluated once in order
		- cycle: repeats from the beginning after all nodes evaluate
		- shuffle: evaluate in a random order

		Each item in a sequence is sepearated by a "-" character.
		The seperator must come at the beginning of the line,
		but may be preceded by whitespace (in any amount).

		About whitespace: Whitespace at the start of a line
		is ignored if it less than or equal to the count of
		whitespace that preceded the list separator ("-") at
		the start of that item. (The count also includes the
		seperator and the extra space after the seperator.)
	 */
	function ParseSequence(state, sequenceType) {
		var itemStrings = [];
		var curItemIndex = -1; // -1 indicates not reading an item yet
		var requiredLeadingWhitespace = -1;

		function parseSequenceItemLine(state) {
			var lineText = "";
			var whitespaceCount = 0;
			var isNewListItem = false;
			var encounteredNonWhitespace = false;

			while (!state.Done() && !(state.Char() === Sym.Linebreak)) {
				// count whitespace until we hit the first non-whitespace character
				if (!encounteredNonWhitespace) {
					if (state.Char() === " " || state.Char() === "\t") {
						whitespaceCount++;
					}
					else {
						encounteredNonWhitespace = true;

						if (state.Char() === Sym.List) {
							isNewListItem = true;
							whitespaceCount += 2; // count the list seperator AND the following extra space
						}
					}
				}

				// add characters one at a time, unless it's a code block
				// since code blocks can contain additional sequences inside
				// them that will mess up our list item detection
				if (state.Char() === Sym.CodeOpen) {
					lineText += state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose, true /*includeSymbols*/);
				}
				else {
					lineText += state.Char();
					state.Step();
				}
			}

			if (state.Char() === Sym.Linebreak) {
				state.Step();
			}

			return { text:lineText, whitespace:whitespaceCount, isNewListItem:isNewListItem };
		}

		function trimLeadingWhitespace(text, trimLength) {
			// the split and join is necessary because a single "line"
			// can contain sequences that may contain newlines of their own
			// (we treat them all as one "line" for sequence parsing purposes)
			var textSplit = text.split(Sym.linebreak);
			textSplit = textSplit.map(function(line) { return line.slice(trimLength) });
			return textSplit.join(Sym.linebreak);
		}

		while (!state.Done()) {
			var lineResults = parseSequenceItemLine(state);

			if (lineResults.isNewListItem) {
				requiredLeadingWhitespace = lineResults.whitespace;
				curItemIndex++;
				itemStrings[curItemIndex] = "";
			}

			// to avoid double counting closing lines (empty ones ending in a curly brace)
			// we only allow lines that have at least as much whitespace as the start of the list item
			// TODO : I think right now this leads to a bug if the list item's indentation is less than
			// its parent code block... hopefully that won't be a big deal for now
			// (NOTE: I think the bug could be fixed by only applying this to the FINAL line of an item, but
			// that would require more consideration and testing)
			if (lineResults.whitespace >= requiredLeadingWhitespace) {
				var trimmedText = trimLeadingWhitespace(lineResults.text, requiredLeadingWhitespace);
				itemStrings[curItemIndex] += trimmedText + Sym.Linebreak;
			}
		}

		// a bit hacky: cut off the trailing newlines from all the items
		itemStrings = itemStrings.map(function(item) { return item.slice(0,-1); });

		var options = [];
		for (var i = 0; i < itemStrings.length; i++) {
			var str = itemStrings[i];
			var dialogBlockState = new ParserState(new DialogBlockNode(false /* doIndentFirstLine */), str);
			dialogBlockState = ParseDialog(dialogBlockState);
			var dialogBlock = dialogBlockState.rootNode;
			options.push(dialogBlock);
		}

		if (sequenceType === "sequence") {
			state.curNode.AddChild(new SequenceNode(options));
		}
		else if (sequenceType === "cycle") {
			state.curNode.AddChild(new CycleNode(options));
		}
		else if (sequenceType === "shuffle") {
			state.curNode.AddChild(new ShuffleNode(options));
		}

		return state;
	}

	function ParseFunction(state, funcName) {
		console.log("~~~ PARSE FUNCTION " + funcName);

		var args = [];

		var curSymbol = "";
		function OnSymbolEnd() {
			curSymbol = curSymbol.trim();
			// console.log("PARAMTER " + curSymbol);
			args.push( StringToValue(curSymbol) );
			// console.log(args);
			curSymbol = "";
		}

		while( !( state.Char() === "\n" || state.Done() ) ) {
			if( state.MatchAhead(Sym.CodeOpen) ) {
				var codeBlockState = new ParserState(new CodeBlockNode(), state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose));
				codeBlockState = ParseCode( codeBlockState );
				var codeBlock = codeBlockState.rootNode;
				args.push( codeBlock );
				curSymbol = "";
			}
			else if( state.MatchAhead(Sym.String) ) {
				/* STRING LITERAL */
				var str = state.ConsumeBlock(Sym.String, Sym.String);
				// console.log("STRING " + str);
				args.push( new LiteralNode(str) );
				curSymbol = "";
			}
			else if(state.Char() === " " && curSymbol.length > 0) {
				OnSymbolEnd();
			}
			else {
				curSymbol += state.Char();
			}
			state.Step();
		}

		if(curSymbol.length > 0) {
			OnSymbolEnd();
		}

		state.curNode.AddChild( new FuncNode( funcName, args ) );

		return state;
	}

	function IsValidVariableName(str) {
		var reg = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
		var isValid = reg.test(str);
		// console.log("VALID variable??? " + isValid);
		return isValid;
	}

	function StringToValue(valStr) {
		if(valStr[0] === Sym.CodeOpen) {
			// CODE BLOCK!!!
			var codeStr = (new ParserState( null, valStr )).ConsumeBlock(Sym.CodeOpen, Sym.CodeClose); //hacky
			var codeBlockState = new ParserState(new CodeBlockNode(), codeStr);
			codeBlockState = ParseCode( codeBlockState );
			return codeBlockState.rootNode;
		}
		else if(valStr[0] === Sym.String) {
			// STRING!!
			// console.log("STRING");
			var str = "";
			var i = 1;
			while (i < valStr.length && valStr[i] != Sym.String) {
				str += valStr[i];
				i++;
			}
			// console.log(str);
			return new LiteralNode( str );
		}
		else if(valStr === "true") {
			// BOOL
			return new LiteralNode( true );
		}
		else if(valStr === "false") {
			// BOOL
			return new LiteralNode( false );
		}
		else if( !isNaN(parseFloat(valStr)) ) {
			// NUMBER!!
			// console.log("NUMBER!!! " + valStr);
			return new LiteralNode( parseFloat(valStr) );
		}
		else if(IsValidVariableName(valStr)) {
			// VARIABLE!!
			// console.log("VARIABLE");
			return new VarNode(valStr); // TODO : check for valid potential variables
		}
		else {
			// uh oh
			return new LiteralNode(null);
		}
	}

	function CreateExpression(expStr) {
		expStr = expStr.trim();

		function IsInsideString(index) {
			var inString = false;
			for(var i = 0; i < expStr.length; i++) {
				if(expStr[i] === Sym.String)
					inString = !inString;

				if(index === i)
					return inString;
			}
			return false;
		}

		function IsInsideCode(index) {
			var count = 0;
			for(var i = 0; i < expStr.length; i++) {
				if(expStr[i] === Sym.CodeOpen)
					count++;
				else if(expStr[i] === Sym.CodeClose)
					count--;

				if(index === i)
					return count > 0;
			}
			return false;
		}

		var operator = null;

		// set is special because other operator can look like it, and it has to go first in the order of operations
		var setIndex = expStr.indexOf(Sym.Set);
		if( setIndex > -1 && !IsInsideString(setIndex) && !IsInsideCode(setIndex) ) { // it might be a set operator
			if( expStr[setIndex+1] != "=" && expStr[setIndex-1] != ">" && expStr[setIndex-1] != "<" ) {
				// ok it actually IS a set operator and not ==, >=, or <=
				operator = Sym.Set;
				var variableName = expStr.substring(0,setIndex).trim(); // TODO : valid variable name testing
				var left = IsValidVariableName(variableName) ? new VarNode( variableName ) : new LiteralNode(null);
				var right = CreateExpression( expStr.substring(setIndex+Sym.Set.length) );
				var exp = new ExpNode( operator, left, right );
				return exp;
			}
		}

		// special if "expression" for single-line if statements
		var ifIndex = expStr.indexOf(Sym.ConditionEnd);
		if( ifIndex > -1 && !IsInsideString(ifIndex) && !IsInsideCode(ifIndex) ) {
			operator = Sym.ConditionEnd;
			var conditionStr = expStr.substring(0,ifIndex).trim();
			var conditions = [ CreateExpression(conditionStr) ];

			var resultStr = expStr.substring(ifIndex+Sym.ConditionEnd.length);
			var results = [];
			function AddResult(str) {
				var dialogBlockState = new ParserState(new DialogBlockNode(), str);
				dialogBlockState = ParseDialog( dialogBlockState );
				var dialogBlock = dialogBlockState.rootNode;
				results.push( dialogBlock );
			}

			var elseIndex = resultStr.indexOf(Sym.ElseExp); // does this need to test for strings?
			if(elseIndex > -1) {
				conditions.push( new ElseNode() );

				var elseStr = resultStr.substring(elseIndex+Sym.ElseExp.length);
				var resultStr = resultStr.substring(0,elseIndex);

				AddResult( resultStr.trim() );
				AddResult( elseStr.trim() );
			}
			else {
				AddResult( resultStr.trim() );
			}

			return new IfNode( conditions, results, true /*isSingleLine*/ );
		}

		for( var i = 0; (operator == null) && (i < Sym.Operators.length); i++ ) {
			var opSym = Sym.Operators[i];
			var opIndex = expStr.indexOf( opSym );
			if( opIndex > -1 && !IsInsideString(opIndex) && !IsInsideCode(opIndex) ) {
				operator = opSym;
				var left = CreateExpression( expStr.substring(0,opIndex) );
				var right = CreateExpression( expStr.substring(opIndex+opSym.length) );
				var exp = new ExpNode( operator, left, right );
				return exp;
			}
		}

		if( operator == null ) {
			return StringToValue(expStr);
		}
	}
	this.CreateExpression = CreateExpression;

	function IsWhitespace(str) {
		return ( str === " " || str === "\t" || str === "\n" );
	}

	function IsExpression(str) {
		var tempState = new ParserState(null, str); // hacky
		var textOutsideCodeBlocks = "";

		while (!tempState.Done()) {
			if (tempState.MatchAhead(Sym.CodeOpen)) {
				tempState.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose);
			}
			else {
				textOutsideCodeBlocks += tempState.Char();
				tempState.Step();
			}
		}

		var containsAnyExpressionOperators = (textOutsideCodeBlocks.indexOf(Sym.ConditionEnd) != -1) ||
				(textOutsideCodeBlocks.indexOf(Sym.Set) != -1) ||
				(Sym.Operators.some(function(opSym) { return textOutsideCodeBlocks.indexOf(opSym) != -1; }));

		return containsAnyExpressionOperators;
	}

	function IsLiteral(str) {
		var isBool = str === "true" || str === "false";
		var isNum = !isNaN(parseFloat(str));
		var isStr = str[0] === '"' && str[str.length-1] === '"';
		var isVar = IsValidVariableName(str);
		var isEmpty = str.length === 0;
		return isBool || isNum || isStr || isVar || isEmpty;
	}

	function ParseExpression(state) {
		var line = state.Source(); // state.Peak( [Sym.Linebreak] ); // TODO : remove the linebreak thing
		// console.log("EXPRESSION " + line);
		var exp = CreateExpression(line);
		// console.log(exp);
		state.curNode.AddChild(exp);
		state.Step(line.length);
		return state;
	}

	function IsConditionalBlock(state) {
		var peakToFirstListSymbol = state.Peak([Sym.List]);

		var foundListSymbol = peakToFirstListSymbol < state.Source().length;

		var areAllCharsBeforeListWhitespace = true;
		for (var i = 0; i < peakToFirstListSymbol.length; i++) {
			if (!IsWhitespace(peakToFirstListSymbol[i])) {
				areAllCharsBeforeListWhitespace = false;
			}
		}

		var peakToFirstConditionSymbol = state.Peak([Sym.ConditionEnd]);
		peakToFirstConditionSymbol = peakToFirstConditionSymbol.slice(peakToFirstListSymbol.length);
		var hasNoLinebreakBetweenListAndConditionEnd = peakToFirstConditionSymbol.indexOf(Sym.Linebreak) == -1;

		return foundListSymbol && 
			areAllCharsBeforeListWhitespace && 
			hasNoLinebreakBetweenListAndConditionEnd;
	}

	function ParseCode(state) {
		if (IsConditionalBlock(state)) {
			state = ParseConditional(state);
		}
		else if (environment.HasFunction(state.Peak([" "]))) { // TODO --- what about newlines???
			var funcName = state.Peak([" "]);
			state.Step(funcName.length);
			state = ParseFunction(state, funcName);
		}
		else if (IsSequence(state.Peak([" ", Sym.Linebreak]))) {
			var sequenceType = state.Peak([" ", Sym.Linebreak]);
			state.Step(sequenceType.length);
			state = ParseSequence(state, sequenceType);
		}
		else if (IsLiteral(state.Source()) || IsExpression(state.Source())) {
			state = ParseExpression(state);
		}
		else {
			var undefinedSrc = state.Peak([]);
			var undefinedNode = new UndefinedNode(undefinedSrc);
			state.curNode.AddChild(undefinedNode);
		}

		// just go to the end now
		while (!state.Done()) {
			state.Step();
		}

		return state;
	}

	function ParseCodeBlock(state) {
		var codeStr = state.ConsumeBlock( Sym.CodeOpen, Sym.CodeClose );
		var codeState = new ParserState(new CodeBlockNode(), codeStr);
		codeState = ParseCode( codeState );
		state.curNode.AddChild( codeState.rootNode );
		return state;
	}

}

} // Script()
</script>

<script>
function Dialog() {

this.CreateRenderer = function() {
	return new DialogRenderer();
};

this.CreateBuffer = function() {
	return new DialogBuffer();
};

var DialogRenderer = function() {

	// TODO : refactor this eventually? remove everything from struct.. avoid the defaults?
	var textboxInfo = {
		img : null,
		width : 104,
		height : 8+4+2+5, //8 for text, 4 for top-bottom padding, 2 for line padding, 5 for arrow
		top : 12,
		left : 12,
		bottom : 12, //for drawing it from the bottom
		font_scale : 0.5, // we draw font at half-size compared to everything else
		padding_vert : 2,
		padding_horz : 4,
		arrow_height : 5,
	};

	var font = null;
	this.SetFont = function(f) {
		font = f;
		textboxInfo.height = (textboxInfo.padding_vert * 3) + (relativeFontHeight() * 2) + textboxInfo.arrow_height;
		textboxInfo.img = context.createImageData(textboxInfo.width*scale, textboxInfo.height*scale);
	}

	function textScale() {
		return scale * textboxInfo.font_scale;
	}

	function relativeFontWidth() {
		return Math.ceil( font.getWidth() * textboxInfo.font_scale );
	}

	function relativeFontHeight() {
		return Math.ceil( font.getHeight() * textboxInfo.font_scale );
	}

	var context = null;
	this.AttachContext = function(c) {
		context = c;
	};

	this.ClearTextbox = function() {
		if(context == null) return;

		//create new image none exists
		if(textboxInfo.img == null)
			textboxInfo.img = context.createImageData(textboxInfo.width*scale, textboxInfo.height*scale);

		// fill text box with black
		for (var i=0;i<textboxInfo.img.data.length;i+=4)
		{
			textboxInfo.img.data[i+0]=0;
			textboxInfo.img.data[i+1]=0;
			textboxInfo.img.data[i+2]=0;
			textboxInfo.img.data[i+3]=255;
		}
	};

	var isCentered = false;
	this.SetCentered = function(centered) {
		isCentered = centered;
	};

	this.DrawTextbox = function() {
		if(context == null) return;
		if (isCentered) {
			context.putImageData(textboxInfo.img, textboxInfo.left*scale, ((height/2)-(textboxInfo.height/2))*scale);
		}
		else if (player().y < mapsize/2) {
			//bottom
			context.putImageData(textboxInfo.img, textboxInfo.left*scale, (height-textboxInfo.bottom-textboxInfo.height)*scale);
		}
		else {
			//top
			context.putImageData(textboxInfo.img, textboxInfo.left*scale, textboxInfo.top*scale);
		}
	};

	var arrowdata = [
		1,1,1,1,1,
		0,1,1,1,0,
		0,0,1,0,0
	];
	this.DrawNextArrow = function() {
		// console.log("draw arrow!");
		var top = (textboxInfo.height-5) * scale;
		var left = (textboxInfo.width-(5+4)) * scale;
		if (textDirection === TextDirection.RightToLeft) { // RTL hack
			left = 4 * scale;
		}

		for (var y = 0; y < 3; y++) {
			for (var x = 0; x < 5; x++) {
				var i = (y * 5) + x;
				if (arrowdata[i] == 1) {
					//scaling nonsense
					for (var sy = 0; sy < scale; sy++) {
						for (var sx = 0; sx < scale; sx++) {
							var pxl = 4 * ( ((top+(y*scale)+sy) * (textboxInfo.width*scale)) + (left+(x*scale)+sx) );
							textboxInfo.img.data[pxl+0] = 255;
							textboxInfo.img.data[pxl+1] = 255;
							textboxInfo.img.data[pxl+2] = 255;
							textboxInfo.img.data[pxl+3] = 255;
						}
					}
				}
			}
		}
	};

	var text_scale = 2; //using a different scaling factor for text feels like cheating... but it looks better
	this.DrawChar = function(char, row, col, leftPos) {
		char.offset = {
			x: char.base_offset.x,
			y: char.base_offset.y
		}; // compute render offset *every* frame

		char.SetPosition(row,col);
		char.ApplyEffects(effectTime);

		var charData = char.bitmap;

		var top = (4 * scale) + (row * 2 * scale) + (row * font.getHeight() * text_scale) + Math.floor( char.offset.y );
		var left = (4 * scale) + (leftPos * text_scale) + Math.floor( char.offset.x );

		var debug_r = Math.random() * 255;

		for (var y = 0; y < char.height; y++) {
			for (var x = 0; x < char.width; x++) {

				var i = (y * char.width) + x;
				if ( charData[i] == 1 ) {

					//scaling nonsense
					for (var sy = 0; sy < text_scale; sy++) {
						for (var sx = 0; sx < text_scale; sx++) {
							var pxl = 4 * ( ((top+(y*text_scale)+sy) * (textboxInfo.width*scale)) + (left+(x*text_scale)+sx) );
							textboxInfo.img.data[pxl+0] = char.color.r;
							textboxInfo.img.data[pxl+1] = char.color.g;
							textboxInfo.img.data[pxl+2] = char.color.b;
							textboxInfo.img.data[pxl+3] = char.color.a;
						}
					}
				}
				// else {
				// 	// DEBUG

				// 	//scaling nonsense
				// 	for (var sy = 0; sy < text_scale; sy++) {
				// 		for (var sx = 0; sx < text_scale; sx++) {
				// 			var pxl = 4 * ( ((top+(y*text_scale)+sy) * (textboxInfo.width*scale)) + (left+(x*text_scale)+sx) );
				// 			textboxInfo.img.data[pxl+0] = debug_r;
				// 			textboxInfo.img.data[pxl+1] = 0;
				// 			textboxInfo.img.data[pxl+2] = 0;
				// 			textboxInfo.img.data[pxl+3] = 255;
				// 		}
				// 	}
				// }

			}
		}
		
		// call printHandler for character
		char.OnPrint();
	};

	var effectTime = 0; // TODO this variable should live somewhere better
	this.Draw = function(buffer, dt) {
		effectTime += dt;

		this.ClearTextbox();

		buffer.ForEachActiveChar(this.DrawChar);

		if (buffer.CanContinue()) {
			this.DrawNextArrow();
		}

		this.DrawTextbox();

		if (buffer.DidPageFinishThisFrame() && onPageFinish != null) {
			onPageFinish();
		}
	};

	/* this is a hook for GIF rendering */
	var onPageFinish = null;
	this.SetPageFinishHandler = function(handler) {
		onPageFinish = handler;
	};

	this.Reset = function() {
		effectTime = 0;
		// TODO - anything else?
	}

	// this.CharsPerRow = function() {
	// 	return textboxInfo.charsPerRow;
	// }
}


var DialogBuffer = function() {
	var buffer = [[[]]]; // holds dialog in an array buffer
	var pageIndex = 0;
	var rowIndex = 0;
	var charIndex = 0;
	var nextCharTimer = 0;
	var nextCharMaxTime = 50; // in milliseconds
	var isDialogReadyToContinue = false;
	var activeTextEffects = [];
	var font = null;
	var arabicHandler = new ArabicHandler();
	var onDialogEndCallbacks = [];

	this.SetFont = function(f) {
		font = f;
	}

	this.CurPage = function() { return buffer[ pageIndex ]; };
	this.CurRow = function() { return this.CurPage()[ rowIndex ]; };
	this.CurChar = function() { return this.CurRow()[ charIndex ]; };
	this.CurPageCount = function() { return buffer.length; };
	this.CurRowCount = function() { return this.CurPage().length; };
	this.CurCharCount = function() { return this.CurRow().length; };

	this.ForEachActiveChar = function(handler) { // Iterates over visible characters on the active page
		var rowCount = rowIndex + 1;
		for (var i = 0; i < rowCount; i++) {
			var row = this.CurPage()[i];
			var charCount = (i == rowIndex) ? charIndex+1 : row.length;
			// console.log(charCount);

			var leftPos = 0;
			if (textDirection === TextDirection.RightToLeft) {
				leftPos = 24 * 8; // hack -- I think this is correct?
			}

			for(var j = 0; j < charCount; j++) {
				var char = row[j];
				if(char) {
					if (textDirection === TextDirection.RightToLeft) {
						leftPos -= char.spacing;
					}
					// console.log(j + " " + leftPos);

					// handler( char, i /*rowIndex*/, j /*colIndex*/ );
					handler(char, i /*rowIndex*/, j /*colIndex*/, leftPos)

					if (textDirection === TextDirection.LeftToRight) {
						leftPos += char.spacing;
					}
				}
			}
		}
	}

	this.Reset = function() {
		buffer = [[[]]];
		pageIndex = 0;
		rowIndex = 0;
		charIndex = 0;
		isDialogReadyToContinue = false;

		afterManualPagebreak = false;

		activeTextEffects = [];

		onDialogEndCallbacks = [];

		isActive = false;
	};

	this.DoNextChar = function() {
		nextCharTimer = 0; //reset timer

		//time to update characters
		if (charIndex + 1 < this.CurCharCount()) {
			//add char to current row
			charIndex++;
		}
		else if (rowIndex + 1 < this.CurRowCount()) {
			//start next row
			rowIndex++;
			charIndex = 0;
		}
		else {
			//the page is full!
			isDialogReadyToContinue = true;
			didPageFinishThisFrame = true;
		}

		if (this.CurChar() != null) {
			if (this.CurChar().isPageBreak) {
				// special case for page break marker character!
				isDialogReadyToContinue = true;
				didPageFinishThisFrame = true;
			}
			
			this.CurChar().OnPrint(); // make sure we hit the callback before we run out of text
		}
	};

	this.Update = function(dt) {
		didPageFinishThisFrame = false;
		didFlipPageThisFrame = false;
		// this.Draw(dt); // TODO move into a renderer object
		if (isDialogReadyToContinue) {
			return; //waiting for dialog to be advanced by player
		}

		nextCharTimer += dt; //tick timer

		if (nextCharTimer > nextCharMaxTime) {
			this.DoNextChar();
		}
	};

	this.Skip = function() {
		console.log("SKIPPP");
		didPageFinishThisFrame = false;
		didFlipPageThisFrame = false;
		// add new characters until you get to the end of the current line of dialog
		while (rowIndex < this.CurRowCount()) {
			this.DoNextChar();

			if(isDialogReadyToContinue) {
				//make sure to push the rowIndex past the end to break out of the loop
				rowIndex++;
				charIndex = 0;
			}
		}
		rowIndex = this.CurRowCount()-1;
		charIndex = this.CurCharCount()-1;
	};

	this.FlipPage = function() {
		didFlipPageThisFrame = true;
		isDialogReadyToContinue = false;
		pageIndex++;
		rowIndex = 0;
		charIndex = 0;
	}

	this.EndDialog = function() {
		isActive = false; // no more text to show... this should be a sign to stop rendering dialog

		for (var i = 0; i < onDialogEndCallbacks.length; i++) {
			onDialogEndCallbacks[i]();
		}
	}

	var afterManualPagebreak = false; // is it bad to track this state like this?

	this.Continue = function() {
		console.log("CONTINUE");

		// if we used a page break character to continue we need
		// to run whatever is in the script afterwards! // TODO : make this comment better
		if (this.CurChar().isPageBreak) {
			// hacky: always treat a page break as the end of dialog
			// if there's more dialog later we re-activate the dialog buffer
			this.EndDialog();
			afterManualPagebreak = true;
			this.CurChar().OnContinue();
			return false;
		}
		if (pageIndex + 1 < this.CurPageCount()) {
			console.log("FLIP PAGE!");
			//start next page
			this.FlipPage();
			return true; /* hasMoreDialog */
		}
		else {
			console.log("END DIALOG!");
			//end dialog mode
			this.EndDialog();
			return false; /* hasMoreDialog */
		}
	};

	var isActive = false;
	this.IsActive = function() { return isActive; };

	this.OnDialogEnd = function(callback) {
		if (!isActive) {
			callback();
		}
		else {
			onDialogEndCallbacks.push(callback);
		}
	}

	this.CanContinue = function() { return isDialogReadyToContinue; };

	function DialogChar(effectList) {
		this.effectList = effectList.slice(); // clone effect list (since it can change between chars)

		this.color = { r:255, g:255, b:255, a:255 };
		this.offset = { x:0, y:0 }; // in pixels (screen pixels?)

		this.col = 0;
		this.row = 0;

		this.SetPosition = function(row,col) {
			// console.log("SET POS");
			// console.log(this);
			this.row = row;
			this.col = col;
		}

		this.ApplyEffects = function(time) {
			// console.log("APPLY EFFECTS! " + time);
			for(var i = 0; i < this.effectList.length; i++) {
				var effectName = this.effectList[i];
				// console.log("FX " + effectName);
				TextEffects[ effectName ].DoEffect( this, time );
			}
		}

		var printHandler = null; // optional function to be called once on printing character
		this.SetPrintHandler = function(handler) {
			printHandler = handler;
		}
		this.OnPrint = function() {
			if (printHandler != null) {
				// console.log("PRINT HANDLER ---- DIALOG BUFFER");
				printHandler();
				printHandler = null; // only call handler once (hacky)
			}
		}

		this.bitmap = [];
		this.width = 0;
		this.height = 0;
		this.base_offset = { // hacky name
 			x: 0,
			y: 0
		};
		this.spacing = 0;
	}

	function DialogFontChar(font, char, effectList) {
		Object.assign(this, new DialogChar(effectList));

		var charData = font.getChar(char);
		this.bitmap = charData.data;
		this.width = charData.width;
		this.height = charData.height;
		this.base_offset.x = charData.offset.x;
		this.base_offset.y = charData.offset.y;
		this.spacing = charData.spacing;
	}

	function DialogDrawingChar(drawingId, effectList) {
		Object.assign(this, new DialogChar(effectList));

		var imageData = renderer.GetImageSource(drawingId)[0];
		var imageDataFlat = [];
		for (var i = 0; i < imageData.length; i++) {
			// console.log(imageData[i]);
			imageDataFlat = imageDataFlat.concat(imageData[i]);
		}

		this.bitmap = imageDataFlat;
		this.width = 8;
		this.height = 8;
		this.spacing = 8;
	}

	function DialogScriptControlChar() {
		Object.assign(this, new DialogChar([]));

		this.width = 0;
		this.height = 0;
		this.spacing = 0;
	}

	// is a control character really the best way to handle page breaks?
	function DialogPageBreakChar() {
		Object.assign(this, new DialogChar([]));

		this.width = 0;
		this.height = 0;
		this.spacing = 0;

		this.isPageBreak = true;

		var continueHandler = null;

		this.SetContinueHandler = function(handler) {
			continueHandler = handler;
		}

		this.OnContinue = function() {
			if (continueHandler) {
				continueHandler();
			}
		}
	}

	function AddWordToCharArray(charArray,word,effectList) {
		for(var i = 0; i < word.length; i++) {
			charArray.push( new DialogFontChar( font, word[i], effectList ) );
		}
		return charArray;
	}

	function GetCharArrayWidth(charArray) {
		var width = 0;
		for(var i = 0; i < charArray.length; i++) {
			width += charArray[i].spacing;
		}
		return width;
	}

	function GetStringWidth(str) {
		var width = 0;
		for (var i = 0; i < str.length; i++) {
			var charData = font.getChar(str[i]);
			width += charData.spacing;
		}
		return width;
	}

	var pixelsPerRow = 192; // hard-coded fun times!!!

	this.AddScriptReturn = function(onReturnHandler) {
		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		var controlChar = new DialogScriptControlChar();
		controlChar.SetPrintHandler(onReturnHandler);

		curRowArr.push(controlChar);

		isActive = true;
	}

	this.AddDrawing = function(drawingId) {
		// console.log("DRAWING ID " + drawingId);

		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		var drawingChar = new DialogDrawingChar(drawingId, activeTextEffects);

		var rowLength = GetCharArrayWidth(curRowArr);

		// TODO : clean up copy-pasted code here :/
		if (afterManualPagebreak) {
			this.FlipPage(); // hacky

			buffer[curPageIndex][curRowIndex] = curRowArr;
			buffer.push([]);
			curPageIndex++;
			buffer[curPageIndex].push([]);
			curRowIndex = 0;
			curRowArr = buffer[curPageIndex][curRowIndex];
			curRowArr.push(drawingChar);

			afterManualPagebreak = false;
		}
		else if (rowLength + drawingChar.spacing  <= pixelsPerRow || rowLength <= 0) {
			//stay on same row
			curRowArr.push(drawingChar);
		}
		else if (curRowIndex == 0) {
			//start next row
			buffer[curPageIndex][curRowIndex] = curRowArr;
			buffer[curPageIndex].push([]);
			curRowIndex++;
			curRowArr = buffer[curPageIndex][curRowIndex];
			curRowArr.push(drawingChar);
		}
		else {
			//start next page
			buffer[curPageIndex][curRowIndex] = curRowArr;
			buffer.push([]);
			curPageIndex++;
			buffer[curPageIndex].push([]);
			curRowIndex = 0;
			curRowArr = buffer[curPageIndex][curRowIndex];
			curRowArr.push(drawingChar);
		}

		isActive = true; // this feels like a bad way to do this???
	}

	// TODO : convert this into something that takes DialogChar arrays
	this.AddText = function(textStr) {
		console.log("ADD TEXT " + textStr);

		//process dialog so it's easier to display
		var words = textStr.split(" ");

		// var curPageIndex = this.CurPageCount() - 1;
		// var curRowIndex = this.CurRowCount() - 1;
		// var curRowArr = this.CurRow();

		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		for (var i = 0; i < words.length; i++) {
			var word = words[i];
			if (arabicHandler.ContainsArabicCharacters(word)) {
				word = arabicHandler.ShapeArabicCharacters(word);
			}

			var wordWithPrecedingSpace = ((i == 0) ? "" : " ") + word;
			var wordLength = GetStringWidth(wordWithPrecedingSpace);

			var rowLength = GetCharArrayWidth(curRowArr);

			if (afterManualPagebreak) {
				this.FlipPage();

				// hacky copied bit for page breaks
				buffer[curPageIndex][curRowIndex] = curRowArr;
				buffer.push([]);
				curPageIndex++;
				buffer[curPageIndex].push([]);
				curRowIndex = 0;
				curRowArr = buffer[curPageIndex][curRowIndex];
				curRowArr = AddWordToCharArray(curRowArr, word, activeTextEffects);

				afterManualPagebreak = false;
			}
			else if (rowLength + wordLength <= pixelsPerRow || rowLength <= 0) {
				//stay on same row
				curRowArr = AddWordToCharArray(curRowArr, wordWithPrecedingSpace, activeTextEffects);
			}
			else if (curRowIndex == 0) {
				//start next row
				buffer[curPageIndex][curRowIndex] = curRowArr;
				buffer[curPageIndex].push([]);
				curRowIndex++;
				curRowArr = buffer[curPageIndex][curRowIndex];
				curRowArr = AddWordToCharArray(curRowArr, word, activeTextEffects);
			}
			else {
				//start next page
				buffer[curPageIndex][curRowIndex] = curRowArr;
				buffer.push([]);
				curPageIndex++;
				buffer[curPageIndex].push([]);
				curRowIndex = 0;
				curRowArr = buffer[curPageIndex][curRowIndex];
				curRowArr = AddWordToCharArray(curRowArr, word, activeTextEffects);
			}
		}

		//destroy any empty stuff
		var lastPage = buffer[buffer.length-1];
		var lastRow = lastPage[lastPage.length-1];
		if (lastRow.length == 0) {
			lastPage.splice(lastPage.length-1, 1);
		}
		if (lastPage.length == 0) {
			buffer.splice(buffer.length-1, 1);
		}

		//finish up 
		lastPage = buffer[buffer.length-1];
		lastRow = lastPage[lastPage.length-1];
		if (lastRow.length > 0) {
			var lastChar = lastRow[lastRow.length-1];
		}

		// console.log(buffer);

		isActive = true;
	};

	this.AddLinebreak = function() {
		var lastPage = buffer[buffer.length-1];
		if (lastPage.length <= 1) {
			// console.log("LINEBREAK - NEW ROW ");
			// add new row
			lastPage.push([]);
		}
		else {
			// add new page
			buffer.push([[]]);
		}
		// console.log(buffer);

		isActive = true;
	}

	this.AddPagebreak = function(onReturnHandler) {
		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		// need to actually create a whole new page if following another pagebreak character
		if (this.CurChar() && this.CurChar().isPageBreak) {
			buffer.push([]);
			curPageIndex++;
			buffer[curPageIndex].push([]);
			curRowIndex = 0;
			curRowArr = buffer[curPageIndex][curRowIndex];
		}

		var pagebreakChar = new DialogPageBreakChar();
		pagebreakChar.SetContinueHandler(onReturnHandler);

		curRowArr.push(pagebreakChar);

		isActive = true;		
	}

	/* new text effects */
	this.HasTextEffect = function(name) {
		return activeTextEffects.indexOf( name ) > -1;
	}
	this.AddTextEffect = function(name) {
		activeTextEffects.push( name );
	}
	this.RemoveTextEffect = function(name) {
		activeTextEffects.splice( activeTextEffects.indexOf( name ), 1 );
	}

	/* this is a hook for GIF rendering */
	var didPageFinishThisFrame = false;
	this.DidPageFinishThisFrame = function(){ return didPageFinishThisFrame; };

	var didFlipPageThisFrame = false;
	this.DidFlipPageThisFrame = function(){ return didFlipPageThisFrame; };

	// this.SetCharsPerRow = function(num){ charsPerRow = num; }; // hacky
};

/* ARABIC */
var ArabicHandler = function() {

	var arabicCharStart = 0x0621;
	var arabicCharEnd = 0x064E;

	var CharacterForm = {
		Isolated : 0,
		Final : 1,
		Initial : 2,
		Middle : 3
	};

	// map glyphs to their character forms
	var glyphForms = {
		/*		 Isolated, Final, Initial, Middle Forms	*/
		0x0621: [0xFE80,0xFE80,0xFE80,0xFE80], /*  HAMZA  */ 
		0x0622: [0xFE81,0xFE82,0xFE81,0xFE82], /*  ALEF WITH MADDA ABOVE  */ 
		0x0623: [0xFE83,0xFE84,0xFE83,0xFE84], /*  ALEF WITH HAMZA ABOVE  */ 
		0x0624: [0xFE85,0xFE86,0xFE85,0xFE86], /*  WAW WITH HAMZA ABOVE  */ 
		0x0625: [0xFE87,0xFE88,0xFE87,0xFE88], /*  ALEF WITH HAMZA BELOW  */ 
		0x0626: [0xFE89,0xFE8A,0xFE8B,0xFE8C], /*  YEH WITH HAMZA ABOVE  */ 
		0x0627: [0xFE8D,0xFE8E,0xFE8D,0xFE8E], /*  ALEF  */ 
		0x0628: [0xFE8F,0xFE90,0xFE91,0xFE92], /*  BEH  */ 
		0x0629: [0xFE93,0xFE94,0xFE93,0xFE94], /*  TEH MARBUTA  */ 
		0x062A: [0xFE95,0xFE96,0xFE97,0xFE98], /*  TEH  */ 
		0x062B: [0xFE99,0xFE9A,0xFE9B,0xFE9C], /*  THEH  */ 
		0x062C: [0xFE9D,0xFE9E,0xFE9F,0xFEA0], /*  JEEM  */ 
		0x062D: [0xFEA1,0xFEA2,0xFEA3,0xFEA4], /*  HAH  */ 
		0x062E: [0xFEA5,0xFEA6,0xFEA7,0xFEA8], /*  KHAH  */ 
		0x062F: [0xFEA9,0xFEAA,0xFEA9,0xFEAA], /*  DAL  */ 
		0x0630: [0xFEAB,0xFEAC,0xFEAB,0xFEAC], /*  THAL */ 
		0x0631: [0xFEAD,0xFEAE,0xFEAD,0xFEAE], /*  RAA  */ 
		0x0632: [0xFEAF,0xFEB0,0xFEAF,0xFEB0], /*  ZAIN  */ 
		0x0633: [0xFEB1,0xFEB2,0xFEB3,0xFEB4], /*  SEEN  */ 
		0x0634: [0xFEB5,0xFEB6,0xFEB7,0xFEB8], /*  SHEEN  */ 
		0x0635: [0xFEB9,0xFEBA,0xFEBB,0xFEBC], /*  SAD  */ 
		0x0636: [0xFEBD,0xFEBE,0xFEBF,0xFEC0], /*  DAD  */ 
		0x0637: [0xFEC1,0xFEC2,0xFEC3,0xFEC4], /*  TAH  */ 
		0x0638: [0xFEC5,0xFEC6,0xFEC7,0xFEC8], /*  ZAH  */ 
		0x0639: [0xFEC9,0xFECA,0xFECB,0xFECC], /*  AIN  */ 
		0x063A: [0xFECD,0xFECE,0xFECF,0xFED0], /*  GHAIN  */ 
		0x063B: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063C: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063D: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063E: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063F: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x0640: [0x0640,0x0640,0x0640,0x0640], /*  TATWEEL  */ 
		0x0641: [0xFED1,0xFED2,0xFED3,0xFED4], /*  FAA  */ 
		0x0642: [0xFED5,0xFED6,0xFED7,0xFED8], /*  QAF  */ 
		0x0643: [0xFED9,0xFEDA,0xFEDB,0xFEDC], /*  KAF  */ 
		0x0644: [0xFEDD,0xFEDE,0xFEDF,0xFEE0], /*  LAM  */ 
		0x0645: [0xFEE1,0xFEE2,0xFEE3,0xFEE4], /*  MEEM  */ 
		0x0646: [0xFEE5,0xFEE6,0xFEE7,0xFEE8], /*  NOON  */ 
		0x0647: [0xFEE9,0xFEEA,0xFEEB,0xFEEC], /*  HEH  */ 
		0x0648: [0xFEED,0xFEEE,0xFEED,0xFEEE], /*  WAW  */ 
		0x0649: [0xFEEF,0xFEF0,0xFBE8,0xFBE9], /*  ALEF MAKSURA  */ 
		0x064A: [0xFEF1,0xFEF2,0xFEF3,0xFEF4], /*  YEH  */ 
		0x064B: [0xFEF5,0xFEF6,0xFEF5,0xFEF6], /*  LAM ALEF MADD*/
		0x064C: [0xFEF7,0xFEF8,0xFEF7,0xFEF8], /*  LAM ALEF HAMZA ABOVE*/
		0x064D: [0xFEF9,0xFEFa,0xFEF9,0xFEFa], /*  LAM ALEF HAMZA BELOW*/
		0x064E: [0xFEFb,0xFEFc,0xFEFb,0xFEFc], /*  LAM ALEF */
	};

	var disconnectedCharacters = [0x0621,0x0622,0x0623,0x0624,0x0625,0x0627,0x062f,0x0630,0x0631,0x0632,0x0648,0x0649,0x064b,0x064c,0x064d,0x064e];

	function IsArabicCharacter(char) {
		var code = char.charCodeAt(0);
		return (code >= arabicCharStart && code <= arabicCharEnd);
	}

	function ContainsArabicCharacters(word) {
		for (var i = 0; i < word.length; i++) {
			if (IsArabicCharacter(word[i])) {
				return true;
			}
		}
		return false;
	}

	function IsDisconnectedCharacter(char) {
		var code = char.charCodeAt(0);
		return disconnectedCharacters.indexOf(code) != -1;
	}

	function ShapeArabicCharacters(word) {
		var shapedWord = "";

		for (var i = 0; i < word.length; i++) {
			if (!IsArabicCharacter(word[i])) {
				shapedWord += word[i];
				continue;
			}

			var connectedToPreviousChar = i-1 >= 0 && IsArabicCharacter(word[i-1]) && !IsDisconnectedCharacter(word[i-1]);

			var connectedToNextChar = i+1 < word.length && IsArabicCharacter(word[i+1]) && !IsDisconnectedCharacter(word[i]);

			var form;
			if (!connectedToPreviousChar && !connectedToNextChar) {
				form = CharacterForm.Isolated;
			}
			else if (connectedToPreviousChar && !connectedToNextChar) {
				form = CharacterForm.Final;
			}
			else if (!connectedToPreviousChar && connectedToNextChar) {
				form = CharacterForm.Initial;
			}
			else if (connectedToPreviousChar && connectedToNextChar) {
				form = CharacterForm.Middle;
			}

			var code = word[i].charCodeAt(0);

			// handle lam alef special case
			if (code == 0x0644 && connectedToNextChar) {
				var nextCode = word[i+1].charCodeAt(0);
				var specialCode = null;
				if (nextCode == 0x0622) {
					// alef madd
					specialCode = glyphForms[0x064b][form];
				}
				else if (nextCode == 0x0623) {
					// hamza above
					specialCode = glyphForms[0x064c][form];
				}
				else if (nextCode == 0x0625) {
					// hamza below
					specialCode = glyphForms[0x064d][form];
				}
				else if (nextCode == 0x0627) {
					// alef
					specialCode = glyphForms[0x064e][form];
				}

				if (specialCode != null) {
					shapedWord += String.fromCharCode(specialCode);
					i++; // skip a step
					continue;
				}
			}

			// hacky?
			if (form === CharacterForm.Isolated) {
				shapedWord += word[i];
				continue;
			}

			var shapedCode = glyphForms[code][form];
			shapedWord += String.fromCharCode(shapedCode);
		}

		return shapedWord;
	}

	this.ContainsArabicCharacters = ContainsArabicCharacters;
	this.ShapeArabicCharacters = ShapeArabicCharacters;
}

/* NEW TEXT EFFECTS */
var TextEffects = new Map();

var RainbowEffect = function() { // TODO - should it be an object or just a method?
	this.DoEffect = function(char,time) {
		// console.log("RAINBOW!!!");
		// console.log(char);
		// console.log(char.color);
		// console.log(char.col);

		var h = Math.abs( Math.sin( (time / 600) - (char.col / 8) ) );
		var rgb = hslToRgb( h, 1, 0.5 );
		char.color.r = rgb[0];
		char.color.g = rgb[1];
		char.color.b = rgb[2];
		char.color.a = 255;
	}
};
TextEffects["rbw"] = new RainbowEffect();

var ColorEffect = function(index) {
	this.DoEffect = function(char) {
		var pal = getPal( curPal() );
		var color = pal[ parseInt( index ) ];
		// console.log(color);
		char.color.r = color[0];
		char.color.g = color[1];
		char.color.b = color[2];
		char.color.a = 255;
	}
};
TextEffects["clr1"] = new ColorEffect(0);
TextEffects["clr2"] = new ColorEffect(1); // TODO : should I use parameters instead of special names?
TextEffects["clr3"] = new ColorEffect(2);

var WavyEffect = function() {
	this.DoEffect = function(char,time) {
		char.offset.y += Math.sin( (time / 250) - (char.col / 2) ) * 4;
	}
};
TextEffects["wvy"] = new WavyEffect();

var ShakyEffect = function() {
	function disturb(func,time,offset,mult1,mult2) {
		return func( (time * mult1) - (offset * mult2) );
	}

	this.DoEffect = function(char,time) {
		char.offset.y += 3
						* disturb(Math.sin,time,char.col,0.1,0.5)
						* disturb(Math.cos,time,char.col,0.3,0.2)
						* disturb(Math.sin,time,char.row,2.0,1.0);
		char.offset.x += 3
						* disturb(Math.cos,time,char.row,0.1,1.0)
						* disturb(Math.sin,time,char.col,3.0,0.7)
						* disturb(Math.cos,time,char.col,0.2,0.3);
	}
};
TextEffects["shk"] = new ShakyEffect();

var DebugHighlightEffect = function() {
	this.DoEffect = function(char) {
		char.color.r = 255;
		char.color.g = 255;
		char.color.b = 0;
		char.color.a = 255;
	}
}
TextEffects["_debug_highlight"] = new DebugHighlightEffect();

} // Dialog()
</script>

<script>
/*
TODO
- reset renderer function
- react to changes in: drawings, palettes
- possible future plan: limit size of cache (remove old images)
- change image store path from (pal > col > draw) to (draw > pal > col)
- get rid of old getSpriteImage (etc) methods
- get editor working again [in progress]
- move debug timer class into core (seems useful)
*/

function Renderer(tilesize, scale) {

console.log("!!!!! NEW RENDERER");

var imageStore = { // TODO : rename to imageCache
	source: {},
	render: {}
};

var palettes = null; // TODO : need null checks?
var context = null;

function setPalettes(paletteObj) {
	palettes = paletteObj;

	// TODO : should this really clear out the render cache?
	imageStore.render = {};
}

function getPaletteColor(paletteId, colorIndex) {
	if (palettes[paletteId] === undefined) {
		paletteId = "default";
	}

	var palette = palettes[paletteId];

	if (colorIndex > palette.colors.length) { // do I need this failure case? (seems un-reliable)
		colorIndex = 0;
	}

	var color = palette.colors[colorIndex];

	return {
		r : color[0],
		g : color[1],
		b : color[2]
	};
}

var debugRenderCount = 0;

// TODO : change image store path from (pal > col > draw) to (draw > pal > col)
function renderImage(drawing, paletteId) {
	// debugRenderCount++;
	// console.log("RENDER COUNT " + debugRenderCount);

	var col = drawing.col;
	var colStr = "" + col;
	var pal = paletteId;
	var drwId = drawing.drw;
	var imgSrc = imageStore.source[ drawing.drw ];

	// initialize render cache entry
	if (imageStore.render[drwId] === undefined || imageStore.render[drwId] === null) {
		imageStore.render[drwId] = {};
	}

	if (imageStore.render[drwId][pal] === undefined || imageStore.render[drwId][pal] === null) {
		imageStore.render[drwId][pal] = {};
	}

	// create array of ImageData frames
	imageStore.render[drwId][pal][colStr] = [];

	for (var i = 0; i < imgSrc.length; i++) {
		var frameSrc = imgSrc[i];
		var frameData = imageDataFromImageSource( frameSrc, pal, col );
		imageStore.render[drwId][pal][colStr].push(frameData);
	}
}

function imageDataFromImageSource(imageSource, pal, col) {
	//console.log(imageSource);

	var img = context.createImageData(tilesize*scale,tilesize*scale);

	var backgroundColor = getPaletteColor(pal,0);
	var foregroundColor = getPaletteColor(pal,col);

	for (var y = 0; y < tilesize; y++) {
		for (var x = 0; x < tilesize; x++) {
			var px = imageSource[y][x];
			for (var sy = 0; sy < scale; sy++) {
				for (var sx = 0; sx < scale; sx++) {
					var pxl = (((y * scale) + sy) * tilesize * scale * 4) + (((x*scale) + sx) * 4);
					if ( px === 1 ) {
						img.data[pxl + 0] = foregroundColor.r;
						img.data[pxl + 1] = foregroundColor.g;
						img.data[pxl + 2] = foregroundColor.b;
						img.data[pxl + 3] = 255;
					}
					else { //ch === 0
						img.data[pxl + 0] = backgroundColor.r;
						img.data[pxl + 1] = backgroundColor.g;
						img.data[pxl + 2] = backgroundColor.b;
						img.data[pxl + 3] = 255;
					}
				}
			}
		}
	}

	// convert to canvas: chrome has poor performance when working directly with image data
	var imageCanvas = document.createElement("canvas");
	imageCanvas.width = img.width;
	imageCanvas.height = img.height;
	var imageContext = imageCanvas.getContext("2d");
	imageContext.putImageData(img,0,0);

	return imageCanvas;
}

// TODO : move into core
function undefinedOrNull(x) {
	return x === undefined || x === null;
}

function isImageRendered(drawing, paletteId) {
	var col = drawing.col;
	var colStr = "" + col;
	var pal = paletteId;
	var drwId = drawing.drw;

	if (undefinedOrNull(imageStore.render[drwId]) ||
		undefinedOrNull(imageStore.render[drwId][pal]) ||
		undefinedOrNull(imageStore.render[drwId][pal][colStr])) {
			return false;
	}
	else {
		return true;
	}
}

function getImageSet(drawing, paletteId) {
	return imageStore.render[drawing.drw][paletteId][drawing.col];
}

function getImageFrame(drawing, paletteId, frameOverride) {
	var frameIndex = 0;
	if (drawing.animation.isAnimated) {
		if (frameOverride != undefined && frameOverride != null) {
			frameIndex = frameOverride;
		}
		else {
			frameIndex = drawing.animation.frameIndex;
		}
	}

	return getImageSet(drawing, paletteId)[frameIndex];
}

function getOrRenderImage(drawing, paletteId, frameOverride) {
	if (!isImageRendered(drawing, paletteId)) {
		renderImage(drawing, paletteId);
	}

	return getImageFrame(drawing, paletteId, frameOverride);
}

/* PUBLIC INTERFACE */
this.GetImage = getOrRenderImage;

this.SetPalettes = setPalettes;

this.SetImageSource = function(drawingId, imageSourceData) {
	imageStore.source[drawingId] = imageSourceData;
	imageStore.render[drawingId] = {}; // reset render cache for this image
}

this.GetImageSource = function(drawingId) {
	return imageStore.source[drawingId];
}

this.GetFrameCount = function(drawingId) {
	return imageStore.source[drawingId].length;
}

this.AttachContext = function(ctx) {
	context = ctx;
}

} // Renderer()
</script>

<script>
var xhr; // TODO : remove
var canvas;
var context; // TODO : remove if safe?
var ctx;

var room = {};
var tile = {};
var sprite = {};
var item = {};
var dialog = {};
var palette = { //start off with a default palette
		"default" : {
			name : "default",
			colors : [[0,0,0],[255,255,255],[255,255,255]]
		}
	};
var variable = {}; // these are starting variable values -- they don't update (or I don't think they will)
var playerId = "A";

var titleDialogId = "title";
function getTitle() {
	return dialog[titleDialogId].src;
}
function setTitle(titleSrc) {
	dialog[titleDialogId] = { src:titleSrc, name:null };
}

var defaultFontName = "ascii_small";
var fontName = defaultFontName;
var TextDirection = {
	LeftToRight : "LTR",
	RightToLeft : "RTL"
};
var textDirection = TextDirection.LeftToRight;

var names = {
	room : new Map(),
	tile : new Map(), // Note: Not currently enabled in the UI
	sprite : new Map(),
	item : new Map(),
	dialog : new Map(),
};
function updateNamesFromCurData() {

	function createNameMap(objectStore) {
		var map = new Map();
		for (id in objectStore) {
			if (objectStore[id].name != undefined && objectStore[id].name != null) {
				map.set(objectStore[id].name, id);
			}
		}
		return map;
	}

	names.room = createNameMap(room);
	names.tile = createNameMap(tile);
	names.sprite = createNameMap(sprite);
	names.item = createNameMap(item);
	names.dialog = createNameMap(dialog);
}

var spriteStartLocations = {};

/* VERSION */
var version = {
	major: 7, // major changes
	minor: 2, // smaller changes
	devBuildPhase: "RELEASE",
};
function getEngineVersion() {
	return version.major + "." + version.minor;
}

/* FLAGS */
var flags;
function resetFlags() {
	flags = {
		ROOM_FORMAT : 0 // 0 = non-comma separated, 1 = comma separated
	};
}
resetFlags(); //init flags on load script

// SUPER hacky location... :/
var editorDevFlags = {
	// NONE right now!
};

function clearGameData() {
	room = {};
	tile = {};
	sprite = {};
	item = {};
	dialog = {};
	palette = { //start off with a default palette
		"default" : {
			name : "default",
			colors : [[0,0,0],[255,255,255],[255,255,255]]
		}
	};
	isEnding = false; //todo - correct place for this?
	variable = {};

	// TODO RENDERER : clear data?

	spriteStartLocations = {};

	// hacky to have this multiple times...
	names = {
		room : new Map(),
		tile : new Map(),
		sprite : new Map(),
		item : new Map(),
		dialog : new Map(),
	};

	fontName = defaultFontName; // TODO : reset font manager too?
	textDirection = TextDirection.LeftToRight;
}

var width = 128;
var height = 128;
var scale = 4; //this is stupid but necessary
var tilesize = 8;
var mapsize = 16;

var curRoom = "0";

var key = {
	left : 37,
	right : 39,
	up : 38,
	down : 40,
	space : 32,
	enter : 13,
	w : 87,
	a : 65,
	s : 83,
	d : 68,
	r : 82,
	shift : 16,
	ctrl : 17,
	alt : 18,
	cmd : 224
};

var prevTime = 0;
var deltaTime = 0;

//inventory update UI handles
var onInventoryChanged = null;
var onVariableChanged = null;
var onGameReset = null;

var isPlayerEmbeddedInEditor = false;

var renderer = new Renderer(tilesize, scale);

function getGameNameFromURL() {
	var game = window.location.hash.substring(1);
	// console.log("game name --- " + game);
	return game;
}

function attachCanvas(c) {
	canvas = c;
	canvas.width = width * scale;
	canvas.height = width * scale;
	ctx = canvas.getContext("2d");
	dialogRenderer.AttachContext(ctx);
	renderer.AttachContext(ctx);
}

var curGameData = null;
function load_game(game_data, startWithTitle) {
	curGameData = game_data; //remember the current game (used to reset the game)

	dialogBuffer.Reset();
	scriptInterpreter.ResetEnvironment(); // ensures variables are reset -- is this the best way?

	parseWorld(game_data);

	if (!isPlayerEmbeddedInEditor) {
		// hack to ensure default font is available
		fontManager.AddResource(defaultFontName + fontManager.GetExtension(), document.getElementById(defaultFontName).text.slice(1));
	}

	var font = fontManager.Get( fontName );
	dialogBuffer.SetFont(font);
	dialogRenderer.SetFont(font);

	setInitialVariables();

	// setInterval(updateLoadingScreen, 300); // hack test

	onready(startWithTitle);
}

function reset_cur_game() {
	if (curGameData == null) {
		return; //can't reset if we don't have the game data
	}

	stopGame();
	clearGameData();
	load_game(curGameData);

	if (isPlayerEmbeddedInEditor && onGameReset != null) {
		onGameReset();
	}
}

var update_interval = null;
function onready(startWithTitle) {
	if(startWithTitle === undefined || startWithTitle === null) startWithTitle = true;

	clearInterval(loading_interval);

	input = new InputManager();

	document.addEventListener('keydown', input.onkeydown);
	document.addEventListener('keyup', input.onkeyup);

	if (isPlayerEmbeddedInEditor) {
		canvas.addEventListener('touchstart', input.ontouchstart, {passive:false});
		canvas.addEventListener('touchmove', input.ontouchmove, {passive:false});
		canvas.addEventListener('touchend', input.ontouchend, {passive:false});
	}
	else {
		// creates a 'touchTrigger' element that covers the entire screen and can universally have touch event listeners added w/o issue.

		// we're checking for existing touchTriggers both at game start and end, so it's slightly redundant.
	  	var existingTouchTrigger = document.querySelector('#touchTrigger');
	  	if (existingTouchTrigger === null){
	  	  var touchTrigger = document.createElement("div");
	  	  touchTrigger.setAttribute("id","touchTrigger");

	  	  // afaik css in js is necessary here to force a fullscreen element
	  	  touchTrigger.setAttribute(
	  	    "style","position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; overflow: hidden;"
	  	  );
	  	  document.body.appendChild(touchTrigger);

	  	  touchTrigger.addEventListener('touchstart', input.ontouchstart);
	  	  touchTrigger.addEventListener('touchmove', input.ontouchmove);
	  	  touchTrigger.addEventListener('touchend', input.ontouchend);
	  	}
	}

	window.onblur = input.onblur;

	update_interval = setInterval(update,16);

	if(startWithTitle) { // used by editor 
		startNarrating(getTitle());
	}
}

function setInitialVariables() {
	for(id in variable) {
		var value = variable[id]; // default to string
		if(value === "true") {
			value = true;
		}
		else if(value === "false") {
			value = false;
		}
		else if(!isNaN(parseFloat(value))) {
			value = parseFloat(value);
		}
		scriptInterpreter.SetVariable(id,value);
	}
	scriptInterpreter.SetOnVariableChangeHandler( onVariableChanged );
}

function getOffset(evt) {
	var offset = { x:0, y:0 };

	var el = evt.target;
	var rect = el.getBoundingClientRect();

	offset.x += rect.left + el.scrollLeft;
	offset.y += rect.top + el.scrollTop;

	offset.x = evt.clientX - offset.x;
	offset.y = evt.clientY - offset.y;

	return offset;
}

function stopGame() {
	console.log("stop GAME!");

	document.removeEventListener('keydown', input.onkeydown);
	document.removeEventListener('keyup', input.onkeyup);

	if (isPlayerEmbeddedInEditor) {
		canvas.removeEventListener('touchstart', input.ontouchstart);
		canvas.removeEventListener('touchmove', input.ontouchmove);
		canvas.removeEventListener('touchend', input.ontouchend);
	}
	else {
		//check for touchTrigger and removes it

    		var existingTouchTrigger = document.querySelector('#touchTrigger');
    		if (existingTouchTrigger !== null){
    			existingTouchTrigger.removeEventListener('touchstart', input.ontouchstart);
    			existingTouchTrigger.removeEventListener('touchmove', input.ontouchmove);
    			existingTouchTrigger.removeEventListener('touchend', input.ontouchend);

    			existingTouchTrigger.parentElement.removeChild(existingTouchTrigger);
    		}
	}

	window.onblur = null;

	clearInterval(update_interval);
}

/* loading animation */
var loading_anim_data = [
	[
		0,1,1,1,1,1,1,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,0,0,1,0,0,
		0,0,1,0,0,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,1,1,1,1,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,1,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,0,0,1,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,1,1,1,1,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,0,0,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,1,1,1,1,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,0,0,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,0,0,0,0,0,0,0,
		1,0,0,0,0,0,0,1,
		1,1,1,0,0,1,1,1,
		1,1,1,1,1,0,0,1,
		1,1,1,1,1,0,0,1,
		1,1,1,0,0,1,1,1,
		1,0,0,0,0,0,0,1,
		0,0,0,0,0,0,0,0,
	]
];
var loading_anim_frame = 0;
var loading_anim_speed = 500;
var loading_interval = null;

function loadingAnimation() {
	//create image
	var loadingAnimImg = ctx.createImageData(8*scale, 8*scale);
	//draw image
	for (var y = 0; y < 8; y++) {
		for (var x = 0; x < 8; x++) {
			var i = (y * 8) + x;
			if (loading_anim_data[loading_anim_frame][i] == 1) {
				//scaling nonsense
				for (var sy = 0; sy < scale; sy++) {
					for (var sx = 0; sx < scale; sx++) {
						var pxl = 4 * ( (((y*scale)+sy) * (8*scale)) + ((x*scale)+sx) );
						loadingAnimImg.data[pxl+0] = 255;
						loadingAnimImg.data[pxl+1] = 255;
						loadingAnimImg.data[pxl+2] = 255;
						loadingAnimImg.data[pxl+3] = 255;
					}
				}
			}
		}
	}
	//put image on canvas
	ctx.putImageData(loadingAnimImg,scale*(width/2 - 4),scale*(height/2 - 4));
	//update frame
	loading_anim_frame++;
	if (loading_anim_frame >= 5) loading_anim_frame = 0;
}

function updateLoadingScreen() {
	// TODO : in progress
	ctx.fillStyle = "rgb(0,0,0)";
	ctx.fillRect(0,0,canvas.width,canvas.height);

	loadingAnimation();
	drawSprite( getSpriteImage(sprite["a"],"0",0), 8, 8, ctx );
}

function update() {
	var curTime = Date.now();
	deltaTime = curTime - prevTime;

	if (curRoom == null) {
		// in the special case where there is no valid room, end the game
		startNarrating( "", true /*isEnding*/ );
	}

	if (!transition.IsTransitionActive()) {
		updateInput();
	}

	if (transition.IsTransitionActive()) {
		// transition animation takes over everything!
		transition.UpdateTransition(deltaTime);
	}
	else {
		if (!isNarrating && !isEnding) {
			updateAnimation();
			drawRoom( room[curRoom] ); // draw world if game has begun
		}
		else {
			//make sure to still clear screen
			ctx.fillStyle = "rgb(" + getPal(curPal())[0][0] + "," + getPal(curPal())[0][1] + "," + getPal(curPal())[0][2] + ")";
			ctx.fillRect(0,0,canvas.width,canvas.height);
		}

		// if (isDialogMode) { // dialog mode
		if(dialogBuffer.IsActive()) {
			dialogRenderer.Draw( dialogBuffer, deltaTime );
			dialogBuffer.Update( deltaTime );
		}

		// keep moving avatar if player holds down button
		if( !dialogBuffer.IsActive() && !isEnding )
		{
			if( curPlayerDirection != Direction.None ) {
				playerHoldToMoveTimer -= deltaTime;

				if( playerHoldToMoveTimer <= 0 )
				{
					movePlayer( curPlayerDirection );
					playerHoldToMoveTimer = 150;
				}
			}
		}
	}

	prevTime = curTime;

	input.resetKeyPressed();
	input.resetTapReleased();
}

function updateInput() {
	if( dialogBuffer.IsActive() ) {
		if (input.anyKeyPressed() || input.isTapReleased()) {
			/* CONTINUE DIALOG */
			if (dialogBuffer.CanContinue()) {
				var hasMoreDialog = dialogBuffer.Continue();
				if(!hasMoreDialog) {
					// ignore currently held keys UNTIL they are released (stops player from insta-moving)
					input.ignoreHeldKeys();
				}
			}
			else {
				dialogBuffer.Skip();
			}
		}
	}
	else if ( isEnding ) {
		if (input.anyKeyPressed() || input.isTapReleased()) {
			/* RESTART GAME */
			reset_cur_game();
		}
	}
	else {
		/* WALK */
		var prevPlayerDirection = curPlayerDirection;

		if ( input.isKeyDown( key.left ) || input.isKeyDown( key.a ) || input.swipeLeft() ) {
			curPlayerDirection = Direction.Left;
		}
		else if ( input.isKeyDown( key.right ) || input.isKeyDown( key.d ) || input.swipeRight() ) {
			curPlayerDirection = Direction.Right;
		}
		else if ( input.isKeyDown( key.up ) || input.isKeyDown( key.w ) || input.swipeUp() ) {
			curPlayerDirection = Direction.Up;
		}
		else if ( input.isKeyDown( key.down ) || input.isKeyDown( key.s ) || input.swipeDown() ) {
			curPlayerDirection = Direction.Down;
		}
		else {
			curPlayerDirection = Direction.None;
		}

		if (curPlayerDirection != Direction.None && curPlayerDirection != prevPlayerDirection) {
			movePlayer( curPlayerDirection );
			playerHoldToMoveTimer = 500;
		}
	}
}

var animationCounter = 0;
var animationTime = 400;
function updateAnimation() {
	animationCounter += deltaTime;

	if ( animationCounter >= animationTime ) {

		// animate sprites
		for (id in sprite) {
			var spr = sprite[id];
			if (spr.animation.isAnimated) {
				spr.animation.frameIndex = ( spr.animation.frameIndex + 1 ) % spr.animation.frameCount;
			}
		}

		// animate tiles
		for (id in tile) {
			var til = tile[id];
			if (til.animation.isAnimated) {
				til.animation.frameIndex = ( til.animation.frameIndex + 1 ) % til.animation.frameCount;
			}
		}

		// animate items
		for (id in item) {
			var itm = item[id];
			if (itm.animation.isAnimated) {
				itm.animation.frameIndex = ( itm.animation.frameIndex + 1 ) % itm.animation.frameCount;
			}
		}

		// reset counter
		animationCounter = 0;

	}
}

function resetAllAnimations() {
	for (id in sprite) {
		var spr = sprite[id];
		if (spr.animation.isAnimated) {
			spr.animation.frameIndex = 0;
		}
	}

	for (id in tile) {
		var til = tile[id];
		if (til.animation.isAnimated) {
			til.animation.frameIndex = 0;
		}
	}

	for (id in item) {
		var itm = item[id];
		if (itm.animation.isAnimated) {
			itm.animation.frameIndex = 0;
		}
	}
}

function getSpriteAt(x,y) {
	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === curRoom) {
			if (spr.x == x && spr.y == y) {
				return id;
			}
		}
	}
	return null;
}

var Direction = {
	None : -1,
	Up : 0,
	Down : 1,
	Left : 2,
	Right : 3
};

var curPlayerDirection = Direction.None;
var playerHoldToMoveTimer = 0;

var InputManager = function() {
	var self = this;

	var pressed;
	var ignored;
	var newKeyPress;
	var touchState;

	function resetAll() {
		pressed = {};
		ignored = {};
		newKeyPress = false;

		touchState = {
			isDown : false,
			startX : 0,
			startY : 0,
			curX : 0,
			curY : 0,
			swipeDistance : 30,
			swipeDirection : Direction.None,
			tapReleased : false
		};
	}
	resetAll();

	function stopWindowScrolling(e) {
		if(e.keyCode == key.left || e.keyCode == key.right || e.keyCode == key.up || e.keyCode == key.down || !isPlayerEmbeddedInEditor)
			e.preventDefault();
	}

	function tryRestartGame(e) {
		/* RESTART GAME */
		if ( e.keyCode === key.r && ( e.getModifierState("Control") || e.getModifierState("Meta") ) ) {
			if ( confirm("Restart the game?") ) {
				reset_cur_game();
			}
		}
	}

	function eventIsModifier(event) {
		return (event.keyCode == key.shift || event.keyCode == key.ctrl || event.keyCode == key.alt || event.keyCode == key.cmd);
	}

	function isModifierKeyDown() {
		return ( self.isKeyDown(key.shift) || self.isKeyDown(key.ctrl) || self.isKeyDown(key.alt) || self.isKeyDown(key.cmd) );
	}

	this.ignoreHeldKeys = function() {
		for (var key in pressed) {
			if (pressed[key]) { // only ignore keys that are actually held
				ignored[key] = true;
				// console.log("IGNORE -- " + key);
			}
		}
	}

	this.onkeydown = function(event) {
		// console.log("KEYDOWN -- " + event.keyCode);

		stopWindowScrolling(event);

		tryRestartGame(event);

		// Special keys being held down can interfere with keyup events and lock movement
		// so just don't collect input when they're held
		{
			if (isModifierKeyDown()) {
				return;
			}

			if (eventIsModifier(event)) {
				resetAll();
			}
		}

		if (ignored[event.keyCode]) {
			return;
		}

		if (!self.isKeyDown(event.keyCode)) {
			newKeyPress = true;
		}

		pressed[event.keyCode] = true;
		ignored[event.keyCode] = false;
	}

	this.onkeyup = function(event) {
		// console.log("KEYUP -- " + event.keyCode);
		pressed[event.keyCode] = false;
		ignored[event.keyCode] = false;
	}

	this.ontouchstart = function(event) {
		event.preventDefault();

		if( event.changedTouches.length > 0 ) {
			touchState.isDown = true;

			touchState.startX = touchState.curX = event.changedTouches[0].clientX;
			touchState.startY = touchState.curY = event.changedTouches[0].clientY;

			touchState.swipeDirection = Direction.None;
		}
	}

	this.ontouchmove = function(event) {
		event.preventDefault();

		if( touchState.isDown && event.changedTouches.length > 0 ) {
			touchState.curX = event.changedTouches[0].clientX;
			touchState.curY = event.changedTouches[0].clientY;

			var prevDirection = touchState.swipeDirection;

			if( touchState.curX - touchState.startX <= -touchState.swipeDistance ) {
				touchState.swipeDirection = Direction.Left;
			}
			else if( touchState.curX - touchState.startX >= touchState.swipeDistance ) {
				touchState.swipeDirection = Direction.Right;
			}
			else if( touchState.curY - touchState.startY <= -touchState.swipeDistance ) {
				touchState.swipeDirection = Direction.Up;
			}
			else if( touchState.curY - touchState.startY >= touchState.swipeDistance ) {
				touchState.swipeDirection = Direction.Down;
			}

			if( touchState.swipeDirection != prevDirection ) {
				// reset center so changing directions is easier
				touchState.startX = touchState.curX;
				touchState.startY = touchState.curY;
			}
		}
	}

	this.ontouchend = function(event) {
		event.preventDefault();

		touchState.isDown = false;

		if( touchState.swipeDirection == Direction.None ) {
			// tap!
			touchState.tapReleased = true;
		}

		touchState.swipeDirection = Direction.None;
	}

	this.isKeyDown = function(keyCode) {
		return pressed[keyCode] != null && pressed[keyCode] == true && (ignored[keyCode] == null || ignored[keyCode] == false);
	}

	this.anyKeyPressed = function() {
		return newKeyPress;
	}

	this.resetKeyPressed = function() {
		newKeyPress = false;
	}

	this.swipeLeft = function() {
		return touchState.swipeDirection == Direction.Left;
	}

	this.swipeRight = function() {
		return touchState.swipeDirection == Direction.Right;
	}

	this.swipeUp = function() {
		return touchState.swipeDirection == Direction.Up;
	}

	this.swipeDown = function() {
		return touchState.swipeDirection == Direction.Down;
	}

	this.isTapReleased = function() {
		return touchState.tapReleased;
	}

	this.resetTapReleased = function() {
		touchState.tapReleased = false;
	}

	this.onblur = function() {
		// console.log("~~~ BLUR ~~");
		resetAll();
	}
}
var input = null;

function movePlayer(direction) {
	if (player().room == null || !Object.keys(room).includes(player().room)) {
		return; // player room is missing or invalid.. can't move them!
	}

	var spr = null;

	if ( curPlayerDirection == Direction.Left && !(spr = getSpriteLeft()) && !isWallLeft()) {
		player().x -= 1;
	}
	else if ( curPlayerDirection == Direction.Right && !(spr = getSpriteRight()) && !isWallRight()) {
		player().x += 1;
	}
	else if ( curPlayerDirection == Direction.Up && !(spr = getSpriteUp()) && !isWallUp()) {
		player().y -= 1;
	}
	else if ( curPlayerDirection == Direction.Down && !(spr = getSpriteDown()) && !isWallDown()) {
		player().y += 1;
	}
	
	var ext = getExit( player().room, player().x, player().y );
	var end = getEnding( player().room, player().x, player().y );
	var itmIndex = getItemIndex( player().room, player().x, player().y );

	// do items first, because you can pick up an item AND go through a door
	if (itmIndex > -1) {
		var itm = room[player().room].items[itmIndex];
		var itemRoom = player().room;

		startItemDialog(itm.id, function() {
			// remove item from room
			room[itemRoom].items.splice(itmIndex, 1);

			// update player inventory
			if (player().inventory[itm.id]) {
				player().inventory[itm.id] += 1;
			}
			else {
				player().inventory[itm.id] = 1;
			}

			// show inventory change in UI
			if (onInventoryChanged != null) {
				onInventoryChanged(itm.id);
			}
		});
	}

	if (end) {
		startEndingDialog(end);
	}
	else if (ext) {
		movePlayerThroughExit(ext);
	}
	else if (spr) {
		startSpriteDialog(spr /*spriteId*/);
	}
}

var transition = new TransitionManager();

function movePlayerThroughExit(ext) {
	var GoToDest = function() {
		if (ext.transition_effect != null) {
			transition.BeginTransition(player().room, player().x, player().y, ext.dest.room, ext.dest.x, ext.dest.y, ext.transition_effect);
			transition.UpdateTransition(0);
		}

		player().room = ext.dest.room;
		player().x = ext.dest.x;
		player().y = ext.dest.y;
		curRoom = ext.dest.room;

		initRoom(curRoom);
	};

	if (ext.dlg != undefined && ext.dlg != null) {
		// TODO : I need to simplify dialog code,
		// so I don't have to get the ID and the source str
		// every time!
		startDialog(
			dialog[ext.dlg].src,
			ext.dlg,
			function(result) {
				var isLocked = ext.property && ext.property.locked === true;
				if (!isLocked) {
					GoToDest();
				}
			},
			ext);
	}
	else {
		GoToDest();
	}
}

function initRoom(roomId) {
	// init exit properties
	for (var i = 0; i < room[roomId].exits.length; i++) {
		room[roomId].exits[i].property = { locked:false };
	}

	// init ending properties
	for (var i = 0; i < room[roomId].endings.length; i++) {
		room[roomId].endings[i].property = { locked:false };
	}
}

function getItemIndex( roomId, x, y ) {
	for( var i = 0; i < room[roomId].items.length; i++ ) {
		var itm = room[roomId].items[i];
		if ( itm.x == x && itm.y == y)
			return i;
	}
	return -1;
}

function getSpriteLeft() { //repetitive?
	return getSpriteAt( player().x - 1, player().y );
}

function getSpriteRight() {
	return getSpriteAt( player().x + 1, player().y );
}

function getSpriteUp() {
	return getSpriteAt( player().x, player().y - 1 );
}

function getSpriteDown() {
	return getSpriteAt( player().x, player().y + 1 );
}

function isWallLeft() {
	return (player().x - 1 < 0) || isWall( player().x - 1, player().y );
}

function isWallRight() {
	return (player().x + 1 >= 16) || isWall( player().x + 1, player().y );
}

function isWallUp() {
	return (player().y - 1 < 0) || isWall( player().x, player().y - 1 );
}

function isWallDown() {
	return (player().y + 1 >= 16) || isWall( player().x, player().y + 1 );
}

function isWall(x,y,roomId) {
	if(roomId == undefined || roomId == null)
		roomId = curRoom;

	var tileId = getTile( x, y );

	if( tileId === '0' )
		return false; // Blank spaces aren't walls, ya doofus

	if( tile[tileId].isWall === undefined || tile[tileId].isWall === null ) {
		// No wall-state defined: check room-specific walls
		var i = room[roomId].walls.indexOf( getTile(x,y) );
		return i > -1;
	}

	// Otherwise, use the tile's own wall-state
	return tile[tileId].isWall;
}

function getItem(roomId,x,y) {
	for (i in room[roomId].items) {
		var item = room[roomId].items[i];
		if (x == item.x && y == item.y) {
			return item;
		}
	}
	return null;
}

function getExit(roomId,x,y) {
	for (i in room[roomId].exits) {
		var e = room[roomId].exits[i];
		if (x == e.x && y == e.y) {
			return e;
		}
	}
	return null;
}

function getEnding(roomId,x,y) {
	for (i in room[roomId].endings) {
		var e = room[roomId].endings[i];
		if (x == e.x && y == e.y) {
			return e;
		}
	}
	return null;
}

function getTile(x,y) {
	// console.log(x + " " + y);
	var t = getRoom().tilemap[y][x];
	return t;
}

function player() {
	return sprite[playerId];
}

// Sort of a hack for legacy palette code (when it was just an array)
function getPal(id) {
	if (palette[id] === undefined) {
		id = "default";
	}

	return palette[ id ].colors;
}

function getRoom() {
	return room[curRoom];
}

function isSpriteOffstage(id) {
	return sprite[id].room == null;
}

function parseWorld(file) {
	spriteStartLocations = {};

	resetFlags();

	var versionNumber = 0;

	// flags to keep track of which compatibility conversions
	// need to be applied to this game data
	var compatibilityFlags = {
		convertSayToPrint : false,
		combineEndingsWithDialog : false,
		convertImplicitSpriteDialogIds : false,
	};

	var lines = file.split("\n");
	var i = 0;
	while (i < lines.length) {
		var curLine = lines[i];

		// console.log(lines[i]);

		if (i == 0) {
			i = parseTitle(lines, i);
		}
		else if (curLine.length <= 0 || curLine.charAt(0) === "#") {
			// collect version number (from a comment.. hacky I know)
			if (curLine.indexOf("# BITSY VERSION ") != -1) {
				versionNumber = parseFloat(curLine.replace("# BITSY VERSION ", ""));

				if (versionNumber < 5.0) {
					compatibilityFlags.convertSayToPrint = true;
				}

				if (versionNumber < 7.0) {
					compatibilityFlags.combineEndingsWithDialog = true;
					compatibilityFlags.convertImplicitSpriteDialogIds = true;
				}
			}

			//skip blank lines & comments
			i++;
		}
		else if (getType(curLine) == "PAL") {
			i = parsePalette(lines, i);
		}
		else if (getType(curLine) === "ROOM" || getType(curLine) === "SET") { //SET for back compat
			i = parseRoom(lines, i, compatibilityFlags);
		}
		else if (getType(curLine) === "TIL") {
			i = parseTile(lines, i);
		}
		else if (getType(curLine) === "SPR") {
			i = parseSprite(lines, i);
		}
		else if (getType(curLine) === "ITM") {
			i = parseItem(lines, i);
		}
		else if (getType(curLine) === "DRW") {
			i = parseDrawing(lines, i);
		}
		else if (getType(curLine) === "DLG") {
			i = parseDialog(lines, i, compatibilityFlags);
		}
		else if (getType(curLine) === "END" && compatibilityFlags.combineEndingsWithDialog) {
			// parse endings for back compat
			i = parseEnding(lines, i, compatibilityFlags);
		}
		else if (getType(curLine) === "VAR") {
			i = parseVariable(lines, i);
		}
		else if (getType(curLine) === "DEFAULT_FONT") {
			i = parseFontName(lines, i);
		}
		else if (getType(curLine) === "TEXT_DIRECTION") {
			i = parseTextDirection(lines, i);
		}
		else if (getType(curLine) === "FONT") {
			i = parseFontData(lines, i);
		}
		else if (getType(curLine) === "!") {
			i = parseFlag(lines, i);
		}
		else {
			i++;
		}
	}

	placeSprites();

	var roomIds = Object.keys(room);
	if (player() != undefined && player().room != null && roomIds.includes(player().room)) {
		// player has valid room
		curRoom = player().room;
	}
	else if (roomIds.length > 0) {
		// player not in any room! what the heck
		curRoom = roomIds[0];
	}
	else {
		// uh oh there are no rooms I guess???
		curRoom = null;
	}

	if (curRoom != null) {
		initRoom(curRoom);
	}

	renderer.SetPalettes(palette);

	scriptCompatibility(compatibilityFlags);

	return versionNumber;
}

function scriptCompatibility(compatibilityFlags) {
	if (compatibilityFlags.convertSayToPrint) {
		console.log("CONVERT SAY TO PRINT!");

		var PrintFunctionVisitor = function() {
			var didChange = false;
			this.DidChange = function() { return didChange; };

			this.Visit = function(node) {
				if (node.type != "function") {
					return;
				}

				if (node.name === "say") {
					node.name = "print";
					didChange = true;
				}
			};
		};

		for (dlgId in dialog) {
			var dialogScript = scriptInterpreter.Parse(dialog[dlgId].src);
			var visitor = new PrintFunctionVisitor();
			dialogScript.VisitAll(visitor);
			if (visitor.DidChange()) {
				var newDialog = dialogScript.Serialize();
				if (newDialog.indexOf("\n") > -1) {
					newDialog = '"""\n' + newDialog + '\n"""';
				}
				dialog[dlgId].src = newDialog;
			}
		}
	}
}

//TODO this is in progress and doesn't support all features
function serializeWorld(skipFonts) {
	if (skipFonts === undefined || skipFonts === null)
		skipFonts = false;

	var worldStr = "";
	/* TITLE */
	worldStr += getTitle() + "\n";
	worldStr += "\n";
	/* VERSION */
	worldStr += "# BITSY VERSION " + getEngineVersion() + "\n"; // add version as a comment for debugging purposes
	if (version.devBuildPhase != "RELEASE") {
		worldStr += "# DEVELOPMENT BUILD -- " + version.devBuildPhase;
	}
	worldStr += "\n";
	/* FLAGS */
	for (f in flags) {
		worldStr += "! " + f + " " + flags[f] + "\n";
	}
	worldStr += "\n"
	/* FONT */
	if (fontName != defaultFontName) {
		worldStr += "DEFAULT_FONT " + fontName + "\n";
		worldStr += "\n"
	}
	if (textDirection != TextDirection.LeftToRight) {
		worldStr += "TEXT_DIRECTION " + textDirection + "\n";
		worldStr += "\n"
	}
	/* PALETTE */
	for (id in palette) {
		if (id != "default") {
			worldStr += "PAL " + id + "\n";
			if( palette[id].name != null )
				worldStr += "NAME " + palette[id].name + "\n";
			for (i in getPal(id)) {
				for (j in getPal(id)[i]) {
					worldStr += getPal(id)[i][j];
					if (j < 2) worldStr += ",";
				}
				worldStr += "\n";
			}
			worldStr += "\n";
		}
	}
	/* ROOM */
	for (id in room) {
		worldStr += "ROOM " + id + "\n";
		if ( flags.ROOM_FORMAT == 0 ) {
			// old non-comma separated format
			for (i in room[id].tilemap) {
				for (j in room[id].tilemap[i]) {
					worldStr += room[id].tilemap[i][j];	
				}
				worldStr += "\n";
			}
		}
		else if ( flags.ROOM_FORMAT == 1 ) {
			// new comma separated format
			for (i in room[id].tilemap) {
				for (j in room[id].tilemap[i]) {
					worldStr += room[id].tilemap[i][j];
					if (j < room[id].tilemap[i].length-1) worldStr += ","
				}
				worldStr += "\n";
			}
		}
		if (room[id].name != null) {
			/* NAME */
			worldStr += "NAME " + room[id].name + "\n";
		}
		if (room[id].walls.length > 0) {
			/* WALLS */
			worldStr += "WAL ";
			for (j in room[id].walls) {
				worldStr += room[id].walls[j];
				if (j < room[id].walls.length-1) {
					worldStr += ",";
				}
			}
			worldStr += "\n";
		}
		if (room[id].items.length > 0) {
			/* ITEMS */
			for (j in room[id].items) {
				var itm = room[id].items[j];
				worldStr += "ITM " + itm.id + " " + itm.x + "," + itm.y;
				worldStr += "\n";
			}
		}
		if (room[id].exits.length > 0) {
			/* EXITS */
			for (j in room[id].exits) {
				var e = room[id].exits[j];
				if ( isExitValid(e) ) {
					worldStr += "EXT " + e.x + "," + e.y + " " + e.dest.room + " " + e.dest.x + "," + e.dest.y;
					if (e.transition_effect != undefined && e.transition_effect != null) {
						worldStr += " FX " + e.transition_effect;
					}
					if (e.dlg != undefined && e.dlg != null) {
						worldStr += " DLG " + e.dlg;
					}
					worldStr += "\n";
				}
			}
		}
		if (room[id].endings.length > 0) {
			/* ENDINGS */
			for (j in room[id].endings) {
				var e = room[id].endings[j];
				// todo isEndingValid
				worldStr += "END " + e.id + " " + e.x + "," + e.y;
				worldStr += "\n";
			}
		}
		if (room[id].pal != null && room[id].pal != "default") {
			/* PALETTE */
			worldStr += "PAL " + room[id].pal + "\n";
		}
		worldStr += "\n";
	}
	/* TILES */
	for (id in tile) {
		worldStr += "TIL " + id + "\n";
		worldStr += serializeDrawing( "TIL_" + id );
		if (tile[id].name != null && tile[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + tile[id].name + "\n";
		}
		if (tile[id].isWall != null && tile[id].isWall != undefined) {
			/* WALL */
			worldStr += "WAL " + tile[id].isWall + "\n";
		}
		if (tile[id].col != null && tile[id].col != undefined && tile[id].col != 1) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + tile[id].col + "\n";
		}
		worldStr += "\n";
	}
	/* SPRITES */
	for (id in sprite) {
		worldStr += "SPR " + id + "\n";
		worldStr += serializeDrawing( "SPR_" + id );
		if (sprite[id].name != null && sprite[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + sprite[id].name + "\n";
		}
		if (sprite[id].dlg != null) {
			worldStr += "DLG " + sprite[id].dlg + "\n";
		}
		if (sprite[id].room != null) {
			/* SPRITE POSITION */
			worldStr += "POS " + sprite[id].room + " " + sprite[id].x + "," + sprite[id].y + "\n";
		}
		if (sprite[id].inventory != null) {
			for(itemId in sprite[id].inventory) {
				worldStr += "ITM " + itemId + " " + sprite[id].inventory[itemId] + "\n";
			}
		}
		if (sprite[id].col != null && sprite[id].col != undefined && sprite[id].col != 2) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + sprite[id].col + "\n";
		}
		worldStr += "\n";
	}
	/* ITEMS */
	for (id in item) {
		worldStr += "ITM " + id + "\n";
		worldStr += serializeDrawing( "ITM_" + id );
		if (item[id].name != null && item[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + item[id].name + "\n";
		}
		if (item[id].dlg != null) {
			worldStr += "DLG " + item[id].dlg + "\n";
		}
		if (item[id].col != null && item[id].col != undefined && item[id].col != 2) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + item[id].col + "\n";
		}
		worldStr += "\n";
	}
	/* DIALOG */
	for (id in dialog) {
		if (id != titleDialogId) {
			worldStr += "DLG " + id + "\n";
			worldStr += dialog[id].src + "\n";
			if (dialog[id].name != null) {
				worldStr += "NAME " + dialog[id].name + "\n";
			}
			worldStr += "\n";
		}
	}
	/* VARIABLES */
	for (id in variable) {
		worldStr += "VAR " + id + "\n";
		worldStr += variable[id] + "\n";
		worldStr += "\n";
	}
	/* FONT */
	// TODO : support multiple fonts
	if (fontName != defaultFontName && !skipFonts) {
		worldStr += fontManager.GetData(fontName);
	}

	return worldStr;
}

function serializeDrawing(drwId) {
	var imageSource = renderer.GetImageSource(drwId);
	var drwStr = "";
	for (f in imageSource) {
		for (y in imageSource[f]) {
			var rowStr = "";
			for (x in imageSource[f][y]) {
				rowStr += imageSource[f][y][x];
			}
			drwStr += rowStr + "\n";
		}
		if (f < (imageSource.length-1)) drwStr += ">\n";
	}
	return drwStr;
}

function isExitValid(e) {
	var hasValidStartPos = e.x >= 0 && e.x < 16 && e.y >= 0 && e.y < 16;
	var hasDest = e.dest != null;
	var hasValidRoomDest = (e.dest.room != null && e.dest.x >= 0 && e.dest.x < 16 && e.dest.y >= 0 && e.dest.y < 16);
	return hasValidStartPos && hasDest && hasValidRoomDest;
}

function placeSprites() {
	for (id in spriteStartLocations) {
		//console.log(id);
		//console.log( spriteStartLocations[id] );
		//console.log(sprite[id]);
		sprite[id].room = spriteStartLocations[id].room;
		sprite[id].x = spriteStartLocations[id].x;
		sprite[id].y = spriteStartLocations[id].y;
		//console.log(sprite[id]);
	}
}

/* ARGUMENT GETTERS */
function getType(line) {
	return getArg(line,0);
}

function getId(line) {
	return getArg(line,1);
}

function getArg(line,arg) {
	return line.split(" ")[arg];
}

function getCoord(line,arg) {
	return getArg(line,arg).split(",");
}

function parseTitle(lines, i) {
	var results = scriptUtils.ReadDialogScript(lines,i);
	setTitle(results.script);
	i = results.index;

	i++;

	return i;
}

function parseRoom(lines, i, compatibilityFlags) {
	var id = getId(lines[i]);
	room[id] = {
		id : id,
		tilemap : [],
		walls : [],
		exits : [],
		endings : [],
		items : [],
		pal : null,
		name : null
	};
	i++;

	// create tile map
	if ( flags.ROOM_FORMAT == 0 ) {
		// old way: no commas, single char tile ids
		var end = i + mapsize;
		var y = 0;
		for (; i<end; i++) {
			room[id].tilemap.push( [] );
			for (x = 0; x<mapsize; x++) {
				room[id].tilemap[y].push( lines[i].charAt(x) );
			}
			y++;
		}
	}
	else if ( flags.ROOM_FORMAT == 1 ) {
		// new way: comma separated, multiple char tile ids
		var end = i + mapsize;
		var y = 0;
		for (; i<end; i++) {
			room[id].tilemap.push( [] );
			var lineSep = lines[i].split(",");
			for (x = 0; x<mapsize; x++) {
				room[id].tilemap[y].push( lineSep[x] );
			}
			y++;
		}
	}

	while (i < lines.length && lines[i].length > 0) { //look for empty line
		// console.log(getType(lines[i]));
		if (getType(lines[i]) === "SPR") {
			/* NOTE SPRITE START LOCATIONS */
			var sprId = getId(lines[i]);
			if (sprId.indexOf(",") == -1 && lines[i].split(" ").length >= 3) { //second conditional checks for coords
				/* PLACE A SINGLE SPRITE */
				var sprCoord = lines[i].split(" ")[2].split(",");
				spriteStartLocations[sprId] = {
					room : id,
					x : parseInt(sprCoord[0]),
					y : parseInt(sprCoord[1])
				};
			}
			else if ( flags.ROOM_FORMAT == 0 ) { // TODO: right now this shortcut only works w/ the old comma separate format
				/* PLACE MULTIPLE SPRITES*/ 
				//Does find and replace in the tilemap (may be hacky, but its convenient)
				var sprList = sprId.split(",");
				for (row in room[id].tilemap) {
					for (s in sprList) {
						var col = room[id].tilemap[row].indexOf( sprList[s] );
						//if the sprite is in this row, replace it with the "null tile" and set its starting position
						if (col != -1) {
							room[id].tilemap[row][col] = "0";
							spriteStartLocations[ sprList[s] ] = {
								room : id,
								x : parseInt(col),
								y : parseInt(row)
							};
						}
					}
				}
			}
		}
		else if (getType(lines[i]) === "ITM") {
			var itmId = getId(lines[i]);
			var itmCoord = lines[i].split(" ")[2].split(",");
			var itm = {
				id: itmId,
				x : parseInt(itmCoord[0]),
				y : parseInt(itmCoord[1])
			};
			room[id].items.push( itm );
		}
		else if (getType(lines[i]) === "WAL") {
			/* DEFINE COLLISIONS (WALLS) */
			room[id].walls = getId(lines[i]).split(",");
		}
		else if (getType(lines[i]) === "EXT") {
			/* ADD EXIT */
			var exitArgs = lines[i].split(" ");
			//arg format: EXT 10,5 M 3,2 [AVA:7 LCK:a,9] [AVA 7 LCK a 9]
			var exitCoords = exitArgs[1].split(",");
			var destName = exitArgs[2];
			var destCoords = exitArgs[3].split(",");
			var ext = {
				x : parseInt(exitCoords[0]),
				y : parseInt(exitCoords[1]),
				dest : {
					room : destName,
					x : parseInt(destCoords[0]),
					y : parseInt(destCoords[1])
				},
				transition_effect : null,
				dlg: null,
			};

			// optional arguments
			var exitArgIndex = 4;
			while (exitArgIndex < exitArgs.length) {
				if (exitArgs[exitArgIndex] == "FX") {
					ext.transition_effect = exitArgs[exitArgIndex+1];
					exitArgIndex += 2;
				}
				else if (exitArgs[exitArgIndex] == "DLG") {
					ext.dlg = exitArgs[exitArgIndex+1];
					exitArgIndex += 2;
				}
				else {
					exitArgIndex += 1;
				}
			}

			room[id].exits.push(ext);
		}
		else if (getType(lines[i]) === "END") {
			/* ADD ENDING */
			var endId = getId(lines[i]);

			// compatibility with when endings were stored separate from other dialog
			if (compatibilityFlags.combineEndingsWithDialog) {
				endId = "end_" + endId;
			}

			var endCoords = getCoord(lines[i], 2);
			var end = {
				id : endId,
				x : parseInt(endCoords[0]),
				y : parseInt(endCoords[1])
			};

			room[id].endings.push(end);
		}
		else if (getType(lines[i]) === "PAL") {
			/* CHOOSE PALETTE (that's not default) */
			room[id].pal = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			var name = lines[i].split(/\s(.+)/)[1];
			room[id].name = name;
			names.room.set(name, id);
		}

		i++;
	}

	return i;
}

function parsePalette(lines,i) { //todo this has to go first right now :(
	var id = getId(lines[i]);
	i++;
	var colors = [];
	var name = null;
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		var args = lines[i].split(" ");
		if (args[0] === "NAME") {
			name = lines[i].split(/\s(.+)/)[1];
		}
		else {
			var col = [];
			lines[i].split(",").forEach(function(i) {
				col.push(parseInt(i));
			});
			colors.push(col);
		}
		i++;
	}
	palette[id] = {
		id : id,
		name : name,
		colors : colors
	};
	return i;
}

function parseTile(lines, i) {
	var id = getId(lines[i]);
	var drwId = null;
	var name = null;

	i++;

	if (getType(lines[i]) === "DRW") { //load existing drawing
		drwId = getId(lines[i]);
		i++;
	}
	else {
		// store tile source
		drwId = "TIL_" + id;
		i = parseDrawingCore( lines, i, drwId );
	}

	//other properties
	var colorIndex = 1; // default palette color index is 1
	var isWall = null; // null indicates it can vary from room to room (original version)
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		if (getType(lines[i]) === "COL") {
			colorIndex = parseInt( getId(lines[i]) );
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			name = lines[i].split(/\s(.+)/)[1];
			names.tile.set( name, id );
		}
		else if (getType(lines[i]) === "WAL") {
			var wallArg = getArg( lines[i], 1 );
			if( wallArg === "true" ) {
				isWall = true;
			}
			else if( wallArg === "false" ) {
				isWall = false;
			}
		}
		i++;
	}

	//tile data
	tile[id] = {
		id : id,
		drw : drwId, //drawing id
		col : colorIndex,
		animation : {
			isAnimated : (renderer.GetFrameCount(drwId) > 1),
			frameIndex : 0,
			frameCount : renderer.GetFrameCount(drwId)
		},
		name : name,
		isWall : isWall
	};

	return i;
}

function parseSprite(lines, i) {
	var id = getId(lines[i]);
	var drwId = null;
	var name = null;

	i++;

	if (getType(lines[i]) === "DRW") { //load existing drawing
		drwId = getId(lines[i]);
		i++;
	}
	else {
		// store sprite source
		drwId = "SPR_" + id;
		i = parseDrawingCore( lines, i, drwId );
	}

	//other properties
	var colorIndex = 2; //default palette color index is 2
	var dialogId = null;
	var startingInventory = {};
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		if (getType(lines[i]) === "COL") {
			/* COLOR OFFSET INDEX */
			colorIndex = parseInt( getId(lines[i]) );
		}
		else if (getType(lines[i]) === "POS") {
			/* STARTING POSITION */
			var posArgs = lines[i].split(" ");
			var roomId = posArgs[1];
			var coordArgs = posArgs[2].split(",");
			spriteStartLocations[id] = {
				room : roomId,
				x : parseInt(coordArgs[0]),
				y : parseInt(coordArgs[1])
			};
		}
		else if(getType(lines[i]) === "DLG") {
			dialogId = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			name = lines[i].split(/\s(.+)/)[1];
			names.sprite.set( name, id );
		}
		else if (getType(lines[i]) === "ITM") {
			/* ITEM STARTING INVENTORY */
			var itemId = getId(lines[i]);
			var itemCount = parseFloat( getArg(lines[i], 2) );
			startingInventory[itemId] = itemCount;
		}
		i++;
	}

	//sprite data
	sprite[id] = {
		id : id,
		drw : drwId, //drawing id
		col : colorIndex,
		dlg : dialogId,
		room : null, //default location is "offstage"
		x : -1,
		y : -1,
		animation : {
			isAnimated : (renderer.GetFrameCount(drwId) > 1),
			frameIndex : 0,
			frameCount : renderer.GetFrameCount(drwId)
		},
		inventory : startingInventory,
		name : name
	};
	return i;
}

function parseItem(lines, i) {
	var id = getId(lines[i]);
	var drwId = null;
	var name = null;

	i++;

	if (getType(lines[i]) === "DRW") { //load existing drawing
		drwId = getId(lines[i]);
		i++;
	}
	else {
		// store item source
		drwId = "ITM_" + id; // these prefixes are maybe a terrible way to differentiate drawing tyepes :/
		i = parseDrawingCore( lines, i, drwId );
	}

	//other properties
	var colorIndex = 2; //default palette color index is 2
	var dialogId = null;
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		if (getType(lines[i]) === "COL") {
			/* COLOR OFFSET INDEX */
			colorIndex = parseInt( getArg( lines[i], 1 ) );
		}
		// else if (getType(lines[i]) === "POS") {
		// 	/* STARTING POSITION */
		// 	var posArgs = lines[i].split(" ");
		// 	var roomId = posArgs[1];
		// 	var coordArgs = posArgs[2].split(",");
		// 	spriteStartLocations[id] = {
		// 		room : roomId,
		// 		x : parseInt(coordArgs[0]),
		// 		y : parseInt(coordArgs[1])
		// 	};
		// }
		else if(getType(lines[i]) === "DLG") {
			dialogId = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			name = lines[i].split(/\s(.+)/)[1];
			names.item.set( name, id );
		}
		i++;
	}

	//item data
	item[id] = {
		id : id,
		drw : drwId, //drawing id
		col : colorIndex,
		dlg : dialogId,
		// room : null, //default location is "offstage"
		// x : -1,
		// y : -1,
		animation : {
			isAnimated : (renderer.GetFrameCount(drwId) > 1),
			frameIndex : 0,
			frameCount : renderer.GetFrameCount(drwId)
		},
		name : name
	};

	// console.log("ITM " + id);
	// console.log(item[id]);

	return i;
}

function parseDrawing(lines, i) {
	// store drawing source
	var drwId = getId( lines[i] );
	return parseDrawingCore( lines, i, drwId );
}

function parseDrawingCore(lines, i, drwId) {
	var frameList = []; //init list of frames
	frameList.push( [] ); //init first frame
	var frameIndex = 0;
	var y = 0;
	while ( y < tilesize ) {
		var l = lines[i+y];
		var row = [];
		for (x = 0; x < tilesize; x++) {
			row.push( parseInt( l.charAt(x) ) );
		}
		frameList[frameIndex].push( row );
		y++;

		if (y === tilesize) {
			i = i + y;
			if ( lines[i] != undefined && lines[i].charAt(0) === ">" ) {
				// start next frame!
				frameList.push( [] );
				frameIndex++;
				//start the count over again for the next frame
				i++;
				y = 0;
			}
		}
	}

	renderer.SetImageSource(drwId, frameList);

	return i;
}

function parseScript(lines, i, backCompatPrefix, compatibilityFlags) {
	var id = getId(lines[i]);
	id = backCompatPrefix + id;
	i++;

	var results = scriptUtils.ReadDialogScript(lines,i);

	dialog[id] = { src:results.script, name:null };

	if (compatibilityFlags.convertImplicitSpriteDialogIds) {
		// explicitly hook up dialog that used to be implicitly
		// connected by sharing sprite and dialog IDs in old versions
		if (sprite[id]) {
			if (sprite[id].dlg === undefined || sprite[id].dlg === null) {
				sprite[id].dlg = id;
			}
		}
	}

	i = results.index;

	return i;
}

function parseDialog(lines, i, compatibilityFlags) {
	// hacky but I need to store this so I can set the name below
	var id = getId(lines[i]);

	i = parseScript(lines, i, "", compatibilityFlags);

	if (lines[i].length > 0 && getType(lines[i]) === "NAME") {
		dialog[id].name = lines[i].split(/\s(.+)/)[1]; // TODO : hacky to keep copying this regex around...
		names.dialog.set(dialog[id].name, id);
		i++;
	}

	return i;
}

// keeping this around to parse old files where endings were separate from dialogs
function parseEnding(lines, i, compatibilityFlags) {
	return parseScript(lines, i, "end_", compatibilityFlags);
}

function parseVariable(lines, i) {
	var id = getId(lines[i]);
	i++;
	var value = lines[i];
	i++;
	variable[id] = value;
	return i;
}

function parseFontName(lines, i) {
	fontName = getArg(lines[i], 1);
	i++;
	return i;
}

function parseTextDirection(lines, i) {
	textDirection = getArg(lines[i], 1);
	i++;
	return i;
}

function parseFontData(lines, i) {
	// NOTE : we're not doing the actual parsing here --
	// just grabbing the block of text that represents the font
	// and giving it to the font manager to use later

	var localFontName = getId(lines[i]);
	var localFontData = lines[i];
	i++;

	while (i < lines.length && lines[i] != "") {
		localFontData += "\n" + lines[i];
		i++;
	}

	var localFontFilename = localFontName + fontManager.GetExtension();
	fontManager.AddResource( localFontFilename, localFontData );

	return i;
}

function parseFlag(lines, i) {
	var id = getId(lines[i]);
	var valStr = lines[i].split(" ")[2];
	flags[id] = parseInt( valStr );
	i++;
	return i;
}

function drawTile(img,x,y,context) {
	if (!context) { //optional pass in context; otherwise, use default
		context = ctx;
	}
	// NOTE: images are now canvases, instead of raw image data (for chrome performance reasons)
	context.drawImage(img,x*tilesize*scale,y*tilesize*scale,tilesize*scale,tilesize*scale);
}

function drawSprite(img,x,y,context) { //this may differ later (or not haha)
	drawTile(img,x,y,context);
}

function drawItem(img,x,y,context) {
	drawTile(img,x,y,context); //TODO these methods are dumb and repetitive
}

// var debugLastRoomDrawn = "0";

function drawRoom(room,context,frameIndex) { // context & frameIndex are optional
	if (!context) { //optional pass in context; otherwise, use default (ok this is REAL hacky isn't it)
		context = ctx;
	}

	// if (room.id != debugLastRoomDrawn) {
	// 	debugLastRoomDrawn = room.id;
	// 	console.log("DRAW ROOM " + debugLastRoomDrawn);
	// }

	var paletteId = "default";

	if (room === undefined) {
		// protect against invalid rooms
		context.fillStyle = "rgb(" + getPal(paletteId)[0][0] + "," + getPal(paletteId)[0][1] + "," + getPal(paletteId)[0][2] + ")";
		context.fillRect(0,0,canvas.width,canvas.height);
		return;
	}

	//clear screen
	if (room.pal != null && palette[paletteId] != undefined) {
		paletteId = room.pal;
	}
	context.fillStyle = "rgb(" + getPal(paletteId)[0][0] + "," + getPal(paletteId)[0][1] + "," + getPal(paletteId)[0][2] + ")";
	context.fillRect(0,0,canvas.width,canvas.height);

	//draw tiles
	for (i in room.tilemap) {
		for (j in room.tilemap[i]) {
			var id = room.tilemap[i][j];
			if (id != "0") {
				//console.log(id);
				if (tile[id] == null) { // hack-around to avoid corrupting files (not a solution though!)
					id = "0";
					room.tilemap[i][j] = id;
				}
				else {
					// console.log(id);
					drawTile( getTileImage(tile[id],paletteId,frameIndex), j, i, context );
				}
			}
		}
	}

	//draw items
	for (var i = 0; i < room.items.length; i++) {
		var itm = room.items[i];
		drawItem( getItemImage(item[itm.id],paletteId,frameIndex), itm.x, itm.y, context );
	}

	//draw sprites
	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === room.id) {
			drawSprite( getSpriteImage(spr,paletteId,frameIndex), spr.x, spr.y, context );
		}
	}
}

// TODO : remove these get*Image methods
function getTileImage(t,palId,frameIndex) {
	return renderer.GetImage(t,palId,frameIndex);
}

function getSpriteImage(s,palId,frameIndex) {
	return renderer.GetImage(s,palId,frameIndex);
}

function getItemImage(itm,palId,frameIndex) {
	return renderer.GetImage(itm,palId,frameIndex);
}

function curPal() {
	return getRoomPal(curRoom);
}

function getRoomPal(roomId) {
	var defaultId = "default";

	if (roomId == null) {
		return defaultId;
	}
	else if (room[roomId].pal != null) {
		//a specific palette was chosen
		return room[roomId].pal;
	}
	else {
		if (roomId in palette) {
			//there is a palette matching the name of the room
			return roomId;
		}
		else {
			//use the default palette
			return defaultId;
		}
	}
	return defaultId;
}

var isDialogMode = false;
var isNarrating = false;
var isEnding = false;
var dialogModule = new Dialog();
var dialogRenderer = dialogModule.CreateRenderer();
var dialogBuffer = dialogModule.CreateBuffer();
var fontManager = new FontManager();

// TODO : is this scriptResult thing being used anywhere???
function onExitDialog(scriptResult, dialogCallback) {
	console.log("EXIT DIALOG!");

	isDialogMode = false;

	if (isNarrating) {
		isNarrating = false;
	}

	if (isDialogPreview) {
		isDialogPreview = false;

		if (onDialogPreviewEnd != null) {
			onDialogPreviewEnd();
		}
	}

	if (dialogCallback != undefined && dialogCallback != null) {
		dialogCallback(scriptResult);
	}
}

/*
TODO
- titles and endings should also take advantage of the script pre-compilation if possible??
- could there be a namespace collision?
- what about dialog NAMEs vs IDs?
- what about a special script block separate from DLG?
*/
function startNarrating(dialogStr,end) {
	console.log("NARRATE " + dialogStr);

	if(end === undefined) {
		end = false;
	}

	isNarrating = true;
	isEnding = end;

	startDialog(dialogStr);
}

function startEndingDialog(ending) {
	isNarrating = true;
	isEnding = true;

	startDialog(
		dialog[ending.id].src,
		ending.id,
		function() {
			var isLocked = ending.property && ending.property.locked === true;
			if (isLocked) {
				isEnding = false;
			}
		},
		ending);
}

function startItemDialog(itemId, dialogCallback) {
	var dialogId = item[itemId].dlg;
	// console.log("START ITEM DIALOG " + dialogId);
	if (dialog[dialogId]) {
		var dialogStr = dialog[dialogId].src;
		startDialog(dialogStr, dialogId, dialogCallback);
	}
	else {
		dialogCallback();
	}
}

function startSpriteDialog(spriteId) {
	var spr = sprite[spriteId];
	var dialogId = spr.dlg;
	// console.log("START SPRITE DIALOG " + dialogId);
	if (dialog[dialogId]){
		var dialogStr = dialog[dialogId].src;
		startDialog(dialogStr,dialogId);
	}
}

function startDialog(dialogStr, scriptId, dialogCallback, objectContext) {
	// console.log("START DIALOG ");
	if (dialogStr.length <= 0) {
		// console.log("ON EXIT DIALOG -- startDialog 1");
		onExitDialog(null, dialogCallback);
		return;
	}

	isDialogMode = true;

	dialogRenderer.Reset();
	dialogRenderer.SetCentered(isNarrating /*centered*/);
	dialogBuffer.Reset();
	scriptInterpreter.SetDialogBuffer(dialogBuffer);

	var onScriptEnd = function(scriptResult) {
		dialogBuffer.OnDialogEnd(function() {
			onExitDialog(scriptResult, dialogCallback);
		});
	};

	if (scriptId === undefined) { // TODO : what's this for again?
		scriptInterpreter.Interpret(dialogStr, onScriptEnd);
	}
	else {
		if (!scriptInterpreter.HasScript(scriptId)) {
			scriptInterpreter.Compile(scriptId, dialogStr);
		}
		// scriptInterpreter.DebugVisualizeScript(scriptId);
		scriptInterpreter.Run(scriptId, onScriptEnd, objectContext);
	}

}

var isDialogPreview = false;
function startPreviewDialog(script, dialogCallback) {
	isNarrating = true;

	isDialogMode = true;

	isDialogPreview = true;

	dialogRenderer.Reset();
	dialogRenderer.SetCentered(true);
	dialogBuffer.Reset();
	scriptInterpreter.SetDialogBuffer(dialogBuffer);

	// TODO : do I really need a seperate callback for this debug mode??
	onDialogPreviewEnd = dialogCallback;

	var onScriptEndCallback = function(scriptResult) {
		dialogBuffer.OnDialogEnd(function() {
			onExitDialog(scriptResult, null);
		});
	};

	scriptInterpreter.Eval(script, onScriptEndCallback);
}

/* NEW SCRIPT STUFF */
var scriptModule = new Script();
var scriptInterpreter = scriptModule.CreateInterpreter();
var scriptUtils = scriptModule.CreateUtils(); // TODO: move to editor.js?
// scriptInterpreter.SetDialogBuffer( dialogBuffer );

</script>

<!-- store default font in separate script tag for back compat-->
<script type="text/bitsyFontData" id="ascii_small">
FONT ascii_small
SIZE 6 8
CHAR 0
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 1
001110
010001
011011
010001
010101
010001
001110
000000
CHAR 2
001110
011111
010101
011111
010001
011111
001110
000000
CHAR 3
000000
001010
011111
011111
011111
001110
000100
000000
CHAR 4
000000
000000
001010
001110
001110
000100
000000
000000
CHAR 5
000100
001110
001110
000100
011111
011111
000100
000000
CHAR 6
000000
000100
001110
011111
011111
000100
001110
000000
CHAR 7
000000
000000
000000
001100
001100
000000
000000
000000
CHAR 8
111111
111111
111111
110011
110011
111111
111111
111111
CHAR 9
000000
000000
011110
010010
010010
011110
000000
000000
CHAR 10
111111
111111
100001
101101
101101
100001
111111
111111
CHAR 11
000000
000111
000011
001101
010010
010010
001100
000000
CHAR 12
001110
010001
010001
001110
000100
001110
000100
000000
CHAR 13
000100
000110
000101
000100
001100
011100
011000
000000
CHAR 14
000011
001101
001011
001101
001011
011011
011000
000000
CHAR 15
000000
010101
001110
011011
001110
010101
000000
000000
CHAR 16
001000
001100
001110
001111
001110
001100
001000
000000
CHAR 17
000010
000110
001110
011110
001110
000110
000010
000000
CHAR 18
000100
001110
011111
000100
011111
001110
000100
000000
CHAR 19
001010
001010
001010
001010
001010
000000
001010
000000
CHAR 20
001111
010101
010101
001101
000101
000101
000101
000000
CHAR 21
001110
010001
001100
001010
000110
010001
001110
000000
CHAR 22
000000
000000
000000
000000
000000
011110
011110
000000
CHAR 23
000100
001110
011111
000100
011111
001110
000100
001110
CHAR 24
000100
001110
011111
000100
000100
000100
000100
000000
CHAR 25
000100
000100
000100
000100
011111
001110
000100
000000
CHAR 26
000000
000100
000110
011111
000110
000100
000000
000000
CHAR 27
000000
000100
001100
011111
001100
000100
000000
000000
CHAR 28
000000
000000
000000
010000
010000
010000
011111
000000
CHAR 29
000000
001010
001010
011111
001010
001010
000000
000000
CHAR 30
000100
000100
001110
001110
011111
011111
000000
000000
CHAR 31
011111
011111
001110
001110
000100
000100
000000
000000
CHAR 32
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 33
000100
001110
001110
000100
000100
000000
000100
000000
CHAR 34
011011
011011
010010
000000
000000
000000
000000
000000
CHAR 35
000000
001010
011111
001010
001010
011111
001010
000000
CHAR 36
001000
001110
010000
001100
000010
011100
000100
000000
CHAR 37
011001
011001
000010
000100
001000
010011
010011
000000
CHAR 38
001000
010100
010100
001000
010101
010010
001101
000000
CHAR 39
001100
001100
001000
000000
000000
000000
000000
000000
CHAR 40
000100
001000
001000
001000
001000
001000
000100
000000
CHAR 41
001000
000100
000100
000100
000100
000100
001000
000000
CHAR 42
000000
001010
001110
011111
001110
001010
000000
000000
CHAR 43
000000
000100
000100
011111
000100
000100
000000
000000
CHAR 44
000000
000000
000000
000000
000000
001100
001100
001000
CHAR 45
000000
000000
000000
011111
000000
000000
000000
000000
CHAR 46
000000
000000
000000
000000
000000
001100
001100
000000
CHAR 47
000000
000001
000010
000100
001000
010000
000000
000000
CHAR 48
001110
010001
010011
010101
011001
010001
001110
000000
CHAR 49
000100
001100
000100
000100
000100
000100
001110
000000
CHAR 50
001110
010001
000001
000110
001000
010000
011111
000000
CHAR 51
001110
010001
000001
001110
000001
010001
001110
000000
CHAR 52
000010
000110
001010
010010
011111
000010
000010
000000
CHAR 53
011111
010000
010000
011110
000001
010001
001110
000000
CHAR 54
000110
001000
010000
011110
010001
010001
001110
000000
CHAR 55
011111
000001
000010
000100
001000
001000
001000
000000
CHAR 56
001110
010001
010001
001110
010001
010001
001110
000000
CHAR 57
001110
010001
010001
001111
000001
000010
001100
000000
CHAR 58
000000
000000
001100
001100
000000
001100
001100
000000
CHAR 59
000000
000000
001100
001100
000000
001100
001100
001000
CHAR 60
000010
000100
001000
010000
001000
000100
000010
000000
CHAR 61
000000
000000
011111
000000
000000
011111
000000
000000
CHAR 62
001000
000100
000010
000001
000010
000100
001000
000000
CHAR 63
001110
010001
000001
000110
000100
000000
000100
000000
CHAR 64
001110
010001
010111
010101
010111
010000
001110
000000
CHAR 65
001110
010001
010001
010001
011111
010001
010001
000000
CHAR 66
011110
010001
010001
011110
010001
010001
011110
000000
CHAR 67
001110
010001
010000
010000
010000
010001
001110
000000
CHAR 68
011110
010001
010001
010001
010001
010001
011110
000000
CHAR 69
011111
010000
010000
011110
010000
010000
011111
000000
CHAR 70
011111
010000
010000
011110
010000
010000
010000
000000
CHAR 71
001110
010001
010000
010111
010001
010001
001111
000000
CHAR 72
010001
010001
010001
011111
010001
010001
010001
000000
CHAR 73
001110
000100
000100
000100
000100
000100
001110
000000
CHAR 74
000001
000001
000001
000001
010001
010001
001110
000000
CHAR 75
010001
010010
010100
011000
010100
010010
010001
000000
CHAR 76
010000
010000
010000
010000
010000
010000
011111
000000
CHAR 77
010001
011011
010101
010001
010001
010001
010001
000000
CHAR 78
010001
011001
010101
010011
010001
010001
010001
000000
CHAR 79
001110
010001
010001
010001
010001
010001
001110
000000
CHAR 80
011110
010001
010001
011110
010000
010000
010000
000000
CHAR 81
001110
010001
010001
010001
010101
010010
001101
000000
CHAR 82
011110
010001
010001
011110
010010
010001
010001
000000
CHAR 83
001110
010001
010000
001110
000001
010001
001110
000000
CHAR 84
011111
000100
000100
000100
000100
000100
000100
000000
CHAR 85
010001
010001
010001
010001
010001
010001
001110
000000
CHAR 86
010001
010001
010001
010001
010001
001010
000100
000000
CHAR 87
010001
010001
010101
010101
010101
010101
001010
000000
CHAR 88
010001
010001
001010
000100
001010
010001
010001
000000
CHAR 89
010001
010001
010001
001010
000100
000100
000100
000000
CHAR 90
011110
000010
000100
001000
010000
010000
011110
000000
CHAR 91
001110
001000
001000
001000
001000
001000
001110
000000
CHAR 92
000000
010000
001000
000100
000010
000001
000000
000000
CHAR 93
001110
000010
000010
000010
000010
000010
001110
000000
CHAR 94
000100
001010
010001
000000
000000
000000
000000
000000
CHAR 95
000000
000000
000000
000000
000000
000000
000000
111111
CHAR 96
001100
001100
000100
000000
000000
000000
000000
000000
CHAR 97
000000
000000
001110
000001
001111
010001
001111
000000
CHAR 98
010000
010000
011110
010001
010001
010001
011110
000000
CHAR 99
000000
000000
001110
010001
010000
010001
001110
000000
CHAR 100
000001
000001
001111
010001
010001
010001
001111
000000
CHAR 101
000000
000000
001110
010001
011110
010000
001110
000000
CHAR 102
000110
001000
001000
011110
001000
001000
001000
000000
CHAR 103
000000
000000
001111
010001
010001
001111
000001
001110
CHAR 104
010000
010000
011100
010010
010010
010010
010010
000000
CHAR 105
000100
000000
000100
000100
000100
000100
000110
000000
CHAR 106
000010
000000
000110
000010
000010
000010
010010
001100
CHAR 107
010000
010000
010010
010100
011000
010100
010010
000000
CHAR 108
000100
000100
000100
000100
000100
000100
000110
000000
CHAR 109
000000
000000
011010
010101
010101
010001
010001
000000
CHAR 110
000000
000000
011100
010010
010010
010010
010010
000000
CHAR 111
000000
000000
001110
010001
010001
010001
001110
000000
CHAR 112
000000
000000
011110
010001
010001
010001
011110
010000
CHAR 113
000000
000000
001111
010001
010001
010001
001111
000001
CHAR 114
000000
000000
010110
001001
001000
001000
011100
000000
CHAR 115
000000
000000
001110
010000
001110
000001
001110
000000
CHAR 116
000000
001000
011110
001000
001000
001010
000100
000000
CHAR 117
000000
000000
010010
010010
010010
010110
001010
000000
CHAR 118
000000
000000
010001
010001
010001
001010
000100
000000
CHAR 119
000000
000000
010001
010001
010101
011111
001010
000000
CHAR 120
000000
000000
010010
010010
001100
010010
010010
000000
CHAR 121
000000
000000
010010
010010
010010
001110
000100
011000
CHAR 122
000000
000000
011110
000010
001100
010000
011110
000000
CHAR 123
000110
001000
001000
011000
001000
001000
000110
000000
CHAR 124
000100
000100
000100
000100
000100
000100
000100
000100
CHAR 125
001100
000010
000010
000011
000010
000010
001100
000000
CHAR 126
001010
010100
000000
000000
000000
000000
000000
000000
CHAR 127
000100
001110
011011
010001
010001
011111
000000
000000
CHAR 128
001110
010001
010000
010000
010001
001110
000100
001100
CHAR 129
010010
000000
010010
010010
010010
010110
001010
000000
CHAR 130
000011
000000
001110
010001
011110
010000
001110
000000
CHAR 131
001110
000000
001110
000001
001111
010001
001111
000000
CHAR 132
001010
000000
001110
000001
001111
010001
001111
000000
CHAR 133
001100
000000
001110
000001
001111
010001
001111
000000
CHAR 134
001110
001010
001110
000001
001111
010001
001111
000000
CHAR 135
000000
001110
010001
010000
010001
001110
000100
001100
CHAR 136
001110
000000
001110
010001
011110
010000
001110
000000
CHAR 137
001010
000000
001110
010001
011110
010000
001110
000000
CHAR 138
001100
000000
001110
010001
011110
010000
001110
000000
CHAR 139
001010
000000
000100
000100
000100
000100
000110
000000
CHAR 140
000100
001010
000000
000100
000100
000100
000110
000000
CHAR 141
001000
000000
000100
000100
000100
000100
000110
000000
CHAR 142
001010
000000
000100
001010
010001
011111
010001
000000
CHAR 143
001110
001010
001110
011011
010001
011111
010001
000000
CHAR 144
000011
000000
011111
010000
011110
010000
011111
000000
CHAR 145
000000
000000
011110
000101
011111
010100
001111
000000
CHAR 146
001111
010100
010100
011111
010100
010100
010111
000000
CHAR 147
001110
000000
001100
010010
010010
010010
001100
000000
CHAR 148
001010
000000
001100
010010
010010
010010
001100
000000
CHAR 149
011000
000000
001100
010010
010010
010010
001100
000000
CHAR 150
001110
000000
010010
010010
010010
010110
001010
000000
CHAR 151
011000
000000
010010
010010
010010
010110
001010
000000
CHAR 152
001010
000000
010010
010010
010010
001110
000100
011000
CHAR 153
010010
001100
010010
010010
010010
010010
001100
000000
CHAR 154
001010
000000
010010
010010
010010
010010
001100
000000
CHAR 155
000000
000100
001110
010000
010000
001110
000100
000000
CHAR 156
000110
001001
001000
011110
001000
001001
010111
000000
CHAR 157
010001
001010
000100
011111
000100
011111
000100
000000
CHAR 158
011000
010100
010100
011010
010111
010010
010010
000000
CHAR 159
000010
000101
000100
001110
000100
000100
010100
001000
CHAR 160
000110
000000
001110
000001
001111
010001
001111
000000
CHAR 161
000110
000000
000100
000100
000100
000100
000110
000000
CHAR 162
000110
000000
001100
010010
010010
010010
001100
000000
CHAR 163
000110
000000
010010
010010
010010
010110
001010
000000
CHAR 164
001010
010100
000000
011100
010010
010010
010010
000000
CHAR 165
001010
010100
000000
010010
011010
010110
010010
000000
CHAR 166
001110
000001
001111
010001
001111
000000
001111
000000
CHAR 167
001100
010010
010010
010010
001100
000000
011110
000000
CHAR 168
000100
000000
000100
001100
010000
010001
001110
000000
CHAR 169
000000
000000
011111
010000
010000
010000
000000
000000
CHAR 170
000000
000000
111111
000001
000001
000000
000000
000000
CHAR 171
010000
010010
010100
001110
010001
000010
000111
000000
CHAR 172
010000
010010
010100
001011
010101
000111
000001
000000
CHAR 173
000100
000000
000100
000100
001110
001110
000100
000000
CHAR 174
000000
000000
001001
010010
001001
000000
000000
000000
CHAR 175
000000
000000
010010
001001
010010
000000
000000
000000
CHAR 176
010101
000000
101010
000000
010101
000000
101010
000000
CHAR 177
010101
101010
010101
101010
010101
101010
010101
101010
CHAR 178
101010
111111
010101
111111
101010
111111
010101
111111
CHAR 179
000100
000100
000100
000100
000100
000100
000100
000100
CHAR 180
000100
000100
000100
111100
000100
000100
000100
000100
CHAR 181
000000
000000
010010
010010
010010
011100
010000
010000
CHAR 182
010100
010100
010100
110100
010100
010100
010100
010100
CHAR 183
000000
000000
000000
111100
010100
010100
010100
010100
CHAR 184
000000
111100
000100
111100
000100
000100
000100
000100
CHAR 185
010100
110100
000100
110100
010100
010100
010100
010100
CHAR 186
010100
010100
010100
010100
010100
010100
010100
010100
CHAR 187
000000
111100
000100
110100
010100
010100
010100
010100
CHAR 188
010100
110100
000100
111100
000000
000000
000000
000000
CHAR 189
010100
010100
010100
111100
000000
000000
000000
000000
CHAR 190
000100
111100
000100
111100
000000
000000
000000
000000
CHAR 191
000000
000000
000000
111100
000100
000100
000100
000100
CHAR 192
000100
000100
000100
000111
000000
000000
000000
000000
CHAR 193
000100
000100
000100
111111
000000
000000
000000
000000
CHAR 194
000000
000000
000000
111111
000100
000100
000100
000100
CHAR 195
000100
000100
000100
000111
000100
000100
000100
000100
CHAR 196
000000
000000
000000
111111
000000
000000
000000
000000
CHAR 197
000100
000100
000100
111111
000100
000100
000100
000100
CHAR 198
000100
000111
000100
000111
000100
000100
000100
000100
CHAR 199
010100
010100
010100
010111
010100
010100
010100
010100
CHAR 200
010100
010111
010000
011111
000000
000000
000000
000000
CHAR 201
000000
011111
010000
010111
010100
010100
010100
010100
CHAR 202
010100
110111
000000
111111
000000
000000
000000
000000
CHAR 203
000000
111111
000000
110111
010100
010100
010100
010100
CHAR 204
010100
010111
010000
010111
010100
010100
010100
010100
CHAR 205
000000
111111
000000
111111
000000
000000
000000
000000
CHAR 206
010100
110111
000000
110111
010100
010100
010100
010100
CHAR 207
000100
111111
000000
111111
000000
000000
000000
000000
CHAR 208
010100
010100
010100
111111
000000
000000
000000
000000
CHAR 209
000000
111111
000000
111111
000100
000100
000100
000100
CHAR 210
000000
000000
000000
111111
010100
010100
010100
010100
CHAR 211
010100
010100
010100
011111
000000
000000
000000
000000
CHAR 212
000000
000000
000000
000000
000000
000000
000000
111111
CHAR 213
000000
000000
000000
000000
000000
000000
111111
111111
CHAR 214
000000
000000
000000
000000
000000
111111
111111
111111
CHAR 215
000000
000000
000000
000000
111111
111111
111111
111111
CHAR 216
000000
000000
000000
111111
111111
111111
111111
111111
CHAR 217
000000
000000
111111
111111
111111
111111
111111
111111
CHAR 218
000000
111111
111111
111111
111111
111111
111111
111111
CHAR 219
111111
111111
111111
111111
111111
111111
111111
111111
CHAR 220
100000
100000
100000
100000
100000
100000
100000
100000
CHAR 221
110000
110000
110000
110000
110000
110000
110000
110000
CHAR 222
111000
111000
111000
111000
111000
111000
111000
111000
CHAR 223
111100
111100
111100
111100
111100
111100
111100
111100
CHAR 224
111110
111110
111110
111110
111110
111110
111110
111110
CHAR 225
000000
011100
010010
011100
010010
010010
011100
010000
CHAR 226
011110
010010
010000
010000
010000
010000
010000
000000
CHAR 227
000000
011111
001010
001010
001010
001010
001010
000000
CHAR 228
001010
000000
001110
000001
001111
010001
001111
000000
CHAR 229
000000
000000
001111
010010
010010
001100
000000
000000
CHAR 230
000000
000000
010010
010010
010010
011100
010000
010000
CHAR 231
000000
000000
001010
010100
000100
000100
000100
000000
CHAR 232
001110
000100
001110
010001
001110
000100
001110
000000
CHAR 233
001100
010010
010010
011110
010010
010010
001100
000000
CHAR 234
000000
001110
010001
010001
001010
001010
011011
000000
CHAR 235
001100
010000
001000
000100
001110
010010
001100
000000
CHAR 236
000000
000000
001010
010101
010101
001010
000000
000000
CHAR 237
000000
000100
001110
010101
010101
001110
000100
000000
CHAR 238
000000
001110
010000
011110
010000
001110
000000
000000
CHAR 239
000000
001100
010010
010010
010010
010010
000000
000000
CHAR 240
000000
011110
000000
011110
000000
011110
000000
000000
CHAR 241
000000
000100
001110
000100
000000
001110
000000
000000
CHAR 242
010000
001100
000010
001100
010000
000000
011110
000000
CHAR 243
000000
000000
111111
111000
100110
100001
100000
111111
CHAR 244
000000
000000
111111
000111
011001
100001
000001
111111
CHAR 245
000100
000100
000100
000100
000100
010100
001000
000000
CHAR 246
001010
000000
001110
010001
010001
010001
001110
000000
CHAR 247
111110
111110
111110
111110
111110
111110
111110
111110
CHAR 248
111100
111100
111100
111100
111100
111100
111100
111100
CHAR 249
111000
111000
111000
111000
111000
111000
111000
111000
CHAR 250
110000
110000
110000
110000
110000
110000
110000
110000
CHAR 251
100000
100000
100000
100000
100000
100000
100000
100000
CHAR 252
001010
000000
010010
010010
010010
010110
001010
000000
CHAR 253
011000
000100
001000
011100
000000
000000
000000
000000
CHAR 254
000000
000000
000000
011110
110010
110011
111110
001111
CHAR 255
010010
111111
010010
010010
111111
010010
000000
000000
</script>
</script>
<script>
 
    /**
    
    @file permanent items
    @summary prevent some items from being picked up
    @license MIT
    @version 15.0.1
    @requires 7.0
    @author Sean S. LeBlanc
    @description
    Prevents certain items from being picked up, but allows them to be walked over and triggers their dialog.
    HOW TO USE:
    1. Copy-paste this script into a script tag after the bitsy source
    2. Update the `itemIsPermanent` function below to match your needs
    */
    this.hacks = this.hacks || {};
    (function (exports, bitsy) {
    'use strict';
    var hackOptions = {
        itemIsPermanent: function (item) {
            // return item.name && item.name == 'tea'; // specific permanent item
            // return ['tea', 'flower', 'hat'].indexOf(item.name) !== -1; // specific permanent item list
            // return item.name && item.name.indexOf('PERMANENT') !== -1; // permanent item flag in name
            return true; // all items are permanent
        },
    };
    
    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }
    
    bitsy = bitsy || /*#__PURE__*/_interopDefaultLegacy(bitsy);
    
    /**
    @file utils
    @summary miscellaneous bitsy utilities
    @author Sean S. LeBlanc
    */
    
    /*
    Helper used to replace code in a script tag based on a search regex
    To inject code without erasing original string, using capturing groups; e.g.
        inject(/(some string)/,'injected before $1 injected after')
    */
    function inject(searchRegex, replaceString) {
        // find the relevant script tag
        var scriptTags = document.getElementsByTagName('script');
        var scriptTag;
        var code;
        for (var i = 0; i < scriptTags.length; ++i) {
            scriptTag = scriptTags[i];
            var matchesSearch = scriptTag.textContent.search(searchRegex) !== -1;
            var isCurrentScript = scriptTag === document.currentScript;
            if (matchesSearch && !isCurrentScript) {
                code = scriptTag.textContent;
                break;
            }
        }
    
        // error-handling
        if (!code) {
            throw new Error('Couldn\'t find "' + searchRegex + '" in script tags');
        }
    
        // modify the content
        code = code.replace(searchRegex, replaceString);
    
        // replace the old script tag with a new one using our modified code
        var newScriptTag = document.createElement('script');
        newScriptTag.textContent = code;
        scriptTag.insertAdjacentElement('afterend', newScriptTag);
        scriptTag.remove();
    }
    
    /**
     * Helper for getting an array with unique elements
     * @param  {Array} array Original array
     * @return {Array}       Copy of array, excluding duplicates
     */
    function unique(array) {
        return array.filter(function (item, idx) {
            return array.indexOf(item) === idx;
        });
    }
    
    /**
    @file kitsy-script-toolkit
    @summary makes it easier and cleaner to run code before and after Bitsy functions or to inject new code into Bitsy script tags
    @license WTFPL (do WTF you want)
    @requires Bitsy Version: 4.5, 4.6
    @author @mildmojo
    @description
    HOW TO USE:
      import {before, after, inject, addDialogTag, addDeferredDialogTag} from "./helpers/kitsy-script-toolkit";
      before(targetFuncName, beforeFn);
      after(targetFuncName, afterFn);
      inject(searchRegex, replaceString);
      addDialogTag(tagName, dialogFn);
      addDeferredDialogTag(tagName, dialogFn);
      For more info, see the documentation at:
      https://github.com/seleb/bitsy-hacks/wiki/Coding-with-kitsy
    */
    
    // Ex: before('load_game', function run() { alert('Loading!'); });
    //     before('show_text', function run(text) { return text.toUpperCase(); });
    //     before('show_text', function run(text, done) { done(text.toUpperCase()); });
    function before(targetFuncName, beforeFn) {
        var kitsy = kitsyInit();
        kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
        kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
    }
    
    function kitsyInit() {
        // return already-initialized kitsy
        if (bitsy.kitsy) {
            return bitsy.kitsy;
        }
    
        // Initialize kitsy
        bitsy.kitsy = {
            queuedInjectScripts: [],
            queuedBeforeScripts: {},
            queuedAfterScripts: {},
        };
    
        var oldStartFunc = bitsy.startExportedGame;
        bitsy.startExportedGame = function doAllInjections() {
            // Only do this once.
            bitsy.startExportedGame = oldStartFunc;
    
            // Rewrite scripts and hook everything up.
            doInjects();
            applyAllHooks();
    
            // Start the game
            bitsy.startExportedGame.apply(this, arguments);
        };
    
        return bitsy.kitsy;
    }
    
    function doInjects() {
        bitsy.kitsy.queuedInjectScripts.forEach(function (injectScript) {
            inject(injectScript.searchRegex, injectScript.replaceString);
        });
        reinitEngine();
    }
    
    function applyAllHooks() {
        var allHooks = unique(Object.keys(bitsy.kitsy.queuedBeforeScripts).concat(Object.keys(bitsy.kitsy.queuedAfterScripts)));
        allHooks.forEach(applyHook);
    }
    
    function applyHook(functionName) {
        var functionNameSegments = functionName.split('.');
        var obj = bitsy;
        while (functionNameSegments.length > 1) {
            obj = obj[functionNameSegments.shift()];
        }
        var lastSegment = functionNameSegments[0];
        var superFn = obj[lastSegment];
        var superFnLength = superFn ? superFn.length : 0;
        var functions = [];
        // start with befores
        functions = functions.concat(bitsy.kitsy.queuedBeforeScripts[functionName] || []);
        // then original
        if (superFn) {
            functions.push(superFn);
        }
        // then afters
        functions = functions.concat(bitsy.kitsy.queuedAfterScripts[functionName] || []);
    
        // overwrite original with one which will call each in order
        obj[lastSegment] = function () {
            var returnVal;
            var args = [].slice.call(arguments);
            var i = 0;
    
            function runBefore() {
                // All outta functions? Finish
                if (i === functions.length) {
                    return returnVal;
                }
    
                // Update args if provided.
                if (arguments.length > 0) {
                    args = [].slice.call(arguments);
                }
    
                if (functions[i].length > superFnLength) {
                    // Assume funcs that accept more args than the original are
                    // async and accept a callback as an additional argument.
                    return functions[i++].apply(this, args.concat(runBefore.bind(this)));
                }
                // run synchronously
                returnVal = functions[i++].apply(this, args);
                if (returnVal && returnVal.length) {
                    args = returnVal;
                }
                return runBefore.apply(this, args);
            }
    
            return runBefore.apply(this, arguments);
        };
    }
    
    function reinitEngine() {
        // recreate the script and dialog objects so that they'll be
        // referencing the code with injections instead of the original
        bitsy.scriptModule = new bitsy.Script();
        bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();
    
        bitsy.dialogModule = new bitsy.Dialog();
        bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
        bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
    }
    
    
    
    
    
    var room;
    var oldItems;
    before('movePlayer', function () {
        room = bitsy.room[bitsy.curRoom];
        oldItems = room.items.slice();
    });
    before('startItemDialog', function (itemId, dialogCallback) {
        // something changed
        if (!hackOptions.itemIsPermanent(bitsy.item[itemId])) {
            return undefined;
        }
        room = bitsy.room[bitsy.curRoom];
        oldItems = room.items.slice();
        return [itemId, function () {
            var newItems = room.items;
            if (newItems.length === oldItems.length) {
                return; // nothing changed
            }
    
            // check for changes
            for (var i = 0; i < oldItems.length; ++i) {
                if (!newItems[i]
                    || oldItems[i].x !== newItems[i].x
                    || oldItems[i].y !== newItems[i].y
                    || oldItems[i].id !== newItems[i].id
                ) {
                    // something changed
                    if (hackOptions.itemIsPermanent(bitsy.item[oldItems[i].id])) {
                        // put that back!
                        newItems.splice(i, 0, oldItems[i]);
                    } else {
                        // add an empty entry for now to keep the arrays aligned
                        newItems.splice(i, 0, null);
                    }
                }
            }
            // clear out those empty entries
            room.items = newItems.filter(function (item) {
                return !!item;
            });
    
            // run the actual callback
            if (dialogCallback) {
                dialogCallback();
            }
        }];
    });
    
    exports.hackOptions = hackOptions;
    
    }(this.hacks.permanent_items = this.hacks.permanent_items || {}, window));
    
    </script>
</head>


<!-- DOCUMENT BODY -->
<body onload='startExportedGame()'>
	<!-- GAME CANVAS -->
	<canvas id='game'></canvas>
</body>


</html>